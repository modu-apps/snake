<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Snake</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #111; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        #game-container { position: relative; }
        canvas { border: 2px solid #333; }
        #minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
        }
        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 16px;
            text-shadow: 1px 1px 2px #000;
        }
        #stats .length {
            font-size: 20px;
            font-weight: bold;
        }
        #stats .rank {
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game" width="1400" height="900"></canvas>
        <canvas id="minimap" width="200" height="200"></canvas>
        <div id="stats">
            <div>Your length: <span class="length">0</span></div>
            <div class="rank">Your rank: <span id="rank-text">- of -</span></div>
        </div>
    </div>

<script>
// Load SDK based on environment
(function() {
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const script = document.createElement('script');

    if (isLocalhost) {
        script.src = 'http://localhost:3001/dist/modu.iife.js?v=dev';
    } else {
        const version = Date.now();
        script.src = `https://cdn.moduengine.com/modu.min.js?v=${version}`;
    }

    script.onload = initGame;
    document.head.appendChild(script);
})();

function initGame() {
const canvas = document.getElementById('game');
const minimap = document.getElementById('minimap');
const minimapCtx = minimap.getContext('2d');
const statsLength = document.querySelector('#stats .length');
const statsRank = document.getElementById('rank-text');
const CANVAS_WIDTH = canvas.width, CANVAS_HEIGHT = canvas.height;

// World size (huge map)
const WORLD_WIDTH = 4000;
const WORLD_HEIGHT = 4000;

// Constants
const SPEED = 4;
const BASE_HEAD_RADIUS = 16;
const BASE_SEGMENT_RADIUS = 14;
const INITIAL_LENGTH = 15;
const FOOD_COUNT = 100;
const MAX_FOOD = 200;
const FOOD_SPAWN_CHANCE = 0.03;
const SEGMENT_SPAWN_INTERVAL = 3;
const TURN_SPEED = 0.15;

// Camera settings
const MIN_ZOOM = 0.3;
const MAX_ZOOM = 1.0;
const ZOOM_SPEED = 0.02;

// Size scaling settings
const SIZE_GROWTH_RATE = 0.02;
const MAX_SIZE_MULTIPLIER = 3;

// Camera state
let camera = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2, zoom: 1.0, targetZoom: 1.0 };
let localClientId = null;

const COLORS = [
    '#ff6b6b', '#4dabf7', '#69db7c', '#ffd43b', '#da77f2', '#ff8e72',
    '#38d9a9', '#748ffc', '#f783ac', '#a9e34b', '#3bc9db', '#9775fa'
];

// Calculate size multiplier based on snake length
function getSizeMultiplier(length) {
    const growth = 1 + (length - INITIAL_LENGTH) * SIZE_GROWTH_RATE;
    return Math.min(growth, MAX_SIZE_MULTIPLIER);
}

// Calculate zoom based on snake length
function getTargetZoom(length) {
    const sizeMultiplier = getSizeMultiplier(length);
    return Math.max(MIN_ZOOM, MAX_ZOOM / sizeMultiplier);
}

// Create game
const game = createGame();
const renderer = game.addPlugin(Simple2DRenderer, canvas);
const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });
window.game = game;

// Define components
const SnakeHead = defineComponent('SnakeHead', {
    length: INITIAL_LENGTH,
    dirX: 1,
    dirY: 0,
    prevDirX: 1,
    prevDirY: 0,
    lastSpawnFrame: { type: 'f32', default: 0 }
});

const SnakeSegment = defineComponent('SnakeSegment', {
    ownerId: 0,
    spawnFrame: { type: 'f32', default: 0 }
});

// Define entities
game.defineEntity('snake-head')
    .with(Transform2D)
    .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, layer: 2 })
    .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })
    .with(Player)
    .with(SnakeHead)
    .register();

game.defineEntity('snake-segment')
    .with(Transform2D)
    .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, layer: 1 })
    .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })
    .with(SnakeSegment)
    .register();

game.defineEntity('food')
    .with(Transform2D)
    .with(Sprite, { shape: SHAPE_CIRCLE, radius: 10, layer: 0 })
    .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: 10, bodyType: BODY_STATIC })
    .register();

// Helper functions
function killSnake(clientId) {
    const head = game.world.getEntityByClientId(clientId);
    if (!head || head.destroyed) return;

    for (const seg of game.query('snake-segment')) {
        if (seg.get(SnakeSegment).ownerId === clientId) {
            seg.destroy();
        }
    }
    head.destroy();
}

function spawnSnake(clientId) {
    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);
    const startX = 200 + (dRandom() * (WORLD_WIDTH - 400)) | 0;
    const startY = 200 + (dRandom() * (WORLD_HEIGHT - 400)) | 0;

    game.spawn('snake-head', {
        x: startX, y: startY, clientId, color,
        length: INITIAL_LENGTH,
        lastSpawnFrame: game.frame
    });
}

function spawnFood() {
    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);
    game.spawn('food', {
        x: 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0,
        y: 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0,
        color
    });
}

// Collision: head hits segment (die if not own)
physics.onCollision('snake-head', 'snake-segment', (head, segment) => {
    if (head.destroyed || segment.destroyed) return;
    const headClientId = head.get(Player).clientId;
    const segOwnerId = segment.get(SnakeSegment).ownerId;
    if (segOwnerId === headClientId) return;
    killSnake(headClientId);
});

// Collision: head eats food (grow)
physics.onCollision('snake-head', 'food', (head, food) => {
    if (food.destroyed) return;
    head.get(SnakeHead).length++;
    food.destroy();
});

// Movement system: move heads, spawn segments
game.addSystem(() => {
    for (const head of game.query('snake-head')) {
        const input = game.world.getInput(head.get(Player).clientId);
        const sh = head.get(SnakeHead);
        const t = head.get(Transform2D);

        sh.prevDirX = sh.dirX;
        sh.prevDirY = sh.dirY;

        let dirX = sh.dirX;
        let dirY = sh.dirY;

        if (input?.target) {
            const dx = input.target.x - t.x;
            const dy = input.target.y - t.y;
            const len = Math.sqrt(dx * dx + dy * dy);

            if (len > 0.1) {
                // Get current and desired angles
                const currentAngle = Math.atan2(dirY, dirX);
                const desiredAngle = Math.atan2(dy, dx);

                // Calculate shortest angle difference
                let angleDiff = desiredAngle - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                // Clamp to max turn speed (constant angular velocity)
                const turn = Math.max(-TURN_SPEED, Math.min(TURN_SPEED, angleDiff));

                // Apply turn
                const newAngle = currentAngle + turn;
                sh.dirX = Math.cos(newAngle);
                sh.dirY = Math.sin(newAngle);
            }
        }

        const moveTarget = { x: t.x + dirX * 1000, y: t.y + dirY * 1000 };
        head.moveTowards(moveTarget, SPEED);

        // Die if touching world boundary
        const radius = head.get(Sprite).radius;
        if (t.x - radius < 0 || t.x + radius > WORLD_WIDTH ||
            t.y - radius < 0 || t.y + radius > WORLD_HEIGHT) {
            killSnake(head.get(Player).clientId);
        }

        const frameDiff = game.frame - sh.lastSpawnFrame;
        if (frameDiff >= SEGMENT_SPAWN_INTERVAL) {
            const color = head.get(Sprite).color;
            const ownerId = head.get(Player).clientId;
            game.spawn('snake-segment', {
                x: t.x, y: t.y,
                color: color,
                ownerId: ownerId,
                spawnFrame: game.frame
            });
            sh.lastSpawnFrame = game.frame;
        }
    }
}, { phase: 'update' });

// Tail cleanup: remove old segments
game.addSystem(() => {
    const headMaxAge = new Map();
    for (const head of game.query('snake-head')) {
        const clientId = head.get(Player).clientId;
        const maxLength = head.get(SnakeHead).length;
        headMaxAge.set(clientId, game.frame - (maxLength * SEGMENT_SPAWN_INTERVAL));
    }

    for (const seg of game.query('snake-segment')) {
        const segData = seg.get(SnakeSegment);
        const oldestAllowed = headMaxAge.get(segData.ownerId);
        if (oldestAllowed !== undefined && segData.spawnFrame < oldestAllowed) {
            seg.destroy();
        }
    }
}, { phase: 'update' });

// Food spawning
game.addSystem(() => {
    if (game.getEntitiesByType('food').length < MAX_FOOD && dRandom() < FOOD_SPAWN_CHANCE) {
        spawnFood();
    }
}, { phase: 'update' });

// System to update snake sizes based on length
game.addSystem(() => {
    const ownerLengths = new Map();
    for (const head of game.query('snake-head')) {
        const clientId = head.get(Player).clientId;
        const length = head.get(SnakeHead).length;
        const sizeMult = getSizeMultiplier(length);
        ownerLengths.set(clientId, sizeMult);

        const headRadius = BASE_HEAD_RADIUS * sizeMult;
        head.get(Sprite).radius = headRadius;
        head.get(Body2D).radius = headRadius;
    }

    for (const seg of game.query('snake-segment')) {
        const ownerId = seg.get(SnakeSegment).ownerId;
        const sizeMult = ownerLengths.get(ownerId) || 1;
        const segRadius = BASE_SEGMENT_RADIUS * sizeMult;
        seg.get(Sprite).radius = segRadius;
        seg.get(Body2D).radius = segRadius;
    }
}, { phase: 'update' });

// Camera update system
game.addSystem(() => {
    if (localClientId === null) return;

    const head = game.world.getEntityByClientId(localClientId);
    if (!head || head.destroyed) return;

    const t = head.get(Transform2D);
    const length = head.get(SnakeHead).length;

    camera.targetZoom = getTargetZoom(length);
    camera.zoom += (camera.targetZoom - camera.zoom) * ZOOM_SPEED;
    camera.x = t.x;
    camera.y = t.y;
}, { phase: 'update' });

// Custom rendering with camera transform
const originalRender = renderer.render.bind(renderer);
renderer.render = function() {
    const ctx = renderer.context;
    const alpha = game.getRenderAlpha();

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    let camX = camera.x, camY = camera.y;
    const localHead = localClientId ? game.world.getEntityByClientId(localClientId) : null;

    if (localHead && !localHead.destroyed) {
        localHead.interpolate(alpha);
        const t = localHead.get(Transform2D);
        camX = localHead.render?.interpX ?? t.x;
        camY = localHead.render?.interpY ?? t.y;
    }

    ctx.save();
    ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camX, -camY);

    // Draw world bounds
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 4 / camera.zoom;
    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    // Draw grid
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1 / camera.zoom;
    const gridSize = 200;
    for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, WORLD_HEIGHT);
        ctx.stroke();
    }
    for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(WORLD_WIDTH, y);
        ctx.stroke();
    }

    // Draw food
    for (const food of game.query('food')) {
        if (food.destroyed) continue;
        food.interpolate(alpha);
        const x = food.render?.interpX ?? food.get(Transform2D).x;
        const y = food.render?.interpY ?? food.get(Transform2D).y;
        const sprite = food.get(Sprite);
        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';
        ctx.beginPath();
        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw snake segments
    for (const seg of game.query('snake-segment')) {
        if (seg.destroyed) continue;
        seg.interpolate(alpha);
        const x = seg.render?.interpX ?? seg.get(Transform2D).x;
        const y = seg.render?.interpY ?? seg.get(Transform2D).y;
        const sprite = seg.get(Sprite);
        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';
        ctx.beginPath();
        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw snake heads
    for (const head of game.query('snake-head')) {
        if (head.destroyed) continue;
        head.interpolate(alpha);
        const x = head.render?.interpX ?? head.get(Transform2D).x;
        const y = head.render?.interpY ?? head.get(Transform2D).y;
        const sprite = head.get(Sprite);
        const sh = head.get(SnakeHead);
        const sizeMult = getSizeMultiplier(sh.length);

        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';
        ctx.beginPath();
        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);
        ctx.fill();

        const dirX = sh.prevDirX + (sh.dirX - sh.prevDirX) * alpha;
        const dirY = sh.prevDirY + (sh.dirY - sh.prevDirY) * alpha;

        const eyeOffset = 6 * sizeMult;
        const eyeRadius = 5 * sizeMult;
        const pupilRadius = 2 * sizeMult;
        const perpX = -dirY, perpY = dirX;

        for (const side of [-1, 1]) {
            const ex = x + dirX * eyeOffset + perpX * eyeOffset * side;
            const ey = y + dirY * eyeOffset + perpY * eyeOffset * side;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ex, ey, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(ex + dirX * pupilRadius, ey + dirY * pupilRadius, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    ctx.restore();
    drawMinimap(camX, camY);
    updateStats();
};

// Update stats display
function updateStats() {
    if (!localClientId) return;

    const localHead = game.world.getEntityByClientId(localClientId);
    if (!localHead || localHead.destroyed) {
        statsLength.textContent = '0';
        statsRank.textContent = '- of -';
        return;
    }

    const myLength = localHead.get(SnakeHead).length;
    statsLength.textContent = myLength;

    // Calculate rank by sorting all snakes by length
    const snakes = [];
    for (const head of game.query('snake-head')) {
        if (head.destroyed) continue;
        snakes.push({
            clientId: head.get(Player).clientId,
            length: head.get(SnakeHead).length
        });
    }
    snakes.sort((a, b) => b.length - a.length);

    const rank = snakes.findIndex(s => s.clientId === localClientId) + 1;
    statsRank.textContent = `${rank} of ${snakes.length}`;
}

// Minimap rendering
function drawMinimap(camX, camY) {
    const mmW = minimap.width;
    const mmH = minimap.height;
    const scaleX = mmW / WORLD_WIDTH;
    const scaleY = mmH / WORLD_HEIGHT;

    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    minimapCtx.fillRect(0, 0, mmW, mmH);

    minimapCtx.strokeStyle = '#444';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(0, 0, mmW, mmH);

    minimapCtx.fillStyle = '#555';
    for (const food of game.query('food')) {
        if (food.destroyed) continue;
        const t = food.get(Transform2D);
        const mx = t.x * scaleX;
        const my = t.y * scaleY;
        minimapCtx.fillRect(mx - 1, my - 1, 2, 2);
    }

    for (const head of game.query('snake-head')) {
        if (head.destroyed) continue;
        const t = head.get(Transform2D);
        const sprite = head.get(Sprite);
        const color = game.getString('color', sprite.color) || '#fff';
        const clientId = head.get(Player).clientId;
        const isLocal = clientId === localClientId;

        minimapCtx.fillStyle = color;
        const mx = t.x * scaleX;
        const my = t.y * scaleY;
        minimapCtx.beginPath();
        minimapCtx.arc(mx, my, isLocal ? 4 : 3, 0, Math.PI * 2);
        minimapCtx.fill();

        if (isLocal) {
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(mx, my, 6, 0, Math.PI * 2);
            minimapCtx.stroke();
        }
    }

    const viewW = (CANVAS_WIDTH / camera.zoom) * scaleX;
    const viewH = (CANVAS_HEIGHT / camera.zoom) * scaleY;
    const viewX = camX * scaleX - viewW / 2;
    const viewY = camY * scaleY - viewH / 2;

    minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    minimapCtx.lineWidth = 1;
    minimapCtx.strokeRect(viewX, viewY, viewW, viewH);
}

// Input
const input = game.addPlugin(InputPlugin, canvas);
input.action('target', { type: 'vector', bindings: ['mouse'] });

// Convert screen to world coordinates
function screenToWorld(screenX, screenY) {
    return {
        x: camera.x + (screenX - CANVAS_WIDTH / 2) / camera.zoom,
        y: camera.y + (screenY - CANVAS_HEIGHT / 2) / camera.zoom
    };
}

// Override input to convert screen to world coordinates
const originalGetInput = game.world.getInput.bind(game.world);
game.world.getInput = function(clientId) {
    const inp = originalGetInput(clientId);
    if (inp?.target && clientId === localClientId) {
        // Only convert if not already converted (check for marker)
        if (!inp._worldConverted) {
            inp._screenTarget = { x: inp.target.x, y: inp.target.y };
            inp._worldConverted = true;
        }
        // Always convert from original screen coords
        inp.target = screenToWorld(inp._screenTarget.x, inp._screenTarget.y);
    }
    return inp;
};

// Connect
game.connect('snake-v7', {
    onRoomCreate() {
        for (let i = 0; i < FOOD_COUNT; i++) spawnFood();
    },
    onConnect(clientId) {
        if (localClientId === null) {
            localClientId = game.internClientId(clientId);
        }
        spawnSnake(clientId);
    },
    onDisconnect(clientId) {
        killSnake(game.internClientId(clientId));
    }
});

Modu.enableDebugUI(game);
}
</script>
</body>
</html>
