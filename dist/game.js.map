{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "/**\r\n * Snake Game - Slither.io style multiplayer\r\n * Build: 2026-01-07\r\n *\r\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\r\n */\r\n\r\nimport { createGame,\r\n    Game,\r\n    Entity,\r\n    Transform2D,\r\n    Body2D,\r\n    Player,\r\n    Sprite,\r\n    BODY_KINEMATIC,\r\n    BODY_STATIC,\r\n    SHAPE_CIRCLE,\r\n    Simple2DRenderer,\r\n    Physics2DSystem,\r\n    InputPlugin,\r\n    enableDebugUI,\r\n    defineComponent, dSqrt, dRandom } from 'modu-engine';\r\n\r\n// ============================================\r\n// Constants\r\n// ============================================\r\n\r\nconst WORLD_WIDTH = 4000;\r\nconst WORLD_HEIGHT = 4000;\r\n\r\nconst SPEED = 8;\r\nconst BOOST_SPEED = 18;\r\nconst BOOST_COST_FRAMES = 10;\r\nconst MIN_BOOST_LENGTH = 10;\r\nconst BASE_HEAD_RADIUS = 16;\r\nconst BASE_SEGMENT_RADIUS = 14;\r\nconst INITIAL_LENGTH = 15;\r\nconst FOOD_COUNT = 100;\r\nconst MAX_FOOD = 200;\r\nconst FOOD_SPAWN_CHANCE = 0.03;\r\nconst SEGMENT_SPAWN_INTERVAL = 1;\r\nconst TURN_SPEED = 0.15;\r\n\r\n// Camera settings\r\nconst MIN_ZOOM = 0.3;\r\nconst MAX_ZOOM = 1.0;\r\nconst ZOOM_SPEED = 0.02;\r\n\r\n// Size scaling\r\nconst SIZE_GROWTH_RATE = 0.02;\r\nconst MAX_SIZE_MULTIPLIER = 3;\r\n\r\nconst COLORS = [\r\n    '#ff6b6b', '#4dabf7', '#69db7c', '#ffd43b', '#da77f2', '#ff8e72',\r\n    '#38d9a9', '#748ffc', '#f783ac', '#a9e34b', '#3bc9db', '#9775fa'\r\n];\r\n\r\n// ============================================\r\n// Types\r\n// ============================================\r\n\r\ninterface Camera {\r\n    x: number;\r\n    y: number;\r\n    zoom: number;\r\n    targetZoom: number;\r\n}\r\n\r\n// ============================================\r\n// Game State\r\n// ============================================\r\n\r\nlet game: Game;\r\nlet renderer: Simple2DRenderer;\r\nlet physics: Physics2DSystem;\r\nlet input: InputPlugin;\r\n\r\nlet canvas: HTMLCanvasElement;\r\nlet minimapCanvas: HTMLCanvasElement;\r\nlet minimapCtx: CanvasRenderingContext2D;\r\nlet statsLength: HTMLElement;\r\nlet statsRank: HTMLElement;\r\nlet WIDTH: number;\r\nlet HEIGHT: number;\r\n\r\nconst camera: Camera = {\r\n    x: WORLD_WIDTH / 2,\r\n    y: WORLD_HEIGHT / 2,\r\n    zoom: 1.0,\r\n    targetZoom: 1.0\r\n};\r\n\r\nlet mouseX: number;\r\nlet mouseY: number;\r\nlet mouseDown = false;\r\n\r\n// ============================================\r\n// Components (all fields default to i32/fixed-point for determinism)\r\n// ============================================\r\n\r\nconst SnakeHead = defineComponent('SnakeHead', {\r\n    length: INITIAL_LENGTH,\r\n    dirX: 1,\r\n    dirY: 0,\r\n    prevDirX: 1,\r\n    prevDirY: 0,\r\n    lastSpawnFrame: 0,\r\n    boostFrames: 0,\r\n    boosting: 0\r\n});\r\n\r\nconst SnakeSegment = defineComponent('SnakeSegment', {\r\n    ownerId: 0,\r\n    spawnFrame: 0\r\n});\r\n\r\n// ============================================\r\n// Helper Functions\r\n// ============================================\r\n\r\nfunction getLocalClientId(): number | null {\r\n    const clientId = game.localClientId;\r\n    if (!clientId || typeof clientId !== 'string') return null;\r\n    // Don't intern temporary local clientIds - they're placeholders before real connection\r\n    if (clientId.startsWith('local-')) return null;\r\n    return game.internClientId(clientId);\r\n}\r\n\r\nfunction getClientIdStr(numericId: number): string {\r\n    return game.getClientIdString(numericId) || '';\r\n}\r\n\r\nfunction compareStrings(a: string, b: string): number {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n}\r\n\r\nfunction getSizeMultiplier(length: number): number {\r\n    const growth = 1 + (length - INITIAL_LENGTH) * SIZE_GROWTH_RATE;\r\n    return Math.min(growth, MAX_SIZE_MULTIPLIER);\r\n}\r\n\r\nfunction getTargetZoom(length: number): number {\r\n    const sizeMultiplier = getSizeMultiplier(length);\r\n    return Math.max(MIN_ZOOM, MAX_ZOOM / sizeMultiplier);\r\n}\r\n\r\nfunction killSnake(clientId: number): void {\r\n    const head = game.world.getEntityByClientId(clientId);\r\n    if (!head || head.destroyed) return;\r\n\r\n    // Sort segments before destroying for deterministic order\r\n    const segments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n    for (const seg of segments) {\r\n        if (seg.get(SnakeSegment).ownerId === clientId) {\r\n            seg.destroy();\r\n        }\r\n    }\r\n    head.destroy();\r\n}\r\n\r\nfunction spawnSnake(clientId: string): void {\r\n    // CRITICAL: Always consume random values to maintain RNG synchronization,\r\n    // even if we end up not spawning the snake (due to duplicate detection).\r\n    // The engine isolates RNG in onConnect, but we should still be consistent.\r\n    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);\r\n    const startX = 200 + (dRandom() * (WORLD_WIDTH - 400)) | 0;\r\n    const startY = 200 + (dRandom() * (WORLD_HEIGHT - 400)) | 0;\r\n\r\n    // Check if snake already exists for this client AFTER consuming random values.\r\n    // This prevents duplicate spawns due to network race conditions where\r\n    // onConnect might be called multiple times (e.g., once from snapshot\r\n    // restoration and again from a late-arriving join input).\r\n    const numericClientId = game.internClientId(clientId);\r\n    const existingHead = game.world.getEntityByClientId(numericClientId);\r\n    if (existingHead && !existingHead.destroyed) {\r\n        console.log(`[spawnSnake] Snake already exists for client ${clientId.slice(0, 8)}, skipping spawn`);\r\n        return;\r\n    }\r\n\r\n    // Set lastSpawnFrame to current frame + 10 to delay segment spawning.\r\n    // This gives late joiners time to fully synchronize before spawning segments,\r\n    // preventing entity ID allocation mismatches during catch-up simulation.\r\n    game.spawn('snake-head', {\r\n        x: startX, y: startY, clientId, color,\r\n        length: INITIAL_LENGTH,\r\n        lastSpawnFrame: game.frame + 10\r\n    });\r\n}\r\n\r\nfunction spawnFood(): void {\r\n    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);\r\n    const x = 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0;\r\n    const y = 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0;\r\n    game.spawn('food', { x, y, color });\r\n}\r\n\r\n// ============================================\r\n// Entity Definitions\r\n// ============================================\r\n\r\nfunction defineEntities(): void {\r\n    game.defineEntity('snake-head')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, layer: 2 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })\r\n        .with(Player)\r\n        .with(SnakeHead)\r\n        .register();\r\n\r\n    game.defineEntity('snake-segment')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, layer: 1 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })\r\n        .with(SnakeSegment)\r\n        .register();\r\n\r\n    game.defineEntity('food')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: 10, layer: 0 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: 10, bodyType: BODY_STATIC })\r\n        .register();\r\n}\r\n\r\n// ============================================\r\n// Collision Handlers\r\n// ============================================\r\n\r\nfunction setupCollisions(): void {\r\n    // Head hits segment (die if not own)\r\n    physics.onCollision('snake-head', 'snake-segment', (head, segment) => {\r\n        if (head.destroyed || segment.destroyed) return;\r\n        const headClientId = head.get(Player).clientId;\r\n        const segOwnerId = segment.get(SnakeSegment).ownerId;\r\n        if (segOwnerId === headClientId) return;\r\n        killSnake(headClientId);\r\n    });\r\n\r\n    // Head eats food\r\n    physics.onCollision('snake-head', 'food', (head, food) => {\r\n        if (food.destroyed) return;\r\n        head.get(SnakeHead).length++;\r\n        food.destroy();\r\n    });\r\n}\r\n\r\n// ============================================\r\n// Systems\r\n// ============================================\r\n\r\nfunction setupSystems(): void {\r\n    // Movement system - MUST process players in deterministic order\r\n    game.addSystem(() => {\r\n        // Group heads by client ID, then sort by client ID string for deterministic order\r\n        const playerHeads = new Map<number, Entity>();\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            if (clientId === undefined || clientId === null) continue;\r\n            playerHeads.set(clientId, head);\r\n        }\r\n\r\n        // Sort by client ID string for deterministic processing order\r\n        const sortedPlayers = [...playerHeads.entries()].sort((a, b) =>\r\n            compareStrings(getClientIdStr(a[0]), getClientIdStr(b[0]))\r\n        );\r\n\r\n        for (const [clientId, head] of sortedPlayers) {\r\n            if (head.destroyed) continue;\r\n\r\n            const playerInput = game.world.getInput(clientId);\r\n            const sh = head.get(SnakeHead);\r\n            const t = head.get(Transform2D);\r\n\r\n            sh.prevDirX = sh.dirX;\r\n            sh.prevDirY = sh.dirY;\r\n\r\n            if (playerInput?.target) {\r\n                // Direction calculation - Math.sqrt auto-transforms to dSqrt\r\n                const dx = playerInput.target.x - t.x;\r\n                const dy = playerInput.target.y - t.y;\r\n                const distSq = dx * dx + dy * dy;\r\n\r\n                if (distSq > 1) {\r\n                    const dist = dSqrt(distSq);\r\n                    const desiredX = dx / dist;\r\n                    const desiredY = dy / dist;\r\n\r\n                    let newDirX = sh.dirX + (desiredX - sh.dirX) * TURN_SPEED;\r\n                    let newDirY = sh.dirY + (desiredY - sh.dirY) * TURN_SPEED;\r\n\r\n                    const newLenSq = newDirX * newDirX + newDirY * newDirY;\r\n                    const newLen = dSqrt(newLenSq);\r\n                    if (newLen > 0.001) {\r\n                        sh.dirX = newDirX / newLen;\r\n                        sh.dirY = newDirY / newLen;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Boost\r\n            const boostPressed = playerInput?.boost === true || (playerInput?.boost as any)?.pressed || playerInput?.boost > 0;\r\n            const isBoosting = boostPressed && sh.length > MIN_BOOST_LENGTH;\r\n            const currentSpeed = isBoosting ? BOOST_SPEED : SPEED;\r\n            sh.boosting = isBoosting ? 1 : 0;\r\n\r\n            if (isBoosting) {\r\n                sh.boostFrames++;\r\n                if (sh.boostFrames >= BOOST_COST_FRAMES) {\r\n                    sh.length--;\r\n                    sh.boostFrames = 0;\r\n                    game.spawn('food', {\r\n                        x: (t.x - sh.dirX * 30) | 0,\r\n                        y: (t.y - sh.dirY * 30) | 0,\r\n                        color: head.get(Sprite).color\r\n                    });\r\n                }\r\n            } else {\r\n                sh.boostFrames = 0;\r\n            }\r\n\r\n            // Use velocity-based movement (physics handles determinism)\r\n            const body = head.get(Body2D);\r\n            body.vx = sh.dirX * currentSpeed * 60;\r\n            body.vy = sh.dirY * currentSpeed * 60;\r\n\r\n            // Boundary check\r\n            const radius = head.get(Sprite).radius;\r\n            if (t.x - radius < 0 || t.x + radius > WORLD_WIDTH ||\r\n                t.y - radius < 0 || t.y + radius > WORLD_HEIGHT) {\r\n                killSnake(clientId);\r\n                continue; // Skip segment spawning for dead snake\r\n            }\r\n\r\n            // Segment spawning - trust engine's deterministic catch-up\r\n            const frameDiff = game.frame - sh.lastSpawnFrame;\r\n            if (frameDiff >= SEGMENT_SPAWN_INTERVAL) {\r\n                const color = head.get(Sprite).color;\r\n                const segment = game.spawn('snake-segment', {\r\n                    x: t.x, y: t.y,\r\n                    color: color,\r\n                    ownerId: clientId,\r\n                    spawnFrame: game.frame\r\n                });\r\n                // Debug: log segment spawning to help diagnose issues\r\n                if (game.frame % 100 === 0) {\r\n                    console.log(`[Spawn] frame=${game.frame} segId=${segment.id} owner=${clientId} isAuth=${game.isAuthority()}`);\r\n                }\r\n                sh.lastSpawnFrame = game.frame;\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Tail cleanup - process in deterministic order\r\n    game.addSystem(() => {\r\n        const headMaxAge = new Map<number, number>();\r\n\r\n        // Sort heads before building the map\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            const maxLength = head.get(SnakeHead).length;\r\n            headMaxAge.set(clientId, game.frame - (maxLength * SEGMENT_SPAWN_INTERVAL));\r\n        }\r\n\r\n        // Sort segments before destroying\r\n        const allSegments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n        for (const seg of allSegments) {\r\n            if (seg.destroyed) continue;\r\n            const segData = seg.get(SnakeSegment);\r\n            const oldestAllowed = headMaxAge.get(segData.ownerId);\r\n            if (oldestAllowed !== undefined && segData.spawnFrame < oldestAllowed) {\r\n                seg.destroy();\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Food spawning - trust engine's deterministic catch-up\r\n    game.addSystem(() => {\r\n        const shouldSpawn = dRandom() < FOOD_SPAWN_CHANCE;\r\n        if (game.getEntitiesByType('food').length < MAX_FOOD && shouldSpawn) {\r\n            spawnFood();\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Size update - process in deterministic order\r\n    game.addSystem(() => {\r\n        const ownerLengths = new Map<number, number>();\r\n\r\n        // Sort heads before processing\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            const length = head.get(SnakeHead).length;\r\n            const sizeMult = getSizeMultiplier(length);\r\n            ownerLengths.set(clientId, sizeMult);\r\n\r\n            const headRadius = BASE_HEAD_RADIUS * sizeMult;\r\n            head.get(Sprite).radius = headRadius;\r\n            head.get(Body2D).radius = headRadius;\r\n        }\r\n\r\n        // Sort segments before processing\r\n        const allSegments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n        for (const seg of allSegments) {\r\n            if (seg.destroyed) continue;\r\n            const ownerId = seg.get(SnakeSegment).ownerId;\r\n            const sizeMult = ownerLengths.get(ownerId) || 1;\r\n            const segRadius = BASE_SEGMENT_RADIUS * sizeMult;\r\n            seg.get(Sprite).radius = segRadius;\r\n            seg.get(Body2D).radius = segRadius;\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Camera update (client-side only, doesn't affect simulation)\r\n    game.addSystem(() => {\r\n        const localId = getLocalClientId();\r\n        if (localId === null) return;\r\n\r\n        const head = game.world.getEntityByClientId(localId);\r\n        if (!head || head.destroyed) return;\r\n\r\n        const t = head.get(Transform2D);\r\n        const length = head.get(SnakeHead).length;\r\n\r\n        camera.targetZoom = getTargetZoom(length);\r\n        camera.zoom += (camera.targetZoom - camera.zoom) * ZOOM_SPEED;\r\n        camera.x = t.x;\r\n        camera.y = t.y;\r\n    }, { phase: 'update' });\r\n}\r\n\r\n// ============================================\r\n// Rendering\r\n// ============================================\r\n\r\nfunction renderWithCamera(): void {\r\n    const ctx = renderer.context;\r\n    const alpha = game.getRenderAlpha();\r\n\r\n    ctx.fillStyle = '#111';\r\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n    let camX = camera.x, camY = camera.y;\r\n    const localId = getLocalClientId();\r\n    const localHead = localId ? game.world.getEntityByClientId(localId) : null;\r\n\r\n    if (localHead && !localHead.destroyed) {\r\n        localHead.interpolate(alpha);\r\n        const t = localHead.get(Transform2D);\r\n        camX = localHead.render?.interpX ?? t.x;\r\n        camY = localHead.render?.interpY ?? t.y;\r\n    }\r\n\r\n    ctx.save();\r\n    ctx.translate(WIDTH / 2, HEIGHT / 2);\r\n    ctx.scale(camera.zoom, camera.zoom);\r\n    ctx.translate(-camX, -camY);\r\n\r\n    // World bounds\r\n    ctx.strokeStyle = '#333';\r\n    ctx.lineWidth = 4 / camera.zoom;\r\n    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\r\n\r\n    // Grid\r\n    ctx.strokeStyle = '#1a1a1a';\r\n    ctx.lineWidth = 1 / camera.zoom;\r\n    const gridSize = 200;\r\n    for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, 0);\r\n        ctx.lineTo(x, WORLD_HEIGHT);\r\n        ctx.stroke();\r\n    }\r\n    for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, y);\r\n        ctx.lineTo(WORLD_WIDTH, y);\r\n        ctx.stroke();\r\n    }\r\n\r\n    // Food (render order doesn't matter for visuals)\r\n    for (const food of game.query('food')) {\r\n        if (food.destroyed) continue;\r\n        food.interpolate(alpha);\r\n        const x = food.render?.interpX ?? food.get(Transform2D).x;\r\n        const y = food.render?.interpY ?? food.get(Transform2D).y;\r\n        const sprite = food.get(Sprite);\r\n        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    // Segments\r\n    for (const seg of game.query('snake-segment')) {\r\n        if (seg.destroyed) continue;\r\n        seg.interpolate(alpha);\r\n        const x = seg.render?.interpX ?? seg.get(Transform2D).x;\r\n        const y = seg.render?.interpY ?? seg.get(Transform2D).y;\r\n        const sprite = seg.get(Sprite);\r\n        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    // Heads\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        head.interpolate(alpha);\r\n        const x = head.render?.interpX ?? head.get(Transform2D).x;\r\n        const y = head.render?.interpY ?? head.get(Transform2D).y;\r\n        const sprite = head.get(Sprite);\r\n        const sh = head.get(SnakeHead);\r\n        const sizeMult = getSizeMultiplier(sh.length);\r\n        const colorStr = game.getString('color', sprite.color) || '#fff';\r\n\r\n        // Glow when boosting\r\n        if (sh.boosting) {\r\n            ctx.save();\r\n            ctx.shadowColor = colorStr;\r\n            ctx.shadowBlur = 30;\r\n            ctx.fillStyle = colorStr;\r\n            ctx.globalAlpha = 0.4;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, sprite.radius * 2.5, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.globalAlpha = 0.6;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, sprite.radius * 1.8, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.fillStyle = colorStr;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Eyes\r\n        const dirX = sh.prevDirX + (sh.dirX - sh.prevDirX) * alpha;\r\n        const dirY = sh.prevDirY + (sh.dirY - sh.prevDirY) * alpha;\r\n        const eyeOffset = 6 * sizeMult;\r\n        const eyeRadius = 5 * sizeMult;\r\n        const pupilRadius = 2 * sizeMult;\r\n        const perpX = -dirY, perpY = dirX;\r\n\r\n        for (const side of [-1, 1]) {\r\n            const ex = x + dirX * eyeOffset + perpX * eyeOffset * side;\r\n            const ey = y + dirY * eyeOffset + perpY * eyeOffset * side;\r\n            ctx.fillStyle = '#fff';\r\n            ctx.beginPath();\r\n            ctx.arc(ex, ey, eyeRadius, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = '#000';\r\n            ctx.beginPath();\r\n            ctx.arc(ex + dirX * pupilRadius, ey + dirY * pupilRadius, pupilRadius, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n    drawMinimap(camX, camY);\r\n    updateStats();\r\n}\r\n\r\nfunction updateStats(): void {\r\n    const localId = getLocalClientId();\r\n    if (!localId) return;\r\n\r\n    const localHead = game.world.getEntityByClientId(localId);\r\n    if (!localHead || localHead.destroyed) {\r\n        statsLength.textContent = '0';\r\n        statsRank.textContent = '- of -';\r\n        return;\r\n    }\r\n\r\n    const myLength = localHead.get(SnakeHead).length;\r\n    statsLength.textContent = String(myLength);\r\n\r\n    const snakes: { clientId: number; length: number }[] = [];\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        snakes.push({\r\n            clientId: head.get(Player).clientId,\r\n            length: head.get(SnakeHead).length\r\n        });\r\n    }\r\n    snakes.sort((a, b) => b.length - a.length);\r\n\r\n    const rank = snakes.findIndex(s => s.clientId === localId) + 1;\r\n    statsRank.textContent = `${rank} of ${snakes.length}`;\r\n}\r\n\r\nfunction drawMinimap(camX: number, camY: number): void {\r\n    const mmW = minimapCanvas.width;\r\n    const mmH = minimapCanvas.height;\r\n    const scaleX = mmW / WORLD_WIDTH;\r\n    const scaleY = mmH / WORLD_HEIGHT;\r\n\r\n    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    minimapCtx.fillRect(0, 0, mmW, mmH);\r\n\r\n    minimapCtx.strokeStyle = '#444';\r\n    minimapCtx.lineWidth = 1;\r\n    minimapCtx.strokeRect(0, 0, mmW, mmH);\r\n\r\n    minimapCtx.fillStyle = '#555';\r\n    for (const food of game.query('food')) {\r\n        if (food.destroyed) continue;\r\n        const t = food.get(Transform2D);\r\n        const mx = t.x * scaleX;\r\n        const my = t.y * scaleY;\r\n        minimapCtx.fillRect(mx - 1, my - 1, 2, 2);\r\n    }\r\n\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        const t = head.get(Transform2D);\r\n        const sprite = head.get(Sprite);\r\n        const color = game.getString('color', sprite.color) || '#fff';\r\n        const clientId = head.get(Player).clientId;\r\n        const isLocal = clientId === getLocalClientId();\r\n\r\n        minimapCtx.fillStyle = color;\r\n        const mx = t.x * scaleX;\r\n        const my = t.y * scaleY;\r\n        minimapCtx.beginPath();\r\n        minimapCtx.arc(mx, my, isLocal ? 4 : 3, 0, Math.PI * 2);\r\n        minimapCtx.fill();\r\n\r\n        if (isLocal) {\r\n            minimapCtx.strokeStyle = '#fff';\r\n            minimapCtx.lineWidth = 1;\r\n            minimapCtx.beginPath();\r\n            minimapCtx.arc(mx, my, 6, 0, Math.PI * 2);\r\n            minimapCtx.stroke();\r\n        }\r\n    }\r\n\r\n    const viewW = (WIDTH / camera.zoom) * scaleX;\r\n    const viewH = (HEIGHT / camera.zoom) * scaleY;\r\n    const viewX = camX * scaleX - viewW / 2;\r\n    const viewY = camY * scaleY - viewH / 2;\r\n\r\n    minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\r\n    minimapCtx.lineWidth = 1;\r\n    minimapCtx.strokeRect(viewX, viewY, viewW, viewH);\r\n}\r\n\r\n// ============================================\r\n// Input Setup\r\n// ============================================\r\n\r\nfunction setupInput(): void {\r\n    mouseX = WIDTH / 2;\r\n    mouseY = HEIGHT / 2;\r\n\r\n    canvas.addEventListener('mousemove', (e) => {\r\n        const rect = canvas.getBoundingClientRect();\r\n        mouseX = e.clientX - rect.left;\r\n        mouseY = e.clientY - rect.top;\r\n    });\r\n\r\n    canvas.addEventListener('mousedown', (e) => { if (e.button === 0) mouseDown = true; });\r\n    canvas.addEventListener('mouseup', (e) => { if (e.button === 0) mouseDown = false; });\r\n    canvas.addEventListener('mouseleave', () => { mouseDown = false; });\r\n\r\n    input.action('target', {\r\n        type: 'vector',\r\n        bindings: [() => ({\r\n            x: Math.round(camera.x + (mouseX - WIDTH / 2) / camera.zoom),\r\n            y: Math.round(camera.y + (mouseY - HEIGHT / 2) / camera.zoom)\r\n        })]\r\n    });\r\n\r\n    input.action('boost', { type: 'button', bindings: [() => mouseDown] });\r\n}\r\n\r\n// ============================================\r\n// Main Entry Point\r\n// ============================================\r\n\r\nexport function initGame(): void {\r\n    canvas = document.getElementById('game') as HTMLCanvasElement;\r\n    minimapCanvas = document.getElementById('minimap') as HTMLCanvasElement;\r\n    minimapCtx = minimapCanvas.getContext('2d')!;\r\n    statsLength = document.querySelector('#stats .length') as HTMLElement;\r\n    statsRank = document.getElementById('rank-text') as HTMLElement;\r\n\r\n    // Set canvas to fullscreen\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n    WIDTH = canvas.width;\r\n    HEIGHT = canvas.height;\r\n\r\n    // Handle window resize\r\n    window.addEventListener('resize', () => {\r\n        canvas.width = window.innerWidth;\r\n        canvas.height = window.innerHeight;\r\n        WIDTH = canvas.width;\r\n        HEIGHT = canvas.height;\r\n    });\r\n\r\n    game = createGame();\r\n    renderer = game.addPlugin(Simple2DRenderer, canvas);\r\n    physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n    input = game.addPlugin(InputPlugin, canvas);\r\n\r\n    (window as any).game = game;\r\n\r\n    defineEntities();\r\n    setupCollisions();\r\n    setupSystems();\r\n    setupInput();\r\n\r\n    renderer.render = renderWithCamera;\r\n\r\n    game.connect('snake-v36', {\r\n        onRoomCreate() {\r\n            for (let i = 0; i < FOOD_COUNT; i++) spawnFood();\r\n        },\r\n        onConnect(clientId: string) {\r\n            spawnSnake(clientId);\r\n        },\r\n        onDisconnect(clientId: string) {\r\n            killSnake(game.internClientId(clientId));\r\n        },\r\n        onSnapshot(entities: Entity[]) {\r\n            // Log snapshot receipt for debugging\r\n            console.log(`[onSnapshot] Received snapshot at frame ${game.frame}, ${entities.length} entities`);\r\n            // Engine handles catch-up deterministically - no special game-side handling needed\r\n        }\r\n    });\r\n\r\n    enableDebugUI(game);\r\n}\r\n\r\n// Auto-init when DOM is ready\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initGame);\r\n} else {\r\n    initGame();\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
