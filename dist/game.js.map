{
  "version": 3,
  "sources": ["../src/game.ts", "../../../engine/src/math/fixed.ts", "../../../engine/src/math/random.ts", "../../../engine/src/core/constants.ts", "../../../engine/src/core/component.ts", "../../../engine/src/core/entity-id.ts", "../../../engine/src/components/index.ts", "../../../engine/src/core/entity.ts", "../../../engine/src/core/query.ts", "../../../engine/src/core/system.ts", "../../../engine/src/core/snapshot.ts", "../../../engine/src/core/string-registry.ts", "../../../engine/src/core/input-history.ts", "../../../engine/src/core/world.ts", "../../../engine/src/codec/binary.ts", "../../../engine/src/game.ts", "../../../engine/src/plugins/simple-2d-renderer.ts", "../../../engine/src/plugins/input-plugin.ts", "../../../engine/src/plugins/determinism-guard.ts", "../../../engine/src/plugins/debug-ui.ts", "../../../engine/src/plugins/physics2d/shapes.ts", "../../../engine/src/plugins/physics2d/layers.ts", "../../../engine/src/plugins/physics2d/rigid-body.ts", "../../../engine/src/plugins/physics2d/collision.ts", "../../../engine/src/plugins/physics2d/spatial-hash.ts", "../../../engine/src/plugins/physics2d/world.ts", "../../../engine/src/plugins/physics2d/system.ts", "../../../engine/src/plugins/physics3d/layers.ts", "../../../engine/src/plugins/physics3d/rigid-body.ts", "../../../engine/src/plugins/physics3d/collision.ts", "../../../engine/src/plugins/physics3d/world.ts"],
  "sourcesContent": ["/**\r\n * Snake Game - Slither.io style multiplayer\r\n *\r\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\r\n */\r\n\r\nimport { createGame,\r\n    Game,\r\n    Entity,\r\n    Transform2D,\r\n    Body2D,\r\n    Player,\r\n    Sprite,\r\n    BODY_KINEMATIC,\r\n    BODY_STATIC,\r\n    SHAPE_CIRCLE,\r\n    Simple2DRenderer,\r\n    Physics2DSystem,\r\n    InputPlugin,\r\n    enableDebugUI,\r\n    defineComponent, dSqrt, dRandom } from 'modu-engine';\r\n\r\n// ============================================\r\n// Constants\r\n// ============================================\r\n\r\nconst WORLD_WIDTH = 4000;\r\nconst WORLD_HEIGHT = 4000;\r\n\r\nconst SPEED = 8;\r\nconst BOOST_SPEED = 18;\r\nconst BOOST_COST_FRAMES = 10;\r\nconst MIN_BOOST_LENGTH = 10;\r\nconst BASE_HEAD_RADIUS = 16;\r\nconst BASE_SEGMENT_RADIUS = 14;\r\nconst INITIAL_LENGTH = 15;\r\nconst FOOD_COUNT = 100;\r\nconst MAX_FOOD = 200;\r\nconst FOOD_SPAWN_CHANCE = 0.03;\r\nconst SEGMENT_SPAWN_INTERVAL = 1;\r\nconst TURN_SPEED = 0.15;\r\n\r\n// Camera settings\r\nconst MIN_ZOOM = 0.3;\r\nconst MAX_ZOOM = 1.0;\r\nconst ZOOM_SPEED = 0.02;\r\n\r\n// Size scaling\r\nconst SIZE_GROWTH_RATE = 0.02;\r\nconst MAX_SIZE_MULTIPLIER = 3;\r\n\r\nconst COLORS = [\r\n    '#ff6b6b', '#4dabf7', '#69db7c', '#ffd43b', '#da77f2', '#ff8e72',\r\n    '#38d9a9', '#748ffc', '#f783ac', '#a9e34b', '#3bc9db', '#9775fa'\r\n];\r\n\r\n// ============================================\r\n// Types\r\n// ============================================\r\n\r\ninterface Camera {\r\n    x: number;\r\n    y: number;\r\n    zoom: number;\r\n    targetZoom: number;\r\n}\r\n\r\n// ============================================\r\n// Game State\r\n// ============================================\r\n\r\nlet game: Game;\r\nlet renderer: Simple2DRenderer;\r\nlet physics: Physics2DSystem;\r\nlet input: InputPlugin;\r\n\r\nlet canvas: HTMLCanvasElement;\r\nlet minimapCanvas: HTMLCanvasElement;\r\nlet minimapCtx: CanvasRenderingContext2D;\r\nlet statsLength: HTMLElement;\r\nlet statsRank: HTMLElement;\r\nlet WIDTH: number;\r\nlet HEIGHT: number;\r\n\r\nconst camera: Camera = {\r\n    x: WORLD_WIDTH / 2,\r\n    y: WORLD_HEIGHT / 2,\r\n    zoom: 1.0,\r\n    targetZoom: 1.0\r\n};\r\n\r\nlet mouseX: number;\r\nlet mouseY: number;\r\nlet mouseDown = false;\r\n\r\n// ============================================\r\n// Components (all fields default to i32/fixed-point for determinism)\r\n// ============================================\r\n\r\nconst SnakeHead = defineComponent('SnakeHead', {\r\n    length: INITIAL_LENGTH,\r\n    dirX: 1,\r\n    dirY: 0,\r\n    prevDirX: 1,\r\n    prevDirY: 0,\r\n    lastSpawnFrame: 0,\r\n    boostFrames: 0,\r\n    boosting: 0\r\n});\r\n\r\nconst SnakeSegment = defineComponent('SnakeSegment', {\r\n    ownerId: 0,\r\n    spawnFrame: 0\r\n});\r\n\r\n// ============================================\r\n// Helper Functions\r\n// ============================================\r\n\r\nfunction getLocalClientId(): number | null {\r\n    const clientId = game.localClientId;\r\n    if (!clientId || typeof clientId !== 'string') return null;\r\n    return game.internClientId(clientId);\r\n}\r\n\r\nfunction getClientIdStr(numericId: number): string {\r\n    return game.getClientIdString(numericId) || '';\r\n}\r\n\r\nfunction compareStrings(a: string, b: string): number {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n}\r\n\r\nfunction getSizeMultiplier(length: number): number {\r\n    const growth = 1 + (length - INITIAL_LENGTH) * SIZE_GROWTH_RATE;\r\n    return Math.min(growth, MAX_SIZE_MULTIPLIER);\r\n}\r\n\r\nfunction getTargetZoom(length: number): number {\r\n    const sizeMultiplier = getSizeMultiplier(length);\r\n    return Math.max(MIN_ZOOM, MAX_ZOOM / sizeMultiplier);\r\n}\r\n\r\nfunction killSnake(clientId: number): void {\r\n    const head = game.world.getEntityByClientId(clientId);\r\n    if (!head || head.destroyed) return;\r\n\r\n    // Sort segments before destroying for deterministic order\r\n    const segments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n    for (const seg of segments) {\r\n        if (seg.get(SnakeSegment).ownerId === clientId) {\r\n            seg.destroy();\r\n        }\r\n    }\r\n    head.destroy();\r\n}\r\n\r\nfunction spawnSnake(clientId: string): void {\r\n    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);\r\n    const startX = 200 + (dRandom() * (WORLD_WIDTH - 400)) | 0;\r\n    const startY = 200 + (dRandom() * (WORLD_HEIGHT - 400)) | 0;\r\n\r\n    game.spawn('snake-head', {\r\n        x: startX, y: startY, clientId, color,\r\n        length: INITIAL_LENGTH,\r\n        lastSpawnFrame: game.frame\r\n    });\r\n}\r\n\r\nfunction spawnFood(): void {\r\n    const color = game.internString('color', COLORS[(dRandom() * COLORS.length) | 0]);\r\n    game.spawn('food', {\r\n        x: 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0,\r\n        y: 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0,\r\n        color\r\n    });\r\n}\r\n\r\n// ============================================\r\n// Entity Definitions\r\n// ============================================\r\n\r\nfunction defineEntities(): void {\r\n    game.defineEntity('snake-head')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, layer: 2 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_HEAD_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })\r\n        .with(Player)\r\n        .with(SnakeHead)\r\n        .register();\r\n\r\n    game.defineEntity('snake-segment')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, layer: 1 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: BASE_SEGMENT_RADIUS, bodyType: BODY_KINEMATIC, isSensor: true })\r\n        .with(SnakeSegment)\r\n        .register();\r\n\r\n    game.defineEntity('food')\r\n        .with(Transform2D)\r\n        .with(Sprite, { shape: SHAPE_CIRCLE, radius: 10, layer: 0 })\r\n        .with(Body2D, { shapeType: SHAPE_CIRCLE, radius: 10, bodyType: BODY_STATIC })\r\n        .register();\r\n}\r\n\r\n// ============================================\r\n// Collision Handlers\r\n// ============================================\r\n\r\nfunction setupCollisions(): void {\r\n    // Head hits segment (die if not own)\r\n    physics.onCollision('snake-head', 'snake-segment', (head, segment) => {\r\n        if (head.destroyed || segment.destroyed) return;\r\n        const headClientId = head.get(Player).clientId;\r\n        const segOwnerId = segment.get(SnakeSegment).ownerId;\r\n        if (segOwnerId === headClientId) return;\r\n        killSnake(headClientId);\r\n    });\r\n\r\n    // Head eats food\r\n    physics.onCollision('snake-head', 'food', (head, food) => {\r\n        if (food.destroyed) return;\r\n        head.get(SnakeHead).length++;\r\n        food.destroy();\r\n    });\r\n}\r\n\r\n// ============================================\r\n// Systems\r\n// ============================================\r\n\r\nfunction setupSystems(): void {\r\n    // Movement system - MUST process players in deterministic order\r\n    game.addSystem(() => {\r\n        // Group heads by client ID, then sort by client ID string for deterministic order\r\n        const playerHeads = new Map<number, Entity>();\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            if (clientId === undefined || clientId === null) continue;\r\n            playerHeads.set(clientId, head);\r\n        }\r\n\r\n        // Sort by client ID string for deterministic processing order\r\n        const sortedPlayers = [...playerHeads.entries()].sort((a, b) =>\r\n            compareStrings(getClientIdStr(a[0]), getClientIdStr(b[0]))\r\n        );\r\n\r\n        for (const [clientId, head] of sortedPlayers) {\r\n            if (head.destroyed) continue;\r\n\r\n            const playerInput = game.world.getInput(clientId);\r\n            const sh = head.get(SnakeHead);\r\n            const t = head.get(Transform2D);\r\n\r\n            sh.prevDirX = sh.dirX;\r\n            sh.prevDirY = sh.dirY;\r\n\r\n            if (playerInput?.target) {\r\n                // Direction calculation - Math.sqrt auto-transforms to dSqrt\r\n                const dx = playerInput.target.x - t.x;\r\n                const dy = playerInput.target.y - t.y;\r\n                const distSq = dx * dx + dy * dy;\r\n\r\n                if (distSq > 1) {\r\n                    const dist = dSqrt(distSq);\r\n                    const desiredX = dx / dist;\r\n                    const desiredY = dy / dist;\r\n\r\n                    let newDirX = sh.dirX + (desiredX - sh.dirX) * TURN_SPEED;\r\n                    let newDirY = sh.dirY + (desiredY - sh.dirY) * TURN_SPEED;\r\n\r\n                    const newLenSq = newDirX * newDirX + newDirY * newDirY;\r\n                    const newLen = dSqrt(newLenSq);\r\n                    if (newLen > 0.001) {\r\n                        sh.dirX = newDirX / newLen;\r\n                        sh.dirY = newDirY / newLen;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Boost\r\n            const boostPressed = playerInput?.boost === true || (playerInput?.boost as any)?.pressed || playerInput?.boost > 0;\r\n            const isBoosting = boostPressed && sh.length > MIN_BOOST_LENGTH;\r\n            const currentSpeed = isBoosting ? BOOST_SPEED : SPEED;\r\n            sh.boosting = isBoosting ? 1 : 0;\r\n\r\n            if (isBoosting) {\r\n                sh.boostFrames++;\r\n                if (sh.boostFrames >= BOOST_COST_FRAMES) {\r\n                    sh.length--;\r\n                    sh.boostFrames = 0;\r\n                    game.spawn('food', {\r\n                        x: (t.x - sh.dirX * 30) | 0,\r\n                        y: (t.y - sh.dirY * 30) | 0,\r\n                        color: head.get(Sprite).color\r\n                    });\r\n                }\r\n            } else {\r\n                sh.boostFrames = 0;\r\n            }\r\n\r\n            // Use velocity-based movement (physics handles determinism)\r\n            const body = head.get(Body2D);\r\n            body.vx = sh.dirX * currentSpeed * 60;\r\n            body.vy = sh.dirY * currentSpeed * 60;\r\n\r\n            // Boundary check\r\n            const radius = head.get(Sprite).radius;\r\n            if (t.x - radius < 0 || t.x + radius > WORLD_WIDTH ||\r\n                t.y - radius < 0 || t.y + radius > WORLD_HEIGHT) {\r\n                killSnake(clientId);\r\n                continue; // Skip segment spawning for dead snake\r\n            }\r\n\r\n            // Segment spawning\r\n            const frameDiff = game.frame - sh.lastSpawnFrame;\r\n            if (frameDiff >= SEGMENT_SPAWN_INTERVAL) {\r\n                const color = head.get(Sprite).color;\r\n                game.spawn('snake-segment', {\r\n                    x: t.x, y: t.y,\r\n                    color: color,\r\n                    ownerId: clientId,\r\n                    spawnFrame: game.frame\r\n                });\r\n                sh.lastSpawnFrame = game.frame;\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Tail cleanup - process in deterministic order\r\n    game.addSystem(() => {\r\n        const headMaxAge = new Map<number, number>();\r\n\r\n        // Sort heads before building the map\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            const maxLength = head.get(SnakeHead).length;\r\n            headMaxAge.set(clientId, game.frame - (maxLength * SEGMENT_SPAWN_INTERVAL));\r\n        }\r\n\r\n        // Sort segments before destroying\r\n        const allSegments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n        for (const seg of allSegments) {\r\n            if (seg.destroyed) continue;\r\n            const segData = seg.get(SnakeSegment);\r\n            const oldestAllowed = headMaxAge.get(segData.ownerId);\r\n            if (oldestAllowed !== undefined && segData.spawnFrame < oldestAllowed) {\r\n                seg.destroy();\r\n            }\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Food spawning\r\n    game.addSystem(() => {\r\n        if (game.getEntitiesByType('food').length < MAX_FOOD && dRandom() < FOOD_SPAWN_CHANCE) {\r\n            spawnFood();\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Size update - process in deterministic order\r\n    game.addSystem(() => {\r\n        const ownerLengths = new Map<number, number>();\r\n\r\n        // Sort heads before processing\r\n        const allHeads = [...game.query('snake-head')].sort((a, b) => a.id - b.id);\r\n        for (const head of allHeads) {\r\n            if (head.destroyed) continue;\r\n            const clientId = head.get(Player).clientId;\r\n            const length = head.get(SnakeHead).length;\r\n            const sizeMult = getSizeMultiplier(length);\r\n            ownerLengths.set(clientId, sizeMult);\r\n\r\n            const headRadius = BASE_HEAD_RADIUS * sizeMult;\r\n            head.get(Sprite).radius = headRadius;\r\n            head.get(Body2D).radius = headRadius;\r\n        }\r\n\r\n        // Sort segments before processing\r\n        const allSegments = [...game.query('snake-segment')].sort((a, b) => a.id - b.id);\r\n        for (const seg of allSegments) {\r\n            if (seg.destroyed) continue;\r\n            const ownerId = seg.get(SnakeSegment).ownerId;\r\n            const sizeMult = ownerLengths.get(ownerId) || 1;\r\n            const segRadius = BASE_SEGMENT_RADIUS * sizeMult;\r\n            seg.get(Sprite).radius = segRadius;\r\n            seg.get(Body2D).radius = segRadius;\r\n        }\r\n    }, { phase: 'update' });\r\n\r\n    // Camera update (client-side only, doesn't affect simulation)\r\n    game.addSystem(() => {\r\n        const localId = getLocalClientId();\r\n        if (localId === null) return;\r\n\r\n        const head = game.world.getEntityByClientId(localId);\r\n        if (!head || head.destroyed) return;\r\n\r\n        const t = head.get(Transform2D);\r\n        const length = head.get(SnakeHead).length;\r\n\r\n        camera.targetZoom = getTargetZoom(length);\r\n        camera.zoom += (camera.targetZoom - camera.zoom) * ZOOM_SPEED;\r\n        camera.x = t.x;\r\n        camera.y = t.y;\r\n    }, { phase: 'update' });\r\n}\r\n\r\n// ============================================\r\n// Rendering\r\n// ============================================\r\n\r\nfunction renderWithCamera(): void {\r\n    const ctx = renderer.context;\r\n    const alpha = game.getRenderAlpha();\r\n\r\n    ctx.fillStyle = '#111';\r\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n    let camX = camera.x, camY = camera.y;\r\n    const localId = getLocalClientId();\r\n    const localHead = localId ? game.world.getEntityByClientId(localId) : null;\r\n\r\n    if (localHead && !localHead.destroyed) {\r\n        localHead.interpolate(alpha);\r\n        const t = localHead.get(Transform2D);\r\n        camX = localHead.render?.interpX ?? t.x;\r\n        camY = localHead.render?.interpY ?? t.y;\r\n    }\r\n\r\n    ctx.save();\r\n    ctx.translate(WIDTH / 2, HEIGHT / 2);\r\n    ctx.scale(camera.zoom, camera.zoom);\r\n    ctx.translate(-camX, -camY);\r\n\r\n    // World bounds\r\n    ctx.strokeStyle = '#333';\r\n    ctx.lineWidth = 4 / camera.zoom;\r\n    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\r\n\r\n    // Grid\r\n    ctx.strokeStyle = '#1a1a1a';\r\n    ctx.lineWidth = 1 / camera.zoom;\r\n    const gridSize = 200;\r\n    for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, 0);\r\n        ctx.lineTo(x, WORLD_HEIGHT);\r\n        ctx.stroke();\r\n    }\r\n    for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, y);\r\n        ctx.lineTo(WORLD_WIDTH, y);\r\n        ctx.stroke();\r\n    }\r\n\r\n    // Food (render order doesn't matter for visuals)\r\n    for (const food of game.query('food')) {\r\n        if (food.destroyed) continue;\r\n        food.interpolate(alpha);\r\n        const x = food.render?.interpX ?? food.get(Transform2D).x;\r\n        const y = food.render?.interpY ?? food.get(Transform2D).y;\r\n        const sprite = food.get(Sprite);\r\n        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    // Segments\r\n    for (const seg of game.query('snake-segment')) {\r\n        if (seg.destroyed) continue;\r\n        seg.interpolate(alpha);\r\n        const x = seg.render?.interpX ?? seg.get(Transform2D).x;\r\n        const y = seg.render?.interpY ?? seg.get(Transform2D).y;\r\n        const sprite = seg.get(Sprite);\r\n        ctx.fillStyle = game.getString('color', sprite.color) || '#fff';\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    // Heads\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        head.interpolate(alpha);\r\n        const x = head.render?.interpX ?? head.get(Transform2D).x;\r\n        const y = head.render?.interpY ?? head.get(Transform2D).y;\r\n        const sprite = head.get(Sprite);\r\n        const sh = head.get(SnakeHead);\r\n        const sizeMult = getSizeMultiplier(sh.length);\r\n        const colorStr = game.getString('color', sprite.color) || '#fff';\r\n\r\n        // Glow when boosting\r\n        if (sh.boosting) {\r\n            ctx.save();\r\n            ctx.shadowColor = colorStr;\r\n            ctx.shadowBlur = 30;\r\n            ctx.fillStyle = colorStr;\r\n            ctx.globalAlpha = 0.4;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, sprite.radius * 2.5, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.globalAlpha = 0.6;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, sprite.radius * 1.8, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.fillStyle = colorStr;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, sprite.radius, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Eyes\r\n        const dirX = sh.prevDirX + (sh.dirX - sh.prevDirX) * alpha;\r\n        const dirY = sh.prevDirY + (sh.dirY - sh.prevDirY) * alpha;\r\n        const eyeOffset = 6 * sizeMult;\r\n        const eyeRadius = 5 * sizeMult;\r\n        const pupilRadius = 2 * sizeMult;\r\n        const perpX = -dirY, perpY = dirX;\r\n\r\n        for (const side of [-1, 1]) {\r\n            const ex = x + dirX * eyeOffset + perpX * eyeOffset * side;\r\n            const ey = y + dirY * eyeOffset + perpY * eyeOffset * side;\r\n            ctx.fillStyle = '#fff';\r\n            ctx.beginPath();\r\n            ctx.arc(ex, ey, eyeRadius, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.fillStyle = '#000';\r\n            ctx.beginPath();\r\n            ctx.arc(ex + dirX * pupilRadius, ey + dirY * pupilRadius, pupilRadius, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n    drawMinimap(camX, camY);\r\n    updateStats();\r\n}\r\n\r\nfunction updateStats(): void {\r\n    const localId = getLocalClientId();\r\n    if (!localId) return;\r\n\r\n    const localHead = game.world.getEntityByClientId(localId);\r\n    if (!localHead || localHead.destroyed) {\r\n        statsLength.textContent = '0';\r\n        statsRank.textContent = '- of -';\r\n        return;\r\n    }\r\n\r\n    const myLength = localHead.get(SnakeHead).length;\r\n    statsLength.textContent = String(myLength);\r\n\r\n    const snakes: { clientId: number; length: number }[] = [];\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        snakes.push({\r\n            clientId: head.get(Player).clientId,\r\n            length: head.get(SnakeHead).length\r\n        });\r\n    }\r\n    snakes.sort((a, b) => b.length - a.length);\r\n\r\n    const rank = snakes.findIndex(s => s.clientId === localId) + 1;\r\n    statsRank.textContent = `${rank} of ${snakes.length}`;\r\n}\r\n\r\nfunction drawMinimap(camX: number, camY: number): void {\r\n    const mmW = minimapCanvas.width;\r\n    const mmH = minimapCanvas.height;\r\n    const scaleX = mmW / WORLD_WIDTH;\r\n    const scaleY = mmH / WORLD_HEIGHT;\r\n\r\n    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    minimapCtx.fillRect(0, 0, mmW, mmH);\r\n\r\n    minimapCtx.strokeStyle = '#444';\r\n    minimapCtx.lineWidth = 1;\r\n    minimapCtx.strokeRect(0, 0, mmW, mmH);\r\n\r\n    minimapCtx.fillStyle = '#555';\r\n    for (const food of game.query('food')) {\r\n        if (food.destroyed) continue;\r\n        const t = food.get(Transform2D);\r\n        const mx = t.x * scaleX;\r\n        const my = t.y * scaleY;\r\n        minimapCtx.fillRect(mx - 1, my - 1, 2, 2);\r\n    }\r\n\r\n    for (const head of game.query('snake-head')) {\r\n        if (head.destroyed) continue;\r\n        const t = head.get(Transform2D);\r\n        const sprite = head.get(Sprite);\r\n        const color = game.getString('color', sprite.color) || '#fff';\r\n        const clientId = head.get(Player).clientId;\r\n        const isLocal = clientId === getLocalClientId();\r\n\r\n        minimapCtx.fillStyle = color;\r\n        const mx = t.x * scaleX;\r\n        const my = t.y * scaleY;\r\n        minimapCtx.beginPath();\r\n        minimapCtx.arc(mx, my, isLocal ? 4 : 3, 0, Math.PI * 2);\r\n        minimapCtx.fill();\r\n\r\n        if (isLocal) {\r\n            minimapCtx.strokeStyle = '#fff';\r\n            minimapCtx.lineWidth = 1;\r\n            minimapCtx.beginPath();\r\n            minimapCtx.arc(mx, my, 6, 0, Math.PI * 2);\r\n            minimapCtx.stroke();\r\n        }\r\n    }\r\n\r\n    const viewW = (WIDTH / camera.zoom) * scaleX;\r\n    const viewH = (HEIGHT / camera.zoom) * scaleY;\r\n    const viewX = camX * scaleX - viewW / 2;\r\n    const viewY = camY * scaleY - viewH / 2;\r\n\r\n    minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\r\n    minimapCtx.lineWidth = 1;\r\n    minimapCtx.strokeRect(viewX, viewY, viewW, viewH);\r\n}\r\n\r\n// ============================================\r\n// Input Setup\r\n// ============================================\r\n\r\nfunction setupInput(): void {\r\n    mouseX = WIDTH / 2;\r\n    mouseY = HEIGHT / 2;\r\n\r\n    canvas.addEventListener('mousemove', (e) => {\r\n        const rect = canvas.getBoundingClientRect();\r\n        mouseX = e.clientX - rect.left;\r\n        mouseY = e.clientY - rect.top;\r\n    });\r\n\r\n    canvas.addEventListener('mousedown', (e) => { if (e.button === 0) mouseDown = true; });\r\n    canvas.addEventListener('mouseup', (e) => { if (e.button === 0) mouseDown = false; });\r\n    canvas.addEventListener('mouseleave', () => { mouseDown = false; });\r\n\r\n    input.action('target', {\r\n        type: 'vector',\r\n        bindings: [() => ({\r\n            x: Math.round(camera.x + (mouseX - WIDTH / 2) / camera.zoom),\r\n            y: Math.round(camera.y + (mouseY - HEIGHT / 2) / camera.zoom)\r\n        })]\r\n    });\r\n\r\n    input.action('boost', { type: 'button', bindings: [() => mouseDown] });\r\n}\r\n\r\n// ============================================\r\n// Main Entry Point\r\n// ============================================\r\n\r\nexport function initGame(): void {\r\n    canvas = document.getElementById('game') as HTMLCanvasElement;\r\n    minimapCanvas = document.getElementById('minimap') as HTMLCanvasElement;\r\n    minimapCtx = minimapCanvas.getContext('2d')!;\r\n    statsLength = document.querySelector('#stats .length') as HTMLElement;\r\n    statsRank = document.getElementById('rank-text') as HTMLElement;\r\n    WIDTH = canvas.width;\r\n    HEIGHT = canvas.height;\r\n\r\n    game = createGame();\r\n    renderer = game.addPlugin(Simple2DRenderer, canvas);\r\n    physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n    input = game.addPlugin(InputPlugin, canvas);\r\n\r\n    (window as any).game = game;\r\n\r\n    defineEntities();\r\n    setupCollisions();\r\n    setupSystems();\r\n    setupInput();\r\n\r\n    renderer.render = renderWithCamera;\r\n\r\n    game.connect('snake-v33', {\r\n        onRoomCreate() {\r\n            for (let i = 0; i < FOOD_COUNT; i++) spawnFood();\r\n        },\r\n        onConnect(clientId: string) {\r\n            spawnSnake(clientId);\r\n        },\r\n        onDisconnect(clientId: string) {\r\n            killSnake(game.internClientId(clientId));\r\n        }\r\n    });\r\n\r\n    enableDebugUI(game);\r\n}\r\n\r\n// Auto-init when DOM is ready\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initGame);\r\n} else {\r\n    initGame();\r\n}\r\n", "/**\r\n * Fixed-Point Math Library for Deterministic Physics\r\n *\r\n * Uses 32-bit integers with 16.16 fixed-point format:\r\n * - 16 bits for integer part (-32768 to 32767)\r\n * - 16 bits for fractional part (precision ~0.000015)\r\n *\r\n * All operations are 100% deterministic across platforms.\r\n */\r\n\r\n// Fixed-point constants\r\nexport const FP_SHIFT = 16;\r\nexport const FP_ONE = 1 << FP_SHIFT;  // 65536\r\nexport const FP_HALF = FP_ONE >> 1;    // 32768\r\nexport const FP_PI = 205887;           // PI * 65536\r\nexport const FP_2PI = 411775;          // 2*PI * 65536\r\nexport const FP_HALF_PI = 102944;      // PI/2 * 65536\r\n\r\n// Type alias for fixed-point numbers (just integers)\r\nexport type Fixed = number;\r\n\r\n// ============================================\r\n// Basic Fixed-Point Operations\r\n// ============================================\r\n\r\n/** Convert float to fixed-point */\r\nexport function toFixed(f: number): Fixed {\r\n    return Math.round(f * FP_ONE) | 0;\r\n}\r\n\r\n/** Convert fixed-point to float (for rendering only) */\r\nexport function toFloat(fp: Fixed): number {\r\n    return fp / FP_ONE;\r\n}\r\n\r\n/** Fixed-point multiplication */\r\nexport function fpMul(a: Fixed, b: Fixed): Fixed {\r\n    // Use BigInt for intermediate to avoid overflow\r\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\r\n    // (e.g., distance calculations on a 1400x900 canvas can overflow)\r\n    // JavaScript numbers can safely represent integers up to 2^53\r\n    return Number((BigInt(a) * BigInt(b)) >> BigInt(FP_SHIFT));\r\n}\r\n\r\n/** Fixed-point division */\r\nexport function fpDiv(a: Fixed, b: Fixed): Fixed {\r\n    if (b === 0) return a >= 0 ? 0x7FFFFFFF : -0x7FFFFFFF;\r\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\r\n    return Number((BigInt(a) << BigInt(FP_SHIFT)) / BigInt(b));\r\n}\r\n\r\n/** Fixed-point absolute value */\r\nexport function fpAbs(a: Fixed): Fixed {\r\n    return a < 0 ? -a : a;\r\n}\r\n\r\n/** Fixed-point sign */\r\nexport function fpSign(a: Fixed): Fixed {\r\n    return a > 0 ? FP_ONE : a < 0 ? -FP_ONE : 0;\r\n}\r\n\r\n/** Fixed-point min */\r\nexport function fpMin(a: Fixed, b: Fixed): Fixed {\r\n    return a < b ? a : b;\r\n}\r\n\r\n/** Fixed-point max */\r\nexport function fpMax(a: Fixed, b: Fixed): Fixed {\r\n    return a > b ? a : b;\r\n}\r\n\r\n/** Fixed-point clamp */\r\nexport function fpClamp(v: Fixed, min: Fixed, max: Fixed): Fixed {\r\n    return v < min ? min : v > max ? max : v;\r\n}\r\n\r\n/** Fixed-point floor */\r\nexport function fpFloor(a: Fixed): Fixed {\r\n    return a & ~(FP_ONE - 1);\r\n}\r\n\r\n/** Fixed-point ceil */\r\nexport function fpCeil(a: Fixed): Fixed {\r\n    return (a + FP_ONE - 1) & ~(FP_ONE - 1);\r\n}\r\n\r\n// ============================================\r\n// Square Root (using Newton-Raphson)\r\n// ============================================\r\n\r\n/** Fixed-point square root using Newton-Raphson iteration */\r\nexport function fpSqrt(a: Fixed): Fixed {\r\n    if (a <= 0) return 0;\r\n\r\n    // For 16.16 fixed-point: if a = v * 65536, we want sqrt(v) * 65536\r\n    // sqrt(a) would give sqrt(v) * 256, which is 256x too small!\r\n    // Solution: compute sqrt(a * 65536) = sqrt(a) * 256 = sqrt(v) * 65536\r\n    const scaled = BigInt(a) * BigInt(FP_ONE);\r\n    if (scaled <= 0n) return 0;\r\n\r\n    // Better initial guess using bit length\r\n    let bitLen = 0n;\r\n    let temp = scaled;\r\n    while (temp > 0n) {\r\n        bitLen++;\r\n        temp >>= 1n;\r\n    }\r\n\r\n    let x = 1n << (bitLen >> 1n);\r\n    if (x === 0n) x = 1n;\r\n\r\n    // Newton-Raphson with proper convergence check\r\n    let prevX = 0n;\r\n    for (let i = 0; i < 30; i++) {\r\n        const xNew = (x + scaled / x) >> 1n;\r\n        // Check for true convergence (oscillating between x and x+1)\r\n        if (xNew === x || xNew === prevX) break;\r\n        prevX = x;\r\n        x = xNew;\r\n    }\r\n\r\n    // Final adjustment: ensure x*x <= scaled < (x+1)*(x+1)\r\n    while (x * x > scaled) x--;\r\n    while ((x + 1n) * (x + 1n) <= scaled) x++;\r\n\r\n    return Number(x);\r\n}\r\n\r\n\n/**\n * Deterministic square root (float API).\n * Takes a float, returns a float, but uses BigInt internally for determinism.\n * Handles large values without 32-bit overflow.\n *\n * @example\n * const dist = dSqrt(dx * dx + dy * dy);  // Deterministic!\n */\nexport function dSqrt(x: number): number {\n    if (x <= 0) return 0;\n\n    // Use BigInt to avoid 32-bit overflow for large values\n    // Scale by FP_ONE^2 so sqrt gives us the right scale back\n    const scaled = BigInt(Math.round(x * FP_ONE)) * BigInt(FP_ONE);\n\n    // Newton-Raphson sqrt using BigInt\n    let bitLen = 0n;\n    let temp = scaled;\n    while (temp > 0n) {\n        bitLen++;\n        temp >>= 1n;\n    }\n\n    let r = 1n << (bitLen >> 1n);\n    let prevR = 0n;\n    for (let i = 0; i < 30; i++) {\n        const rNew = (r + scaled / r) >> 1n;\n        if (rNew === r || rNew === prevR) break;\n        prevR = r;\n        r = rNew;\n    }\n\n    while (r * r > scaled) r--;\n    while ((r + 1n) * (r + 1n) <= scaled) r++;\n\n    return Number(r) / FP_ONE;\n}\n\r\n// ============================================\r\n// Trigonometry (Lookup Tables)\r\n// ============================================\r\n\r\n// Sine lookup table (257 entries for 0 to PI/2, inclusive)\r\n// PRE-COMPUTED for cross-platform determinism - DO NOT use Math.sin() at runtime!\r\n// Math.sin() produces different results across browsers/CPUs, breaking determinism.\r\nconst SIN_TABLE_SIZE = 256;\r\nconst SIN_TABLE: Fixed[] = [\r\n    0, 402, 804, 1206, 1608, 2010, 2412, 2814, 3216, 3617, 4019, 4420, 4821, 5222, 5623, 6023,\r\n    6424, 6824, 7224, 7623, 8022, 8421, 8820, 9218, 9616, 10014, 10411, 10808, 11204, 11600, 11996, 12391,\r\n    12785, 13180, 13573, 13966, 14359, 14751, 15143, 15534, 15924, 16314, 16703, 17091, 17479, 17867, 18253, 18639,\r\n    19024, 19409, 19792, 20175, 20557, 20939, 21320, 21699, 22078, 22457, 22834, 23210, 23586, 23961, 24335, 24708,\r\n    25080, 25451, 25821, 26190, 26558, 26925, 27291, 27656, 28020, 28383, 28745, 29106, 29466, 29824, 30182, 30538,\r\n    30893, 31248, 31600, 31952, 32303, 32652, 33000, 33347, 33692, 34037, 34380, 34721, 35062, 35401, 35738, 36075,\r\n    36410, 36744, 37076, 37407, 37736, 38064, 38391, 38716, 39040, 39362, 39683, 40002, 40320, 40636, 40951, 41264,\r\n    41576, 41886, 42194, 42501, 42806, 43110, 43412, 43713, 44011, 44308, 44604, 44898, 45190, 45480, 45769, 46056,\r\n    46341, 46624, 46906, 47186, 47464, 47741, 48015, 48288, 48559, 48828, 49095, 49361, 49624, 49886, 50146, 50404,\r\n    50660, 50914, 51166, 51417, 51665, 51911, 52156, 52398, 52639, 52878, 53114, 53349, 53581, 53812, 54040, 54267,\r\n    54491, 54714, 54934, 55152, 55368, 55582, 55794, 56004, 56212, 56418, 56621, 56823, 57022, 57219, 57414, 57607,\r\n    57798, 57986, 58172, 58356, 58538, 58718, 58896, 59071, 59244, 59415, 59583, 59750, 59914, 60075, 60235, 60392,\r\n    60547, 60700, 60851, 60999, 61145, 61288, 61429, 61568, 61705, 61839, 61971, 62101, 62228, 62353, 62476, 62596,\r\n    62714, 62830, 62943, 63054, 63162, 63268, 63372, 63473, 63572, 63668, 63763, 63854, 63944, 64031, 64115, 64197,\r\n    64277, 64354, 64429, 64501, 64571, 64639, 64704, 64766, 64827, 64884, 64940, 64993, 65043, 65091, 65137, 65180,\r\n    65220, 65259, 65294, 65328, 65358, 65387, 65413, 65436, 65457, 65476, 65492, 65505, 65516, 65525, 65531, 65535,\r\n    65536  // sin(PI/2) = 1.0 = FP_ONE\r\n];\r\n\r\n// Pre-computed constant: (SIN_TABLE_SIZE * 2 / PI) in fixed-point\r\n// Used to map angles to table indices. Pre-computed to avoid Math.PI at runtime.\r\nconst FP_ANGLE_TO_INDEX = 10680707;  // = round(162.9746617261 * 65536)\r\n\r\n/** Fixed-point sine using lookup table with linear interpolation */\r\nexport function fpSin(angle: Fixed): Fixed {\r\n    // Normalize angle to 0 to 2PI using modulo (avoids infinite loops)\r\n    // First handle negative angles\r\n    if (angle < 0) {\r\n        const periods = ((-angle / FP_2PI) | 0) + 1;\r\n        angle += periods * FP_2PI;\r\n    }\r\n    // Then reduce to 0..2PI range\r\n    if (angle >= FP_2PI) {\r\n        angle = angle % FP_2PI;\r\n    }\r\n\r\n    // Determine quadrant\r\n    let quadrant = 0;\r\n    if (angle >= FP_PI) {\r\n        angle -= FP_PI;\r\n        quadrant = 2;\r\n    }\r\n    if (angle >= FP_HALF_PI) {\r\n        angle = FP_PI - angle;\r\n        quadrant += 1;\r\n    }\r\n\r\n    // Map angle to table index (0 to 256)\r\n    const indexFp = fpMul(angle, FP_ANGLE_TO_INDEX);\r\n    const index = indexFp >> FP_SHIFT;\r\n    const frac = indexFp & (FP_ONE - 1);\r\n\r\n    // Linear interpolation with safe bounds clamping\r\n    const clampedIndex = index < 0 ? 0 : (index > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : index);\r\n    const nextIndex = index + 1;\r\n    const clampedIndexNext = nextIndex < 0 ? 0 : (nextIndex > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : nextIndex);\r\n    const a = SIN_TABLE[clampedIndex] ?? 0;\r\n    const b = SIN_TABLE[clampedIndexNext] ?? FP_ONE;\r\n    let result = a + fpMul(b - a, frac);\r\n\r\n    // Apply quadrant sign\r\n    if (quadrant >= 2) result = -result;\r\n\r\n    return result;\r\n}\r\n\r\n/** Fixed-point cosine */\r\nexport function fpCos(angle: Fixed): Fixed {\r\n    return fpSin(angle + FP_HALF_PI);\r\n}\r\n\r\n/** Fixed-point atan2 using CORDIC-style approximation */\r\nexport function fpAtan2(y: Fixed, x: Fixed): Fixed {\r\n    if (x === 0 && y === 0) return 0;\r\n\r\n    const absX = fpAbs(x);\r\n    const absY = fpAbs(y);\r\n\r\n    // Use approximation: atan(y/x) = (PI/4) * (y/x) for |y/x| <= 1\r\n    let angle: Fixed;\r\n    if (absX >= absY) {\r\n        const ratio = fpDiv(absY, absX);\r\n        // atan approximation for small angles\r\n        angle = fpMul(ratio, 51472); // PI/4 * 65536 = 51472\r\n    } else {\r\n        const ratio = fpDiv(absX, absY);\r\n        angle = FP_HALF_PI - fpMul(ratio, 51472);\r\n    }\r\n\r\n    // Adjust for quadrant\r\n    if (x < 0) angle = FP_PI - angle;\r\n    if (y < 0) angle = -angle;\r\n\r\n    return angle;\r\n}\r\n", "/**\r\n * Deterministic Random\r\n *\r\n * Simple, deterministic random function. Same seed = same sequence.\r\n * Automatically overrides Math.random() on import for full determinism.\r\n */\r\n\r\n// ============================================\r\n// Internal State\r\n// ============================================\r\n\r\nlet s0 = 1;\r\nlet s1 = 2;\r\n\r\n// ============================================\r\n// Core Random Function\r\n// ============================================\r\n\r\nfunction next(): number {\r\n    let x = s0;\r\n    const y = s1;\r\n    s0 = y;\r\n    x ^= (x << 23) >>> 0;\r\n    x ^= x >>> 17;\r\n    x ^= y;\r\n    x ^= y >>> 26;\r\n    s1 = x >>> 0;\r\n    return (s0 + s1) >>> 0;\r\n}\r\n\r\n// ============================================\r\n// Public API\r\n// ============================================\r\n\r\n/**\r\n * Set the random seed (internal use).\r\n */\r\nfunction setSeed(seed: number): void {\r\n    seed = seed >>> 0;\r\n    if (seed === 0) seed = 1;\r\n\r\n    // Mix the seed into two state values\r\n    let s = seed;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s0 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    s = (seed * 0x9e3779b9) >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s1 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    if (s0 === 0 && s1 === 0) s0 = 1;\r\n}\r\n\r\n/**\r\n * Get random float between 0 (inclusive) and 1 (exclusive).\r\n * Works like Math.random() but deterministic.\r\n */\r\nexport function dRandom(): number {\r\n    return next() / 0x100000000;\r\n}\r\n\r\n// ============================================\r\n// State Save/Load (for rollback)\r\n// ============================================\r\n\r\nexport interface RandomState {\r\n    s0: number;\r\n    s1: number;\r\n}\r\n\r\nexport function saveRandomState(): RandomState {\r\n    return { s0, s1 };\r\n}\r\n\r\nexport function loadRandomState(state: RandomState): void {\r\n    s0 = state.s0;\r\n    s1 = state.s1;\r\n}\r\n\r\n// Initialize with default seed\r\nsetSeed(1);\r\n", "/**\r\n * ECS Constants\r\n *\r\n * Core constants for the Entity-Component-System architecture.\r\n */\r\n\r\n/**\r\n * Maximum number of concurrent entities.\r\n *\r\n * This is a hard limit due to TypedArray storage. Exceeding this will\r\n * throw an error. For most games, 10,000 is far more than needed.\r\n *\r\n * Memory usage per component field: MAX_ENTITIES \u00D7 4 bytes = 40 KB\r\n * With 10 components \u00D7 5 fields average = 2 MB total\r\n */\r\nexport const MAX_ENTITIES = 10_000;\r\n\r\n/**\r\n * Entity ID format: [12 bits generation][20 bits index]\r\n * - Generation: Prevents ABA problem when IDs are recycled\r\n * - Index: Direct array index for O(1) component access\r\n */\r\nexport const GENERATION_BITS = 12;\r\nexport const INDEX_BITS = 20;\r\nexport const INDEX_MASK = (1 << INDEX_BITS) - 1;\r\nexport const MAX_GENERATION = (1 << GENERATION_BITS) - 1;\r\n\r\n/**\r\n * System execution phases (in order)\r\n */\r\nexport const SYSTEM_PHASES = [\r\n    'input',\r\n    'update',\r\n    'prePhysics',\r\n    'physics',\r\n    'postPhysics',\r\n    'render'\r\n] as const;\r\n\r\nexport type SystemPhase = typeof SYSTEM_PHASES[number];\r\n", "/**\r\n * Component System\r\n *\r\n * Components are pure data containers. This module handles:\r\n * - Component type definitions with schemas\r\n * - Type inference from default values\r\n * - SoA (Structure of Arrays) storage allocation\r\n * - Pre-generated accessor class creation\r\n */\r\n\r\nimport { MAX_ENTITIES } from './constants';\r\nimport { toFixed, toFloat } from '../math';\r\n\r\n/**\r\n * Supported field types for components.\r\n * - i32: 32-bit integer (default for numbers, uses fixed-point for physics)\r\n * - u8: 8-bit unsigned (for flags, enums)\r\n * - bool: boolean (stored as u8)\r\n * - f32: 32-bit float (ONLY for render-only data, NON-DETERMINISTIC)\r\n */\r\nexport type FieldType = 'i32' | 'u8' | 'bool' | 'f32';\r\n\r\nexport interface FieldDefinition {\r\n    type: FieldType;\r\n    default: number | boolean;\r\n}\r\n\r\nexport interface ComponentSchema {\r\n    [fieldName: string]: FieldDefinition;\r\n}\r\n\r\n/**\r\n * Component storage using Structure of Arrays (SoA) pattern.\r\n * Each field is stored in a separate TypedArray for cache efficiency.\r\n */\r\nexport interface ComponentStorage {\r\n    /** Bitmask tracking which entities have this component */\r\n    mask: Uint32Array;\r\n\r\n    /** Field arrays indexed by entity index */\r\n    fields: Record<string, Int32Array | Uint8Array | Float32Array>;\r\n\r\n    /** Schema defining field types */\r\n    schema: ComponentSchema;\r\n}\r\n\r\n/**\r\n * Options for defining a component.\r\n */\r\nexport interface ComponentOptions {\r\n    /**\r\n     * Whether this component should be synchronized across the network.\r\n     * When false, the component is excluded from:\r\n     * - Network snapshots (not sent to other clients)\r\n     * - State hash computation (doesn't affect determinism checks)\r\n     * - Rollback state (not saved/restored during rollback)\r\n     *\r\n     * Use sync: false for client-only state like cameras, UI, local effects.\r\n     * @default true\r\n     */\r\n    sync?: boolean;\r\n}\r\n\r\n/**\r\n * Component type definition.\r\n */\r\nexport interface ComponentType<T extends Record<string, any> = any> {\r\n    readonly name: string;\r\n    readonly schema: ComponentSchema;\r\n    readonly storage: ComponentStorage;\r\n    readonly AccessorClass: new (index: number) => T;\r\n    readonly fieldNames: string[];\r\n    /** Whether this component is synchronized across network. Default: true */\r\n    readonly sync: boolean;\r\n}\r\n\r\n/**\r\n * Infer field definition from a default value.\r\n * ALL numbers default to i32 for determinism.\r\n * f32 requires explicit declaration and logs a warning.\r\n */\r\nexport function inferFieldDef(value: any): FieldDefinition {\r\n    // Explicit type definition\r\n    if (typeof value === 'object' && value !== null && 'type' in value) {\r\n        const def = value as { type: FieldType; default?: number | boolean };\r\n\r\n        if (def.type === 'f32') {\r\n            console.warn(\r\n                `Component field uses f32 which is NON-DETERMINISTIC. ` +\r\n                `Only use for render-only data, never for synced state.`\r\n            );\r\n        }\r\n\r\n        return {\r\n            type: def.type,\r\n            default: def.default ?? (def.type === 'bool' ? false : 0)\r\n        };\r\n    }\r\n\r\n    // Boolean inference\r\n    if (typeof value === 'boolean') {\r\n        return { type: 'bool', default: value };\r\n    }\r\n\r\n    // Number inference - ALL default to i32 for determinism\r\n    if (typeof value === 'number') {\r\n        return { type: 'i32', default: value };\r\n    }\r\n\r\n    // Null/undefined treated as i32 with 0 default\r\n    if (value === null || value === undefined) {\r\n        return { type: 'i32', default: 0 };\r\n    }\r\n\r\n    throw new Error(\r\n        `Unsupported field type: ${typeof value}. ` +\r\n        `Components can only contain numbers and booleans. ` +\r\n        `Use game.internString() for string values.`\r\n    );\r\n}\r\n\r\n/**\r\n * Create TypedArray for a field type.\r\n */\r\nfunction createFieldArray(type: FieldType): Int32Array | Uint8Array | Float32Array {\r\n    switch (type) {\r\n        case 'i32':\r\n            return new Int32Array(MAX_ENTITIES);\r\n        case 'u8':\r\n        case 'bool':\r\n            return new Uint8Array(MAX_ENTITIES);\r\n        case 'f32':\r\n            return new Float32Array(MAX_ENTITIES);\r\n        default:\r\n            throw new Error(`Unknown field type: ${type}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Create SoA storage for a component schema.\r\n */\r\nexport function createComponentStorage(schema: ComponentSchema): ComponentStorage {\r\n    const fields: Record<string, Int32Array | Uint8Array | Float32Array> = {};\r\n\r\n    for (const [name, def] of Object.entries(schema)) {\r\n        fields[name] = createFieldArray(def.type);\r\n    }\r\n\r\n    return {\r\n        mask: new Uint32Array(Math.ceil(MAX_ENTITIES / 32)),\r\n        fields,\r\n        schema\r\n    };\r\n}\r\n\r\n/**\r\n * Generate an accessor class for a component type.\r\n * Uses Object.defineProperty for optimal V8 performance (not Proxy).\r\n */\r\nexport function generateAccessorClass<T>(\r\n    name: string,\r\n    schema: ComponentSchema,\r\n    storage: ComponentStorage\r\n): new (index: number) => T {\r\n    // Create a class dynamically\r\n    const AccessorClass = function(this: any, index: number) {\r\n        this._index = index;\r\n    } as any;\r\n\r\n    AccessorClass.prototype = {};\r\n\r\n    // Add getter/setter for each field\r\n    for (const [fieldName, fieldDef] of Object.entries(schema)) {\r\n        const fieldArray = storage.fields[fieldName];\r\n        const isFixedPoint = fieldDef.type === 'i32';\r\n        const isBool = fieldDef.type === 'bool';\r\n\r\n        Object.defineProperty(AccessorClass.prototype, fieldName, {\r\n            get: function(this: { _index: number }) {\r\n                const value = fieldArray[this._index];\r\n                if (isBool) return value !== 0;\r\n                if (isFixedPoint) return toFloat(value as number);\r\n                return value;\r\n            },\r\n            set: function(this: { _index: number }, value: any) {\r\n                if (isBool) {\r\n                    fieldArray[this._index] = value ? 1 : 0;\r\n                } else if (isFixedPoint) {\r\n                    fieldArray[this._index] = toFixed(value);\r\n                } else {\r\n                    fieldArray[this._index] = value;\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: false\r\n        });\r\n    }\r\n\r\n    // Add _index property definition\r\n    Object.defineProperty(AccessorClass.prototype, '_index', {\r\n        value: 0,\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    return AccessorClass as new (index: number) => T;\r\n}\r\n\r\n/**\r\n * Component registry - stores all defined components.\r\n */\r\nconst componentRegistry = new Map<string, ComponentType>();\r\n\r\n/**\r\n * Define a new component type.\r\n *\r\n * @param name Unique component name\r\n * @param defaults Default values (type inferred from values)\r\n * @param options Optional configuration (sync, etc.)\r\n * @returns ComponentType for use in entity definitions\r\n *\r\n * @example\r\n * const Health = defineComponent('health', { current: 100, max: 100 });\r\n * const Position = defineComponent('position', { x: 0, y: 0 });\r\n *\r\n * // Client-only component (not synced)\r\n * const Camera2D = defineComponent('camera2d', { zoom: 1, targetZoom: 1 }, { sync: false });\r\n */\r\nexport function defineComponent<T extends Record<string, any>>(\r\n    name: string,\r\n    defaults: T,\r\n    options?: ComponentOptions\r\n): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\r\n    if (componentRegistry.has(name)) {\r\n        throw new Error(`Component '${name}' is already defined`);\r\n    }\r\n\r\n    // Build schema from defaults\r\n    const schema: ComponentSchema = {};\r\n    for (const [fieldName, defaultValue] of Object.entries(defaults)) {\r\n        schema[fieldName] = inferFieldDef(defaultValue);\r\n    }\r\n\r\n    // Create storage\r\n    const storage = createComponentStorage(schema);\r\n\r\n    // Generate accessor class\r\n    const AccessorClass = generateAccessorClass<any>(name, schema, storage);\r\n\r\n    const componentType: ComponentType = {\r\n        name,\r\n        schema,\r\n        storage,\r\n        AccessorClass,\r\n        fieldNames: Object.keys(schema),\r\n        sync: options?.sync !== false // Default to true\r\n    };\r\n\r\n    componentRegistry.set(name, componentType);\r\n\r\n    return componentType as any;\r\n}\r\n\r\n/**\r\n * Get a component type by name.\r\n */\r\nexport function getComponentType(name: string): ComponentType | undefined {\r\n    return componentRegistry.get(name);\r\n}\r\n\r\n/**\r\n * Check if entity has component (via bitmask).\r\n */\r\nexport function hasComponent(storage: ComponentStorage, index: number): boolean {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    return (storage.mask[word] & bit) !== 0;\r\n}\r\n\r\n/**\r\n * Add component to entity (set bit in mask).\r\n */\r\nexport function addComponentToEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] |= bit;\r\n}\r\n\r\n/**\r\n * Remove component from entity (clear bit in mask).\r\n */\r\nexport function removeComponentFromEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] &= ~bit;\r\n}\r\n\r\n/**\r\n * Initialize component fields to defaults for an entity.\r\n */\r\nexport function initializeComponentDefaults(storage: ComponentStorage, index: number): void {\r\n    for (const [fieldName, fieldDef] of Object.entries(storage.schema)) {\r\n        const arr = storage.fields[fieldName];\r\n        if (fieldDef.type === 'i32') {\r\n            arr[index] = toFixed(fieldDef.default as number);\r\n        } else if (fieldDef.type === 'bool') {\r\n            arr[index] = fieldDef.default ? 1 : 0;\r\n        } else {\r\n            arr[index] = fieldDef.default as number;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Clear all component registrations (for testing).\r\n */\r\nexport function clearComponentRegistry(): void {\r\n    componentRegistry.clear();\r\n}\r\n\r\n/**\r\n * Get all registered components.\r\n */\r\nexport function getAllComponents(): Map<string, ComponentType> {\r\n    return componentRegistry;\r\n}\r\n", "/**\n * Entity ID Allocator\n *\n * Manages entity ID allocation with generation counters for ABA safety.\n * Entity ID format: [12 bits generation][20 bits index]\n */\n\nimport {\n    MAX_ENTITIES,\n    INDEX_MASK,\n    INDEX_BITS,\n    MAX_GENERATION,\n    GENERATION_BITS\n} from './constants';\n\nexport interface EntityIdAllocatorState {\n    nextIndex: number;\n    freeList: number[];\n    generations: number[];\n}\n\nexport class EntityIdAllocator {\n    /** Generation counter for each entity slot */\n    private generations: Uint16Array;\n\n    /** Free list of available indices (sorted ascending for determinism) */\n    private freeList: number[] = [];\n\n    /** Next index to allocate if free list is empty */\n    private nextIndex: number = 0;\n\n    constructor() {\n        this.generations = new Uint16Array(MAX_ENTITIES);\n    }\n\n    /**\n     * Allocate a new entity ID.\n     * Returns entity ID with generation encoded.\n     */\n    allocate(): number {\n        let index: number;\n\n        if (this.freeList.length > 0) {\n            // Always take the LOWEST available index for determinism\n            index = this.freeList.shift()!;\n        } else {\n            if (this.nextIndex >= MAX_ENTITIES) {\n                throw new Error(\n                    `Entity limit exceeded (MAX_ENTITIES=${MAX_ENTITIES}). ` +\n                    `Consider destroying unused entities or increasing the limit.`\n                );\n            }\n            index = this.nextIndex++;\n        }\n\n        const generation = this.generations[index];\n        return (generation << INDEX_BITS) | index;\n    }\n\n    /**\n     * Free an entity ID, returning it to the pool.\n     * Increments generation to invalidate stale references.\n     */\n    free(eid: number): void {\n        const index = eid & INDEX_MASK;\n\n        // Increment generation (wrap at max)\n        this.generations[index] = ((this.generations[index] + 1) & MAX_GENERATION) as number;\n\n        // Binary search insert to maintain sorted order (deterministic)\n        const insertIdx = this.findInsertIndex(index);\n        this.freeList.splice(insertIdx, 0, index);\n    }\n\n    /**\n     * Check if an entity ID is still valid (generation matches).\n     */\n    isValid(eid: number): boolean {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n        return index < this.nextIndex && this.generations[index] === generation;\n    }\n\n    /**\n     * Get the index portion of an entity ID.\n     */\n    getIndex(eid: number): number {\n        return eid & INDEX_MASK;\n    }\n\n    /**\n     * Get the generation portion of an entity ID.\n     */\n    getGeneration(eid: number): number {\n        return eid >>> INDEX_BITS;\n    }\n\n    /**\n     * Get current state for snapshotting.\n     */\n    getState(): EntityIdAllocatorState {\n        return {\n            nextIndex: this.nextIndex,\n            freeList: [...this.freeList],\n            generations: Array.from(this.generations.slice(0, this.nextIndex))\n        };\n    }\n\n    /**\n     * Restore state from snapshot.\n     */\n    setState(state: EntityIdAllocatorState): void {\n        this.nextIndex = state.nextIndex;\n        this.freeList = [...state.freeList];\n\n        // Restore generations\n        for (let i = 0; i < state.generations.length; i++) {\n            this.generations[i] = state.generations[i];\n        }\n    }\n\n    /**\n     * Reset allocator to initial state.\n     */\n    reset(): void {\n        this.nextIndex = 0;\n        this.freeList = [];\n        this.generations.fill(0);\n    }\n\n    /**\n     * Get number of active entities.\n     */\n    getActiveCount(): number {\n        return this.nextIndex - this.freeList.length;\n    }\n\n    /**\n     * Binary search to find insert position for sorted free list.\n     */\n    /**\n     * Get next ID that will be allocated (for snapshots).\n     */\n    getNextId(): number {\n        return this.nextIndex;\n    }\n\n    /**\n     * Set next ID (for snapshot restore).\n     */\n    setNextId(id: number): void {\n        this.nextIndex = id;\n    }\n\n    /**\n     * Allocate a specific entity ID (for snapshot restore).\n     * This bypasses normal allocation and marks the specific eid as used.\n     * Returns the requested eid.\n     */\n    allocateSpecific(eid: number): number {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n\n        // Extend nextIndex if needed\n        if (index >= this.nextIndex) {\n            this.nextIndex = index + 1;\n        }\n\n        // Remove from free list if present\n        const freeIdx = this.freeList.indexOf(index);\n        if (freeIdx !== -1) {\n            this.freeList.splice(freeIdx, 1);\n        }\n\n        // Set the generation\n        this.generations[index] = generation;\n\n        return eid;\n    }\n\n    private findInsertIndex(index: number): number {\n        let lo = 0;\n        let hi = this.freeList.length;\n\n        while (lo < hi) {\n            const mid = (lo + hi) >>> 1;\n            if (this.freeList[mid] < index) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n}\n", "/**\n * Standard ECS Components\n *\n * Built-in components for common game functionality.\n * All numeric values use fixed-point (i32) for determinism.\n */\n\nimport { defineComponent, ComponentType } from '../core/component';\n\n/**\n * Transform2D - Position and rotation.\n */\nexport const Transform2D = defineComponent('Transform2D', {\n    x: 0,\n    y: 0,\n    angle: 0\n});\n\n/**\n * Body2D - Physics body properties.\n */\nexport const Body2D = defineComponent('Body2D', {\n    // Velocity\n    vx: 0,\n    vy: 0,\n\n    // Angular velocity\n    angularVelocity: 0,\n\n    // Force accumulator (added to velocity each frame, then cleared)\n    forceX: 0,\n    forceY: 0,\n\n    // Impulse accumulator (added to velocity once, then cleared)\n    impulseX: 0,\n    impulseY: 0,\n\n    // Size (use width/height OR radius)\n    width: 0,\n    height: 0,\n    radius: 0,\n\n    // Physics properties\n    mass: 1,\n    restitution: 0,    // Bounciness (0-1)\n    friction: 0,\n\n    // Body type: 0=dynamic, 1=static, 2=kinematic\n    bodyType: 0,\n\n    // Shape type: 0=rect, 1=circle\n    shapeType: 1,\n\n    // Is sensor (no collision response, just events)\n    damping: 0,\n    isSensor: false\n});\n// Add helper methods to Body2D accessor prototype\n(Body2D.AccessorClass.prototype as any).setVelocity = function(vx: number, vy: number): void {\n    this.vx = vx;\n    this.vy = vy;\n};\n\n/**\n * Player - Marks an entity as player-controlled.\n * This is the ownership component - attach to any entity a player controls.\n * clientId is stored as interned string ID (integer).\n */\nexport const Player = defineComponent('Player', {\n    clientId: 0    // Interned clientId string\n});\n\n/**\n * Sprite - Visual rendering component.\n *\n * Can render either:\n * - Simple shapes (circle, rect) with color\n * - Image sprites (via spriteId)\n */\nexport const Sprite = defineComponent('Sprite', {\n    // Shape type: 0=rect, 1=circle, 2=image\n    shape: 1,  // Default circle\n\n    // Size (for shapes)\n    width: 0,\n    height: 0,\n    radius: 10,\n\n    // Color (interned string ID, e.g., '#ff0000')\n    color: 0,\n\n    // Image sprite ID (interned string, for shape=SPRITE_IMAGE)\n    spriteId: 0,\n\n    // Render offset from transform position\n    offsetX: 0,\n    offsetY: 0,\n\n    // Scale\n    scaleX: 1,\n    scaleY: 1,\n\n    // Layer for z-ordering (higher = in front)\n    layer: 0,\n\n    // Visibility\n    visible: true\n});\n\n// Sprite shape constants (reuse SHAPE_RECT, SHAPE_CIRCLE, add SPRITE_IMAGE)\nexport const SPRITE_IMAGE = 2;\n\n/**\n * Camera2D - 2D camera for viewport control.\n *\n * This is a client-only component (sync: false) - each client manages\n * their own camera independently. The camera is not included in:\n * - Network snapshots\n * - State hash computation\n * - Rollback state\n *\n * @example\n * // Define camera entity\n * game.defineEntity('camera')\n *     .with(Camera2D)\n *     .register();\n *\n * // Spawn and use camera\n * const cam = game.spawn('camera');\n * const camera = cam.get(Camera2D);\n * camera.x = player.x;\n * camera.y = player.y;\n * camera.zoom = 1.5;\n */\nexport const Camera2D = defineComponent('Camera2D', {\n    // Position (world coordinates the camera is centered on)\n    x: 0,\n    y: 0,\n\n    // Zoom level (1 = normal, >1 = zoomed in, <1 = zoomed out)\n    zoom: 1,\n\n    // Target zoom for smooth transitions\n    targetZoom: 1,\n\n    // Smoothing factor for position interpolation (0-1, higher = snappier)\n    smoothing: 0.1,\n\n    // Optional: follow entity ID (0 = no target)\n    followEntity: 0,\n\n    // Viewport bounds (set by renderer)\n    viewportWidth: 0,\n    viewportHeight: 0\n}, { sync: false });\n\n// Re-export types for convenience\nexport type Transform2DData = {\n    x: number;\n    y: number;\n    angle: number;\n};\n\nexport type Body2DData = {\n    vx: number;\n    vy: number;\n    angularVelocity: number;\n    forceX: number;\n    forceY: number;\n    impulseX: number;\n    impulseY: number;\n    width: number;\n    height: number;\n    radius: number;\n    mass: number;\n    restitution: number;\n    friction: number;\n    bodyType: number;\n    shapeType: number;\n    isSensor: boolean;\n    setVelocity(vx: number, vy: number): void;\n};\n\nexport type PlayerType = {\n    clientId: number;\n};\n\n// Body type constants\nexport const BODY_DYNAMIC = 0;\nexport const BODY_STATIC = 1;\nexport const BODY_KINEMATIC = 2;\n\n// Shape type constants\nexport const SHAPE_RECT = 0;\nexport const SHAPE_CIRCLE = 1;\n\nexport type Camera2DData = {\n    x: number;\n    y: number;\n    zoom: number;\n    targetZoom: number;\n    smoothing: number;\n    followEntity: number;\n    viewportWidth: number;\n    viewportHeight: number;\n};\n", "/**\r\n * Entity Wrapper\r\n *\r\n * Provides an ergonomic API for entity access while using SoA storage internally.\r\n * Entity wrappers are pooled and reused to minimize allocations.\r\n */\r\n\r\nimport {\r\n    ComponentType,\r\n    hasComponent,\r\n    addComponentToEntity,\r\n    removeComponentFromEntity,\r\n    initializeComponentDefaults\r\n} from './component';\r\nimport { INDEX_MASK } from './constants';\r\nimport { toFixed, toFloat, fpMul, fpDiv, fpSqrt, FP_ONE } from '../math';\r\nimport { Transform2D, Body2D } from '../components';\r\n\r\n/**\r\n * Render-only state (client-only, never serialized).\r\n */\r\nexport interface RenderState {\r\n    /** Previous tick X position (for interpolation) */\r\n    prevX: number;\r\n    /** Previous tick Y position */\r\n    prevY: number;\r\n    /** Interpolated X (computed each render) */\r\n    interpX: number;\r\n    /** Interpolated Y */\r\n    interpY: number;\r\n    /** Screen X after camera transform */\r\n    screenX: number;\r\n    /** Screen Y after camera transform */\r\n    screenY: number;\r\n    /** Whether entity is visible */\r\n    visible: boolean;\r\n    /** Custom render properties */\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * Restore callback type - called after snapshot load to reconstruct derived fields.\r\n */\r\nexport type EntityRestoreCallback = (entity: Entity, game: any) => void;\r\n\r\n/**\r\n * Entity definition for spawning.\r\n */\r\nexport interface EntityDefinition {\r\n    name: string;\r\n    components: Array<{\r\n        type: ComponentType;\r\n        defaults?: Record<string, any>;\r\n    }>;\r\n    /** Optional: fields to sync in snapshots. If not set, all fields are synced. */\r\n    syncFields?: string[];\r\n    /** Optional: callback to reconstruct non-synced fields after snapshot load. */\r\n    onRestore?: EntityRestoreCallback;\r\n}\r\n\r\n/**\r\n * Entity wrapper - provides ergonomic access to SoA-stored entity data.\r\n */\r\nexport class Entity {\r\n    /** Entity ID (includes generation) */\r\n    eid: number = -1;\r\n\r\n    /** Entity type name */\r\n    type: string = '';\r\n\r\n    /** Whether entity is destroyed */\r\n    destroyed: boolean = false;\r\n\r\n    /** Render-only state (client-only, never serialized) */\r\n    render: RenderState = {\r\n        prevX: 0,\r\n        prevY: 0,\r\n        interpX: 0,\r\n        interpY: 0,\r\n        screenX: 0,\r\n        screenY: 0,\r\n        visible: true\r\n    };\r\n\r\n    /** Component types this entity has */\r\n    private _components: ComponentType[] = [];\r\n\r\n    /** Cached accessor instances */\r\n    private _accessors: Map<ComponentType, any> = new Map();\r\n\r\n    /** Reference to world for operations */\r\n    private _world: EntityWorld | null = null;\r\n\r\n    /** Current frame's input data (set during tick) */\r\n    private _inputData: Record<string, any> | null = null;\r\n\r\n    /**\r\n     * Get component accessor.\r\n     * Returns typed accessor for reading/writing component data.\r\n     */\r\n    get<T extends Record<string, any>>(component: ComponentType<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        // Check if entity has this component\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} (type: ${this.type}) does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Get or create accessor\r\n        let accessor = this._accessors.get(component);\r\n        if (!accessor) {\r\n            accessor = new component.AccessorClass(index);\r\n            this._accessors.set(component, accessor);\r\n        } else {\r\n            // Update index in case wrapper was reused\r\n            accessor._index = index;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Check if entity has a component.\r\n     */\r\n    has(component: ComponentType): boolean {\r\n        return hasComponent(component.storage, this.eid & INDEX_MASK);\r\n    }\r\n\r\n    /**\r\n     * Add a component to this entity at runtime.\r\n     */\r\n    addComponent<T extends Record<string, any>>(component: ComponentType<T>, data?: Partial<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} already has component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Add to storage\r\n        addComponentToEntity(component.storage, index);\r\n        initializeComponentDefaults(component.storage, index);\r\n\r\n        // Track component\r\n        this._components.push(component);\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.addComponent(this.eid, component);\r\n        }\r\n\r\n        // Get accessor and apply data\r\n        const accessor = this.get(component);\r\n        if (data) {\r\n            for (const [key, value] of Object.entries(data)) {\r\n                (accessor as any)[key] = value;\r\n            }\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Remove a component from this entity at runtime.\r\n     */\r\n    removeComponent(component: ComponentType): void {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Remove from storage\r\n        removeComponentFromEntity(component.storage, index);\r\n\r\n        // Remove from tracking\r\n        const idx = this._components.indexOf(component);\r\n        if (idx !== -1) {\r\n            this._components.splice(idx, 1);\r\n        }\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.removeComponent(this.eid, component);\r\n        }\r\n\r\n        // Clear cached accessor\r\n        this._accessors.delete(component);\r\n    }\r\n\r\n    /**\r\n     * Destroy this entity.\r\n     */\r\n    destroy(): void {\r\n        if (this.destroyed) return;\r\n        this.destroyed = true;\r\n\r\n        if (this._world) {\r\n            this._world.destroyEntity(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all components on this entity.\r\n     */\r\n    getComponents(): ComponentType[] {\r\n        return [...this._components];\r\n    }\r\n\r\n    /**\r\n     * Get current frame's input data.\r\n     * Returns null if no input was received this tick.\r\n     */\r\n    get input(): Record<string, any> | null {\r\n        return this._inputData;\r\n    }\r\n\r\n    /**\r\n     * Set input data for this tick (called by World).\r\n     */\r\n    _setInputData(data: Record<string, any> | null): void {\r\n        this._inputData = data;\r\n    }\r\n\r\n    /**\r\n     * Save current position to render.prev* for interpolation.\r\n     * Should be called in prePhysics phase before physics updates position.\r\n     */\r\n    _savePreviousState(): void {\r\n        // Look for common position components (Body2D, Transform, etc.)\r\n        // Store current position as previous for interpolation\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            // Check for x/y fields in component\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const xArr = component.storage.fields['x'];\r\n                const yArr = component.storage.fields['y'];\r\n\r\n                // Convert from fixed-point to float for render state\r\n                this.render.prevX = toFloat(xArr[index]);\r\n                this.render.prevY = toFloat(yArr[index]);\r\n                return; // Found position component, done\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate interpolated position for rendering.\r\n     * @param alpha Interpolation factor (0-1) between previous and current state\r\n     */\r\n    interpolate(alpha: number): void {\r\n        // Get current position\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const currentX = toFloat(component.storage.fields['x'][index]);\r\n                const currentY = toFloat(component.storage.fields['y'][index]);\r\n\r\n                // Linear interpolation between previous and current\r\n                this.render.interpX = this.render.prevX + (currentX - this.render.prevX) * alpha;\r\n                this.render.interpY = this.render.prevY + (currentY - this.render.prevY) * alpha;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize entity (called by world).\r\n     */\r\n    _init(\r\n        eid: number,\r\n        type: string,\r\n        components: ComponentType[],\r\n        world: EntityWorld\r\n    ): void {\r\n        this.eid = eid;\r\n        this.type = type;\r\n        this.destroyed = false;\r\n        this._components = components;\r\n        this._world = world;\r\n        this._accessors.clear();\r\n\r\n        // Reset render state\r\n        this.render.prevX = 0;\r\n        this.render.prevY = 0;\r\n        this.render.interpX = 0;\r\n        this.render.interpY = 0;\r\n        this.render.screenX = 0;\r\n        this.render.screenY = 0;\r\n        this.render.visible = true;\r\n\r\n        // Clear input data\r\n        this._inputData = null;\r\n    }\r\n\r\n    /**\r\n     * Clean up entity (called when returned to pool).\r\n     */\r\n    _cleanup(): void {\r\n        this._world = null;\r\n        this._components = [];\r\n        this._accessors.clear();\r\n        this._inputData = null;\r\n    }\r\n\r\n    // ==========================================\r\n    // Movement Helpers (Deterministic)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Set velocity toward a target point.\r\n     * Uses fixed-point math internally for determinism.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     */\r\n    moveTowards(target: { x: number; y: number }, speed: number): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n\r\n        // Distance squared (avoid sqrt if possible)\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        if (distSq === 0) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        // Distance\r\n        const dist = fpSqrt(distSq);\r\n\r\n        // Normalize and scale by speed (speed is in units/sec, physics expects units/sec)\r\n        const speedFp = toFixed(speed * 60); // Convert to units per tick at 60fps base\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Set velocity toward a target, but stop if within radius.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     * @param stopRadius Stop moving when within this distance (default: 0)\r\n     */\r\n    moveTowardsWithStop(target: { x: number; y: number }, speed: number, stopRadius: number = 0): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const stopRadiusFp = toFixed(stopRadius);\r\n        const stopRadiusSq = fpMul(stopRadiusFp, stopRadiusFp);\r\n\r\n        // Stop if within radius\r\n        if (distSq <= stopRadiusSq) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        const dist = fpSqrt(distSq);\r\n        const speedFp = toFixed(speed * 60);\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Stop all movement.\r\n     */\r\n    stop(): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = 0;\r\n        body.vy = 0;\r\n    }\r\n\r\n    /**\r\n     * Set velocity directly.\r\n     *\r\n     * @param vx X velocity\r\n     * @param vy Y velocity\r\n     */\r\n    setVelocity(vx: number, vy: number): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = vx;\r\n        body.vy = vy;\r\n    }\r\n\r\n    /**\r\n     * Get distance to a point (deterministic).\r\n     */\r\n    distanceTo(target: { x: number; y: number }): number {\r\n        if (!this.has(Transform2D)) return 0;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n\r\n        return toFloat(fpSqrt(distSq));\r\n    }\r\n\r\n    /**\r\n     * Check if within distance of a point (deterministic).\r\n     */\r\n    isWithin(target: { x: number; y: number }, distance: number): boolean {\r\n        if (!this.has(Transform2D)) return false;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const distFp = toFixed(distance);\r\n        const distSqThreshold = fpMul(distFp, distFp);\r\n\r\n        return distSq <= distSqThreshold;\r\n    }\r\n}\r\n\r\n/**\r\n * Forward declaration for EntityWorld (actual implementation in world.ts).\r\n */\r\nexport interface EntityWorld {\r\n    queryEngine: {\r\n        addComponent(eid: number, component: ComponentType): void;\r\n        removeComponent(eid: number, component: ComponentType): void;\r\n    };\r\n    destroyEntity(entity: Entity): void;\r\n}\r\n\r\n/**\r\n * Entity pool for reusing entity wrappers.\r\n */\r\nexport class EntityPool {\r\n    private pool: Entity[] = [];\r\n    private active: Map<number, Entity> = new Map();\r\n\r\n    /**\r\n     * Get or create an entity wrapper.\r\n     */\r\n    acquire(eid: number): Entity {\r\n        // Check if already have wrapper for this eid\r\n        let entity = this.active.get(eid);\r\n        if (entity) {\r\n            return entity;\r\n        }\r\n\r\n        // Get from pool or create new\r\n        entity = this.pool.pop() || new Entity();\r\n        this.active.set(eid, entity);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Return entity wrapper to pool.\r\n     */\r\n    release(eid: number): void {\r\n        const entity = this.active.get(eid);\r\n        if (entity) {\r\n            entity._cleanup();\r\n            this.active.delete(eid);\r\n            this.pool.push(entity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get entity by eid if it exists.\r\n     */\r\n    get(eid: number): Entity | undefined {\r\n        return this.active.get(eid);\r\n    }\r\n\r\n    /**\r\n     * Check if entity exists.\r\n     */\r\n    has(eid: number): boolean {\r\n        return this.active.has(eid);\r\n    }\r\n\r\n    /**\r\n     * Clear all entities.\r\n     */\r\n    clear(): void {\r\n        for (const entity of this.active.values()) {\r\n            entity._cleanup();\r\n            this.pool.push(entity);\r\n        }\r\n        this.active.clear();\r\n    }\r\n\r\n    /**\r\n     * Get count of active entities.\r\n     */\r\n    get size(): number {\r\n        return this.active.size;\r\n    }\r\n}\r\n", "/**\r\n * Query Engine\r\n *\r\n * Efficient entity queries with caching and iterator support.\r\n * Queries return iterators with snapshot semantics for safe mutation.\r\n */\r\n\r\nimport { ComponentType, hasComponent } from './component';\r\nimport { INDEX_MASK } from './constants';\r\n\r\n/**\r\n * Entity-like interface for query results.\r\n * Actual Entity class will implement this.\r\n */\r\nexport interface QueryableEntity {\r\n    readonly eid: number;\r\n    readonly type: string;\r\n    readonly destroyed: boolean;\r\n}\r\n\r\n/**\r\n * Function to get entity wrapper by eid.\r\n */\r\nexport type EntityGetter = (eid: number) => QueryableEntity | null;\r\n\r\n/**\r\n * Function to check if entity is destroyed.\r\n */\r\nexport type DestroyedChecker = (eid: number) => boolean;\r\n\r\n/**\r\n * Query iterator with snapshot semantics.\r\n * Captures eid list at creation time for safe iteration during mutation.\r\n */\r\nexport class QueryIterator<T extends QueryableEntity> implements Iterable<T> {\r\n    private eids: number[];\r\n    private index: number = 0;\r\n    private getEntity: EntityGetter;\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(\r\n        matchingEids: number[],\r\n        getEntity: EntityGetter,\r\n        isDestroyed: DestroyedChecker\r\n    ) {\r\n        // Copy eids at creation time - safe from mutation\r\n        this.eids = matchingEids.slice();\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        this.index = 0;\r\n        return {\r\n            next: (): IteratorResult<T> => {\r\n                while (this.index < this.eids.length) {\r\n                    const eid = this.eids[this.index++];\r\n\r\n                    // Skip destroyed entities\r\n                    if (this.isDestroyed(eid)) continue;\r\n\r\n                    const entity = this.getEntity(eid);\r\n                    if (entity) {\r\n                        return { done: false, value: entity as T };\r\n                    }\r\n                }\r\n                return { done: true, value: undefined as any };\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert to array (allocates).\r\n     */\r\n    toArray(): T[] {\r\n        const result: T[] = [];\r\n        for (const entity of this) {\r\n            result.push(entity);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get first matching entity.\r\n     */\r\n    first(): T | null {\r\n        for (const entity of this) {\r\n            return entity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find entity matching predicate.\r\n     */\r\n    find(predicate: (entity: T) => boolean): T | null {\r\n        for (const entity of this) {\r\n            if (predicate(entity)) {\r\n                return entity;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Count entities without allocating array.\r\n     */\r\n    count(): number {\r\n        let count = 0;\r\n        for (const _ of this) {\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n/**\r\n * Query engine - manages entity indices and cached queries.\r\n */\r\nexport class QueryEngine {\r\n    /** Type index: entity type -> set of eids */\r\n    private typeIndex: Map<string, Set<number>> = new Map();\r\n\r\n    /** Component index: component -> set of eids */\r\n    private componentIndex: Map<ComponentType, Set<number>> = new Map();\r\n\r\n    /** Client ID index: clientId -> eid (O(1) lookup) */\r\n    private clientIdIndex: Map<number, number> = new Map();\r\n\r\n    /** Entity getter function */\r\n    private getEntity: EntityGetter;\r\n\r\n    /** Destroyed checker function */\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(getEntity: EntityGetter, isDestroyed: DestroyedChecker) {\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    /**\r\n     * Register an entity in the indices.\r\n     */\r\n    addEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Add to type index\r\n        let typeSet = this.typeIndex.get(type);\r\n        if (!typeSet) {\r\n            typeSet = new Set();\r\n            this.typeIndex.set(type, typeSet);\r\n        }\r\n        typeSet.add(eid);\r\n\r\n        // Add to component indices\r\n        for (const component of components) {\r\n            let compSet = this.componentIndex.get(component);\r\n            if (!compSet) {\r\n                compSet = new Set();\r\n                this.componentIndex.set(component, compSet);\r\n            }\r\n            compSet.add(eid);\r\n        }\r\n\r\n        // Add to clientId index if provided\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.set(clientId, eid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an entity from all indices.\r\n     */\r\n    removeEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Remove from type index\r\n        this.typeIndex.get(type)?.delete(eid);\r\n\r\n        // Remove from component indices\r\n        for (const component of components) {\r\n            this.componentIndex.get(component)?.delete(eid);\r\n        }\r\n\r\n        // Remove from clientId index\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.delete(clientId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add component to an existing entity.\r\n     */\r\n    addComponent(eid: number, component: ComponentType): void {\r\n        let compSet = this.componentIndex.get(component);\r\n        if (!compSet) {\r\n            compSet = new Set();\r\n            this.componentIndex.set(component, compSet);\r\n        }\r\n        compSet.add(eid);\r\n    }\r\n\r\n    /**\r\n     * Remove component from an existing entity.\r\n     */\r\n    removeComponent(eid: number, component: ComponentType): void {\r\n        this.componentIndex.get(component)?.delete(eid);\r\n    }\r\n\r\n    /**\r\n     * Update clientId mapping for an entity.\r\n     */\r\n    setClientId(eid: number, clientId: number): void {\r\n        this.clientIdIndex.set(clientId, eid);\r\n    }\r\n\r\n    /**\r\n     * Remove clientId mapping.\r\n     */\r\n    removeClientId(clientId: number): void {\r\n        this.clientIdIndex.delete(clientId);\r\n    }\r\n\r\n    /**\r\n     * Query by entity type.\r\n     */\r\n    byType<T extends QueryableEntity>(type: string): QueryIterator<T> {\r\n        const typeSet = this.typeIndex.get(type);\r\n        const eids = typeSet ? this.sortedEids(typeSet) : [];\r\n        return new QueryIterator<T>(eids, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by component(s) - entities must have ALL specified components.\r\n     */\r\n    byComponents<T extends QueryableEntity>(...components: ComponentType[]): QueryIterator<T> {\r\n        if (components.length === 0) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Start with the smallest set for efficiency\r\n        let smallestSet: Set<number> | undefined;\r\n        let smallestSize = Infinity;\r\n\r\n        for (const component of components) {\r\n            const compSet = this.componentIndex.get(component);\r\n            if (!compSet || compSet.size === 0) {\r\n                // One component has no entities, result is empty\r\n                return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n            }\r\n            if (compSet.size < smallestSize) {\r\n                smallestSize = compSet.size;\r\n                smallestSet = compSet;\r\n            }\r\n        }\r\n\r\n        if (!smallestSet) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Filter to entities that have ALL components\r\n        const result: number[] = [];\r\n        for (const eid of smallestSet) {\r\n            let hasAll = true;\r\n            for (const component of components) {\r\n                if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                    hasAll = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (hasAll) {\r\n                result.push(eid);\r\n            }\r\n        }\r\n\r\n        // Sort by eid for deterministic order\r\n        result.sort((a, b) => a - b);\r\n\r\n        return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by type or component.\r\n     */\r\n    query<T extends QueryableEntity>(\r\n        typeOrComponent: string | ComponentType,\r\n        ...moreComponents: ComponentType[]\r\n    ): QueryIterator<T> {\r\n        if (typeof typeOrComponent === 'string') {\r\n            // Query by type\r\n            if (moreComponents.length > 0) {\r\n                // Type + components: filter type results by components\r\n                const typeSet = this.typeIndex.get(typeOrComponent);\r\n                if (!typeSet || typeSet.size === 0) {\r\n                    return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n                }\r\n\r\n                const result: number[] = [];\r\n                for (const eid of typeSet) {\r\n                    let hasAll = true;\r\n                    for (const component of moreComponents) {\r\n                        if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                            hasAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (hasAll) {\r\n                        result.push(eid);\r\n                    }\r\n                }\r\n\r\n                result.sort((a, b) => a - b);\r\n                return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n            }\r\n\r\n            return this.byType<T>(typeOrComponent);\r\n        }\r\n\r\n        // Query by component(s)\r\n        return this.byComponents<T>(typeOrComponent, ...moreComponents);\r\n    }\r\n\r\n    /**\r\n     * O(1) lookup by clientId.\r\n     */\r\n    getByClientId(clientId: number): number | undefined {\r\n        return this.clientIdIndex.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Get all entity IDs (sorted for determinism).\r\n     */\r\n    getAllEids(): number[] {\r\n        const allEids = new Set<number>();\r\n\r\n        for (const typeSet of this.typeIndex.values()) {\r\n            for (const eid of typeSet) {\r\n                allEids.add(eid);\r\n            }\r\n        }\r\n\r\n        return Array.from(allEids).sort((a, b) => a - b);\r\n    }\r\n\r\n    /**\r\n     * Clear all indices (for reset).\r\n     */\r\n    clear(): void {\r\n        this.typeIndex.clear();\r\n        this.componentIndex.clear();\r\n        this.clientIdIndex.clear();\r\n    }\r\n\r\n    /**\r\n     * Get sorted eids from a set (for deterministic iteration).\r\n     */\r\n    private sortedEids(set: Set<number>): number[] {\r\n        return Array.from(set).sort((a, b) => a - b);\r\n    }\r\n}\r\n", "/**\r\n * System Scheduler\r\n *\r\n * Manages system registration and execution in ordered phases.\r\n * Systems are functions that operate on entities with specific components.\r\n */\r\n\r\nimport { SystemPhase, SYSTEM_PHASES } from './constants';\r\n\r\nexport interface SystemOptions {\r\n    /** Execution phase (default: 'update') */\r\n    phase?: SystemPhase;\r\n\r\n    /** Only run on client (e.g., rendering) */\r\n    client?: boolean;\r\n\r\n    /** Only run on server */\r\n    server?: boolean;\r\n\r\n    /** Execution order within phase (lower = earlier) */\r\n    order?: number;\r\n}\r\n\r\nexport type SystemFn = () => void;\r\n\r\ninterface SystemEntry {\r\n    fn: SystemFn;\r\n    options: SystemOptions;\r\n    order: number;\r\n}\r\n\r\n/**\r\n * System scheduler - manages system registration and execution.\r\n */\r\nexport class SystemScheduler {\r\n    /** Systems organized by phase */\r\n    private systems: Map<SystemPhase, SystemEntry[]> = new Map();\r\n\r\n    /** Whether we're running on client or server */\r\n    private isClient: boolean = true;\r\n\r\n    /** System ID counter for ordering */\r\n    private nextSystemId: number = 0;\r\n\r\n    constructor() {\r\n        // Initialize all phases\r\n        for (const phase of SYSTEM_PHASES) {\r\n            this.systems.set(phase, []);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set whether this scheduler is running on client or server.\r\n     */\r\n    setIsClient(isClient: boolean): void {\r\n        this.isClient = isClient;\r\n    }\r\n\r\n    /**\r\n     * Add a system to the scheduler.\r\n     *\r\n     * @param fn System function to execute\r\n     * @param options System options (phase, client/server, order)\r\n     * @returns Function to remove the system\r\n     */\r\n    add(fn: SystemFn, options: SystemOptions = {}): () => void {\r\n        const phase = options.phase || 'update';\r\n        const systems = this.systems.get(phase);\r\n\r\n        if (!systems) {\r\n            throw new Error(`Unknown system phase: ${phase}`);\r\n        }\r\n\r\n        const entry: SystemEntry = {\r\n            fn,\r\n            options,\r\n            order: options.order ?? this.nextSystemId++\r\n        };\r\n\r\n        systems.push(entry);\r\n\r\n        // Sort by order\r\n        systems.sort((a, b) => a.order - b.order);\r\n\r\n        // Return removal function\r\n        return () => this.remove(fn);\r\n    }\r\n\r\n    /**\r\n     * Remove a system from the scheduler.\r\n     */\r\n    remove(fn: SystemFn): boolean {\r\n        for (const systems of this.systems.values()) {\r\n            const index = systems.findIndex(s => s.fn === fn);\r\n            if (index !== -1) {\r\n                systems.splice(index, 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Run all systems in a specific phase.\r\n     */\r\n    runPhase(phase: SystemPhase): void {\r\n        const systems = this.systems.get(phase);\r\n        if (!systems) return;\r\n\r\n        for (const system of systems) {\r\n            // Skip client-only systems on server\r\n            if (system.options.client && !this.isClient) continue;\r\n\r\n            // Skip server-only systems on client\r\n            if (system.options.server && this.isClient) continue;\r\n\r\n            // Execute system\r\n            try {\r\n                const result = system.fn() as unknown;\r\n\r\n                // Check for accidental async systems\r\n                if (result && typeof result === 'object' && 'then' in result) {\r\n                    throw new Error(\r\n                        `System returned a Promise. Async systems are not allowed ` +\r\n                        `as they break determinism. Remove 'await' from your system.`\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error in system during '${phase}' phase:`, error);\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run all phases in order (except render if not client).\r\n     */\r\n    runAll(): void {\r\n        for (const phase of SYSTEM_PHASES) {\r\n            // Skip render phase on server\r\n            if (phase === 'render' && !this.isClient) continue;\r\n\r\n            this.runPhase(phase);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get count of systems in each phase (for debugging).\r\n     */\r\n    getSystemCounts(): Record<SystemPhase, number> {\r\n        const counts: Partial<Record<SystemPhase, number>> = {};\r\n        for (const [phase, systems] of this.systems) {\r\n            counts[phase] = systems.length;\r\n        }\r\n        return counts as Record<SystemPhase, number>;\r\n    }\r\n\r\n    /**\r\n     * Clear all systems (for testing).\r\n     */\r\n    clear(): void {\r\n        for (const systems of this.systems.values()) {\r\n            systems.length = 0;\r\n        }\r\n        this.nextSystemId = 0;\r\n    }\r\n}\r\n", "/**\r\n * Sparse Snapshot System\r\n *\r\n * Efficient snapshot encoding using entity bitmaps.\r\n * Only active entities are stored, not MAX_ENTITIES slots.\r\n */\r\n\r\nimport { MAX_ENTITIES, INDEX_MASK } from './constants';\r\nimport { ComponentType, getAllComponents } from './component';\r\nimport { EntityIdAllocatorState } from './entity-id';\r\n\r\n/**\r\n * Sparse snapshot format.\r\n * Much smaller than full snapshot when entity count << MAX_ENTITIES.\r\n */\r\nexport interface SparseSnapshot {\r\n    /** Frame number */\r\n    frame: number;\r\n\r\n    /** Sequence number (for network ordering) */\r\n    seq: number;\r\n\r\n    /** Bitmap: which entity indices are active */\r\n    entityMask: Uint32Array;\r\n\r\n    /** Entity metadata (type, clientId) indexed by position in packed arrays */\r\n    entityMeta: EntityMeta[];\r\n\r\n    /** Packed component data for each component type */\r\n    componentData: Map<string, ArrayBuffer>;\r\n\r\n    /** Entity count (for quick reference) */\r\n    entityCount: number;\r\n\r\n    /** Allocator state for deterministic ID recycling */\r\n    allocator: EntityIdAllocatorState;\r\n\r\n    /** String registry for late joiners */\r\n    strings: {\r\n        tables: Record<string, Record<string, number>>;\r\n        nextIds: Record<string, number>;\r\n    };\r\n\r\n    /** RNG state */\r\n    rng?: { s0: number; s1: number };\r\n}\r\n\r\n/**\r\n * Entity metadata stored per-entity in snapshot.\r\n */\r\nexport interface EntityMeta {\r\n    eid: number;\r\n    type: string;\r\n    clientId?: number;\r\n}\r\n\r\n/**\r\n * Sparse snapshot encoder/decoder.\r\n */\r\nexport class SparseSnapshotCodec {\r\n    /**\r\n     * Encode world state to sparse snapshot.\r\n     */\r\n    encode(\r\n        activeEids: number[],\r\n        getEntityType: (eid: number) => string,\r\n        getEntityClientId: (eid: number) => number | undefined,\r\n        getComponentsForEntity: (eid: number) => ComponentType[],\r\n        allocatorState: EntityIdAllocatorState,\r\n        stringsState: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> },\r\n        frame: number = 0,\r\n        seq: number = 0,\r\n        rng?: { s0: number; s1: number }\r\n    ): SparseSnapshot {\r\n        // Build entity bitmap\r\n        const entityMask = new Uint32Array(Math.ceil(MAX_ENTITIES / 32));\r\n        const entityMeta: EntityMeta[] = [];\r\n\r\n        // Sort eids for deterministic order\r\n        const sortedEids = [...activeEids].sort((a, b) => a - b);\r\n\r\n        for (const eid of sortedEids) {\r\n            const index = eid & INDEX_MASK;\r\n            entityMask[index >>> 5] |= (1 << (index & 31));\r\n\r\n            entityMeta.push({\r\n                eid,\r\n                type: getEntityType(eid),\r\n                clientId: getEntityClientId(eid)\r\n            });\r\n        }\r\n\r\n        // Pack component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const [name, component] of allComponents) {\r\n            // Skip components that are not synced (client-only state)\r\n            if (!component.sync) continue;\r\n\r\n            const fieldCount = component.fieldNames.length;\r\n            if (fieldCount === 0) continue;\r\n\r\n            // Calculate buffer size\r\n            let totalSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                totalSize += sortedEids.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const buffer = new ArrayBuffer(totalSize);\r\n            let offset = 0;\r\n\r\n            // Pack each field's data for active entities only\r\n            for (const fieldName of component.fieldNames) {\r\n                const sourceArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = sourceArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (sourceArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    sortedEids.length\r\n                );\r\n\r\n                // Copy only active entity data\r\n                for (let i = 0; i < sortedEids.length; i++) {\r\n                    const index = sortedEids[i] & INDEX_MASK;\r\n                    packedArr[i] = sourceArr[index];\r\n                }\r\n\r\n                offset += sortedEids.length * bytesPerElement;\r\n            }\r\n\r\n            componentData.set(name, buffer);\r\n        }\r\n\r\n        return {\r\n            frame,\r\n            seq,\r\n            entityMask,\r\n            entityMeta,\r\n            componentData,\r\n            entityCount: sortedEids.length,\r\n            allocator: allocatorState,\r\n            strings: stringsState,\r\n            rng\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decode sparse snapshot back to world state.\r\n     */\r\n    decode(\r\n        snapshot: SparseSnapshot,\r\n        clearWorld: () => void,\r\n        setAllocatorState: (state: EntityIdAllocatorState) => void,\r\n        setStringsState: (state: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> }) => void,\r\n        createEntity: (eid: number, type: string, clientId?: number) => void,\r\n        setRng?: (rng: { s0: number; s1: number }) => void\r\n    ): void {\r\n        // Clear existing state\r\n        clearWorld();\r\n\r\n        // Restore allocator state\r\n        setAllocatorState(snapshot.allocator);\r\n\r\n        // Restore strings\r\n        setStringsState(snapshot.strings);\r\n\r\n        // Restore RNG if provided\r\n        if (snapshot.rng && setRng) {\r\n            setRng(snapshot.rng);\r\n        }\r\n\r\n        // Get component types\r\n        const allComponents = getAllComponents();\r\n\r\n        // Unpack entities from metadata\r\n        for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n            const meta = snapshot.entityMeta[i];\r\n            createEntity(meta.eid, meta.type, meta.clientId);\r\n        }\r\n\r\n        // Unpack component data\r\n        for (const [name, buffer] of snapshot.componentData) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            let offset = 0;\r\n\r\n            for (const fieldName of component.fieldNames) {\r\n                const targetArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = targetArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (targetArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    snapshot.entityCount\r\n                );\r\n\r\n                // Unpack to entity indices\r\n                for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n                    const index = snapshot.entityMeta[i].eid & INDEX_MASK;\r\n                    targetArr[index] = packedArr[i];\r\n                }\r\n\r\n                offset += snapshot.entityCount * bytesPerElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate snapshot size in bytes.\r\n     */\r\n    getSize(snapshot: SparseSnapshot): number {\r\n        let size = 0;\r\n\r\n        // Entity mask\r\n        size += snapshot.entityMask.byteLength;\r\n\r\n        // Entity metadata (rough estimate)\r\n        size += snapshot.entityMeta.length * 32; // ~32 bytes per entity meta\r\n\r\n        // Component data\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            size += buffer.byteLength;\r\n        }\r\n\r\n        // Allocator state\r\n        size += snapshot.allocator.freeList.length * 4;\r\n        size += snapshot.allocator.generations.length * 2;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Serialize snapshot to binary for network transfer.\r\n     */\r\n    toBinary(snapshot: SparseSnapshot): ArrayBuffer {\r\n        // Calculate total size\r\n        const metaJson = JSON.stringify({\r\n            frame: snapshot.frame,\r\n            seq: snapshot.seq,\r\n            entityMeta: snapshot.entityMeta,\r\n            allocator: snapshot.allocator,\r\n            strings: snapshot.strings,\r\n            rng: snapshot.rng,\r\n            componentNames: Array.from(snapshot.componentData.keys())\r\n        });\r\n\r\n        const metaBytes = new TextEncoder().encode(metaJson);\r\n        const metaLength = metaBytes.length;\r\n\r\n        // Calculate component data size\r\n        let componentDataSize = 0;\r\n        const componentSizes: number[] = [];\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            componentSizes.push(buffer.byteLength);\r\n            componentDataSize += buffer.byteLength;\r\n        }\r\n\r\n        // Total: 4 (meta length) + meta + 4 (mask length) + mask + component data\r\n        const totalSize = 4 + metaLength + 4 + snapshot.entityMask.byteLength + componentDataSize;\r\n\r\n        const buffer = new ArrayBuffer(totalSize);\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Write meta length and data\r\n        view.setUint32(offset, metaLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, metaLength).set(metaBytes);\r\n        offset += metaLength;\r\n\r\n        // Write entity mask\r\n        view.setUint32(offset, snapshot.entityMask.byteLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, snapshot.entityMask.byteLength).set(\r\n            new Uint8Array(snapshot.entityMask.buffer)\r\n        );\r\n        offset += snapshot.entityMask.byteLength;\r\n\r\n        // Write component data\r\n        for (const compBuffer of snapshot.componentData.values()) {\r\n            new Uint8Array(buffer, offset, compBuffer.byteLength).set(\r\n                new Uint8Array(compBuffer)\r\n            );\r\n            offset += compBuffer.byteLength;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Deserialize snapshot from binary.\r\n     */\r\n    fromBinary(buffer: ArrayBuffer): SparseSnapshot {\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Read meta\r\n        const metaLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const metaBytes = new Uint8Array(buffer, offset, metaLength);\r\n        const metaJson = new TextDecoder().decode(metaBytes);\r\n        const meta = JSON.parse(metaJson);\r\n        offset += metaLength;\r\n\r\n        // Read entity mask\r\n        const maskLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const entityMask = new Uint32Array(\r\n            buffer.slice(offset, offset + maskLength)\r\n        );\r\n        offset += maskLength;\r\n\r\n        // Read component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const name of meta.componentNames) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            // Calculate size for this component\r\n            let compSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                compSize += meta.entityMeta.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const compBuffer = buffer.slice(offset, offset + compSize);\r\n            componentData.set(name, compBuffer);\r\n            offset += compSize;\r\n        }\r\n\r\n        return {\r\n            frame: meta.frame,\r\n            seq: meta.seq,\r\n            entityMask,\r\n            entityMeta: meta.entityMeta,\r\n            componentData,\r\n            entityCount: meta.entityMeta.length,\r\n            allocator: meta.allocator,\r\n            strings: meta.strings,\r\n            rng: meta.rng\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Rollback buffer - stores snapshots for rewinding state.\r\n */\r\nexport class RollbackBuffer {\r\n    private snapshots: Map<number, SparseSnapshot> = new Map();\r\n    private codec: SparseSnapshotCodec = new SparseSnapshotCodec();\r\n\r\n    constructor(private maxFrames: number = 60) {}\r\n\r\n    /**\r\n     * Save a snapshot for a frame.\r\n     */\r\n    save(frame: number, snapshot: SparseSnapshot): void {\r\n        this.snapshots.set(frame, snapshot);\r\n\r\n        // Prune old snapshots (keep exactly maxFrames snapshots)\r\n        const minFrame = frame - this.maxFrames + 1;\r\n        for (const f of this.snapshots.keys()) {\r\n            if (f < minFrame) {\r\n                this.snapshots.delete(f);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get snapshot for a frame.\r\n     */\r\n    get(frame: number): SparseSnapshot | undefined {\r\n        return this.snapshots.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Check if snapshot exists for frame.\r\n     */\r\n    has(frame: number): boolean {\r\n        return this.snapshots.has(frame);\r\n    }\r\n\r\n    /**\r\n     * Get oldest available frame.\r\n     */\r\n    getOldestFrame(): number | undefined {\r\n        let oldest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (oldest === undefined || frame < oldest) {\r\n                oldest = frame;\r\n            }\r\n        }\r\n        return oldest;\r\n    }\r\n\r\n    /**\r\n     * Get newest available frame.\r\n     */\r\n    getNewestFrame(): number | undefined {\r\n        let newest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (newest === undefined || frame > newest) {\r\n                newest = frame;\r\n            }\r\n        }\r\n        return newest;\r\n    }\r\n\r\n    /**\r\n     * Clear all snapshots.\r\n     */\r\n    clear(): void {\r\n        this.snapshots.clear();\r\n    }\r\n\r\n    /**\r\n     * Get number of stored snapshots.\r\n     */\r\n    get size(): number {\r\n        return this.snapshots.size;\r\n    }\r\n}\r\n", "/**\r\n * String Registry - Deterministic string interning\r\n *\r\n * Converts strings to integer IDs for efficient storage and comparison.\r\n * Used for entity types, colors, sprite IDs, etc.\r\n *\r\n * DETERMINISM: ID allocation order must be identical across all clients.\r\n * Strings are assigned IDs in order of first intern() call.\r\n */\r\n\r\nexport interface StringRegistryState {\r\n    tables: Record<string, Record<string, number>>;\r\n    nextIds: Record<string, number>;\r\n}\r\n\r\n/**\r\n * String registry for interning strings.\r\n *\r\n * Provides bidirectional mapping between strings and integer IDs,\r\n * organized by namespace (e.g., 'color', 'sprite', 'entityType').\r\n */\r\nexport class StringRegistry {\r\n    private stringToId: Map<string, Map<string, number>> = new Map();\r\n    private idToString: Map<string, Map<number, string>> = new Map();\r\n    private nextId: Map<string, number> = new Map();\r\n\r\n    /**\r\n     * Intern a string, get back an integer ID.\r\n     * If the string was already interned, returns the existing ID.\r\n     *\r\n     * @param namespace - Category for the string (e.g., 'color', 'sprite')\r\n     * @param str - The string to intern\r\n     * @returns Integer ID for the string\r\n     */\r\n    intern(namespace: string, str: string): number {\r\n        let nsMap = this.stringToId.get(namespace);\r\n        if (!nsMap) {\r\n            nsMap = new Map();\r\n            this.stringToId.set(namespace, nsMap);\r\n        }\r\n\r\n        const existing = nsMap.get(str);\r\n        if (existing !== undefined) return existing;\r\n\r\n        const id = this.nextId.get(namespace) ?? 1;\r\n        this.nextId.set(namespace, id + 1);\r\n\r\n        nsMap.set(str, id);\r\n\r\n        let idMap = this.idToString.get(namespace);\r\n        if (!idMap) {\r\n            idMap = new Map();\r\n            this.idToString.set(namespace, idMap);\r\n        }\r\n        idMap.set(id, str);\r\n\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Look up string by ID.\r\n     *\r\n     * @param namespace - Category for the string\r\n     * @param id - Integer ID to look up\r\n     * @returns The original string, or null if not found\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.idToString.get(namespace)?.get(id) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get state for snapshotting.\r\n     * Returns a serializable representation of all interned strings.\r\n     */\r\n    getState(): StringRegistryState {\r\n        const tables: Record<string, Record<string, number>> = {};\r\n        const nextIds: Record<string, number> = {};\r\n\r\n        for (const [ns, nsMap] of this.stringToId) {\r\n            tables[ns] = Object.fromEntries(nsMap);\r\n            nextIds[ns] = this.nextId.get(ns) ?? 1;\r\n        }\r\n\r\n        return { tables, nextIds };\r\n    }\r\n\r\n    /**\r\n     * Restore state from snapshot.\r\n     * Replaces all current data with the snapshot state.\r\n     */\r\n    setState(state: StringRegistryState): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n\r\n        for (const [ns, table] of Object.entries(state.tables)) {\r\n            const nsMap = new Map(Object.entries(table));\r\n            this.stringToId.set(ns, nsMap);\r\n\r\n            const idMap = new Map<number, string>();\r\n            for (const [str, id] of nsMap) {\r\n                idMap.set(id, str);\r\n            }\r\n            this.idToString.set(ns, idMap);\r\n\r\n            this.nextId.set(ns, state.nextIds[ns] ?? 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all data.\r\n     */\r\n    clear(): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n    }\r\n}\r\n", "/**\r\n * InputHistory - Stores confirmed server inputs for rollback resimulation\r\n *\r\n * This class is CRITICAL for determinism in rollback netcode. It stores all\r\n * inputs (both predictions and server-confirmed) so that resimulation can\r\n * replay the exact same sequence of inputs after a rollback.\r\n *\r\n * Key guarantees:\r\n * 1. Inputs are stored per-frame with deterministic iteration order (sorted by clientId)\r\n * 2. Server-confirmed inputs replace any local predictions\r\n * 3. Serialization produces bit-exact snapshots for late joiners\r\n * 4. Memory is bounded by maxFrames through pruning\r\n */\r\n\r\n/**\r\n * Input data for a single frame, containing all client inputs.\r\n */\r\nexport interface FrameInput {\r\n    /** The frame number */\r\n    frame: number;\r\n\r\n    /** Client inputs for this frame (clientId -> input data) */\r\n    inputs: Map<number, Record<string, any>>;\r\n\r\n    /** Whether this frame has been confirmed by the server */\r\n    confirmed: boolean;\r\n\r\n    /**\r\n     * Get inputs in deterministic (sorted) order for resimulation.\r\n     * CRITICAL: Iteration order must be identical across all clients.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]>;\r\n}\r\n\r\n/**\r\n * Internal FrameInput implementation.\r\n */\r\nclass FrameInputImpl implements FrameInput {\r\n    frame: number;\r\n    inputs: Map<number, Record<string, any>>;\r\n    confirmed: boolean;\r\n\r\n    constructor(frame: number) {\r\n        this.frame = frame;\r\n        this.inputs = new Map();\r\n        this.confirmed = false;\r\n    }\r\n\r\n    /**\r\n     * Get inputs sorted by clientId for deterministic iteration.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]> {\r\n        const entries = Array.from(this.inputs.entries());\r\n        // Sort by clientId (numeric) for determinism\r\n        entries.sort((a, b) => a[0] - b[0]);\r\n        return entries;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialized state for snapshots.\r\n */\r\nexport interface InputHistoryState {\r\n    frames: Array<{\r\n        frame: number;\r\n        inputs: Array<{ clientId: number; data: Record<string, any> }>;\r\n        confirmed: boolean;\r\n    }>;\r\n}\r\n\r\n/**\r\n * InputHistory stores inputs for resimulation during rollback.\r\n */\r\nexport class InputHistory {\r\n    /** Stored frames: frame number -> FrameInput */\r\n    private history: Map<number, FrameInputImpl> = new Map();\r\n\r\n    /** Maximum frames to keep (for memory management) */\r\n    private maxFrames: number;\r\n\r\n    /**\r\n     * Create InputHistory with optional max frame limit.\r\n     * @param maxFrames Maximum frames to keep (default 120)\r\n     */\r\n    constructor(maxFrames: number = 120) {\r\n        this.maxFrames = maxFrames;\r\n    }\r\n\r\n    /**\r\n     * Store input for a frame from a client.\r\n     * Used for local predictions before server confirmation.\r\n     *\r\n     * @param frame Frame number\r\n     * @param clientId Client ID (numeric)\r\n     * @param input Input data\r\n     */\r\n    setInput(frame: number, clientId: number, input: Record<string, any>): void {\r\n        let frameInput = this.history.get(frame);\r\n\r\n        if (!frameInput) {\r\n            frameInput = new FrameInputImpl(frame);\r\n            this.history.set(frame, frameInput);\r\n        }\r\n\r\n        frameInput.inputs.set(clientId, input);\r\n    }\r\n\r\n    /**\r\n     * Mark a frame as server-confirmed with authoritative inputs.\r\n     * This replaces any local predictions with server-provided data.\r\n     *\r\n     * @param frame Frame number\r\n     * @param inputs Map of clientId -> input data from server\r\n     */\r\n    confirmFrame(frame: number, inputs: Map<number, Record<string, any>>): void {\r\n        // Create new frame or replace existing\r\n        const frameInput = new FrameInputImpl(frame);\r\n        frameInput.confirmed = true;\r\n\r\n        // Copy all server inputs\r\n        for (const [clientId, data] of inputs) {\r\n            frameInput.inputs.set(clientId, data);\r\n        }\r\n\r\n        this.history.set(frame, frameInput);\r\n    }\r\n\r\n    /**\r\n     * Get input data for a specific frame.\r\n     *\r\n     * @param frame Frame number\r\n     * @returns FrameInput or undefined if not found\r\n     */\r\n    getFrame(frame: number): FrameInput | undefined {\r\n        return this.history.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Get ordered frames for resimulation.\r\n     * Returns frames in ascending order, skipping any missing frames.\r\n     *\r\n     * CRITICAL: Order must be deterministic for rollback to work.\r\n     *\r\n     * @param fromFrame Start frame (inclusive)\r\n     * @param toFrame End frame (inclusive)\r\n     * @returns Array of FrameInput in ascending frame order\r\n     */\r\n    getRange(fromFrame: number, toFrame: number): FrameInput[] {\r\n        if (fromFrame > toFrame) {\r\n            return [];\r\n        }\r\n\r\n        const result: FrameInputImpl[] = [];\r\n\r\n        // Collect all frames in range\r\n        for (const [frame, frameInput] of this.history) {\r\n            if (frame >= fromFrame && frame <= toFrame) {\r\n                result.push(frameInput);\r\n            }\r\n        }\r\n\r\n        // Sort by frame number for deterministic order\r\n        result.sort((a, b) => a.frame - b.frame);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Remove frames before the specified frame number.\r\n     * Called to limit memory usage.\r\n     *\r\n     * @param beforeFrame Remove all frames with frame < beforeFrame\r\n     */\r\n    prune(beforeFrame: number): void {\r\n        // Collect frames to remove (avoid modifying during iteration)\r\n        const toRemove: number[] = [];\r\n\r\n        for (const frame of this.history.keys()) {\r\n            if (frame < beforeFrame) {\r\n                toRemove.push(frame);\r\n            }\r\n        }\r\n\r\n        // Remove collected frames\r\n        for (const frame of toRemove) {\r\n            this.history.delete(frame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize for snapshots (late joiner sync).\r\n     * CRITICAL: Must produce identical output across all clients.\r\n     *\r\n     * @returns Serializable state object\r\n     */\r\n    getState(): InputHistoryState {\r\n        const frames: InputHistoryState['frames'] = [];\r\n\r\n        // Sort frames by frame number for deterministic serialization\r\n        const sortedFrames = Array.from(this.history.entries())\r\n            .sort((a, b) => a[0] - b[0]);\r\n\r\n        for (const [, frameInput] of sortedFrames) {\r\n            // Sort inputs by clientId for deterministic serialization\r\n            const sortedInputs = frameInput.getSortedInputs().map(([clientId, data]) => ({\r\n                clientId,\r\n                data\r\n            }));\r\n\r\n            frames.push({\r\n                frame: frameInput.frame,\r\n                inputs: sortedInputs,\r\n                confirmed: frameInput.confirmed\r\n            });\r\n        }\r\n\r\n        return { frames };\r\n    }\r\n\r\n    /**\r\n     * Restore from serialized state (for late joiner sync).\r\n     * Clears existing data before restoring.\r\n     *\r\n     * @param state Previously serialized state\r\n     */\r\n    setState(state: InputHistoryState): void {\r\n        // Clear existing data\r\n        this.history.clear();\r\n\r\n        // Restore frames\r\n        for (const frameData of state.frames) {\r\n            const frameInput = new FrameInputImpl(frameData.frame);\r\n            frameInput.confirmed = frameData.confirmed;\r\n\r\n            for (const { clientId, data } of frameData.inputs) {\r\n                frameInput.inputs.set(clientId, data);\r\n            }\r\n\r\n            this.history.set(frameData.frame, frameInput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the number of frames currently stored.\r\n     * Useful for debugging and monitoring memory usage.\r\n     */\r\n    get size(): number {\r\n        return this.history.size;\r\n    }\r\n\r\n    /**\r\n     * Clear all stored history.\r\n     */\r\n    clear(): void {\r\n        this.history.clear();\r\n    }\r\n}\r\n", "/**\n * ECS World\n *\n * Main entry point for the ECS system. Manages:\n * - Entity definitions and spawning\n * - Component management\n * - Query engine\n * - System scheduler\n * - String interning\n */\n\nimport { EntityIdAllocator, EntityIdAllocatorState } from './entity-id';\nimport { SparseSnapshot, SparseSnapshotCodec } from './snapshot';\nimport {\n    ComponentType,\n    defineComponent as defineComponentInternal,\n    hasComponent,\n    addComponentToEntity,\n    initializeComponentDefaults,\n    removeComponentFromEntity,\n    clearComponentRegistry,\n    getAllComponents\n} from './component';\nimport { QueryEngine, QueryIterator } from './query';\nimport { SystemScheduler, SystemFn, SystemOptions } from './system';\nimport { Entity, EntityPool, EntityDefinition, RenderState } from './entity';\nimport { INDEX_MASK } from './constants';\nimport { toFixed, saveRandomState, loadRandomState } from '../math';\nimport { StringRegistry } from './string-registry';\nimport { InputHistory } from './input-history';\n\n/**\n * Entity definition builder.\n */\nexport class EntityBuilder {\n    private components: Array<{\n        type: ComponentType;\n        defaults?: Record<string, any>;\n    }> = [];\n\n    private registered: boolean = false;\n    private _syncFields?: string[];\n    private _onRestore?: (entity: Entity, game: any) => void;\n\n    constructor(\n        private world: World,\n        private name: string\n    ) {}\n\n    /**\n     * Add a component to this entity definition.\n     */\n    with<T extends Record<string, any>>(\n        component: ComponentType<T>,\n        defaults?: Partial<T>\n    ): EntityBuilder {\n        this.components.push({\n            type: component,\n            defaults: defaults as Record<string, any>\n        });\n\n        // Register immediately (idempotent - just overwrites with latest)\n        this.register();\n\n        return this;\n    }\n\n    /**\n     * Set sync fields for this entity (internal - use GameEntityBuilder.syncOnly()).\n     */\n    _setSyncFields(fields: string[]): void {\n        this._syncFields = fields;\n    }\n\n    /**\n     * Set restore callback for this entity (internal - use GameEntityBuilder.onRestore()).\n     */\n    _setOnRestore(callback: (entity: Entity, game: any) => void): void {\n        this._onRestore = callback;\n    }\n\n    /**\n     * Finalize entity definition.\n     */\n    private register(): void {\n        this.world._registerEntityDef({\n            name: this.name,\n            components: this.components,\n            syncFields: this._syncFields,\n            onRestore: this._onRestore\n        });\n    }\n\n    /**\n     * Force immediate registration (for sync usage).\n     */\n    _ensureRegistered(): void {\n        if (!this.registered) {\n            this.registered = true;\n        }\n        this.register();\n    }\n\n    /**\n     * Get the entity definition (for internal use).\n     */\n    _getDefinition(): EntityDefinition {\n        return {\n            name: this.name,\n            components: this.components,\n            syncFields: this._syncFields,\n            onRestore: this._onRestore\n        };\n    }\n}\n\n/**\n * ECS World - main container for all ECS state.\n */\nexport class World {\n    /** Entity ID allocator */\n    readonly idAllocator: EntityIdAllocator;\n\n    /** Query engine */\n    readonly queryEngine: QueryEngine;\n\n    /** System scheduler */\n    readonly scheduler: SystemScheduler;\n\n    /** Entity pool */\n    readonly entityPool: EntityPool;\n\n    /** String registry */\n    readonly strings: StringRegistry;\n\n    /** Entity definitions */\n    private entityDefs: Map<string, EntityDefinition> = new Map();\n\n    /** Active entity eids */\n    private activeEntities: Set<number> = new Set();\n\n    /** Entity type by eid */\n    private entityTypes: Map<number, string> = new Map();\n\n    /** Entity components by eid */\n    private entityComponents: Map<number, ComponentType[]> = new Map();\n\n    /** Client ID by eid */\n    private entityClientIds: Map<number, number> = new Map();\n\n    /** Input registry: clientId \u2192 input data */\n    private inputRegistry: Map<number, any> = new Map();\n\n    /** Whether running on client */\n    private _isClient: boolean = true;\n\n    constructor() {\n        this.idAllocator = new EntityIdAllocator();\n        this.entityPool = new EntityPool();\n        this.strings = new StringRegistry();\n\n        // Create query engine with callbacks\n        this.queryEngine = new QueryEngine(\n            (eid) => this.getEntity(eid),\n            (eid) => this.isDestroyed(eid)\n        );\n\n        this.scheduler = new SystemScheduler();\n\n        // Register interpolation state saving in prePhysics phase\n        this.addSystem(() => this.saveInterpolationState(), { phase: 'prePhysics', order: -1000 });\n    }\n\n    /**\n     * Set whether running on client.\n     */\n    setIsClient(isClient: boolean): void {\n        this._isClient = isClient;\n        this.scheduler.setIsClient(isClient);\n    }\n\n    /**\n     * Check if running on client.\n     */\n    get isClient(): boolean {\n        return this._isClient;\n    }\n\n    // ==========================================\n    // Component API\n    // ==========================================\n\n    /**\n     * Define a new component type.\n     */\n    defineComponent<T extends Record<string, any>>(\n        name: string,\n        defaults: T\n    ): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\n        return defineComponentInternal(name, defaults);\n    }\n\n    // ==========================================\n    // Entity Definition API\n    // ==========================================\n\n    /**\n     * Define a new entity type.\n     */\n    defineEntity(name: string): EntityBuilder {\n        const builder = new EntityBuilder(this, name);\n        // Auto-register when builder methods are done\n        // We need to defer this, so we'll register on first spawn or explicitly\n        return builder;\n    }\n\n    /**\n     * Register an entity definition (internal).\n     */\n    _registerEntityDef(def: EntityDefinition): void {\n        this.entityDefs.set(def.name, def);\n    }\n\n    /**\n     * Get entity definition by type name.\n     */\n    getEntityDef(typeName: string): EntityDefinition | undefined {\n        return this.entityDefs.get(typeName);\n    }\n\n    // ==========================================\n    // Entity Spawning/Destruction\n    // ==========================================\n\n    /**\n     * Spawn a new entity.\n     */\n    spawn(\n        typeOrBuilder: string | EntityBuilder,\n        props: Record<string, any> = {}\n    ): Entity {\n        // Handle EntityBuilder\n        let typeName: string;\n        if (typeof typeOrBuilder === 'string') {\n            typeName = typeOrBuilder;\n        } else {\n            const def = typeOrBuilder._getDefinition();\n            this._registerEntityDef(def);\n            typeName = def.name;\n        }\n\n        // Get entity definition\n        const def = this.entityDefs.get(typeName);\n        if (!def) {\n            throw new Error(`Unknown entity type: '${typeName}'`);\n        }\n\n        // Allocate entity ID\n        const eid = this.idAllocator.allocate();\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, typeName);\n\n        // Initialize components\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n\n            // Add to storage\n            addComponentToEntity(component.storage, index);\n            initializeComponentDefaults(component.storage, index);\n\n            // Apply definition defaults\n            if (compDef.defaults) {\n                for (const [key, value] of Object.entries(compDef.defaults)) {\n                    const arr = component.storage.fields[key];\n                    if (arr) {\n                        const fieldDef = component.storage.schema[key];\n                        if (fieldDef.type === 'i32') {\n                            arr[index] = toFixed(value as number);\n                        } else if (fieldDef.type === 'bool') {\n                            arr[index] = value ? 1 : 0;\n                        } else {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Apply spawn props (route to components)\n        let clientId: number | undefined;\n        for (const [key, value] of Object.entries(props)) {\n            if (key === 'clientId') {\n                clientId = value as number;\n                this.entityClientIds.set(eid, clientId);\n            }\n\n            // Route to first component that has this field\n            for (const component of componentTypes) {\n                if (key in component.storage.schema) {\n                    const arr = component.storage.fields[key];\n                    const fieldDef = component.storage.schema[key];\n                    if (fieldDef.type === 'i32') {\n                        arr[index] = toFixed(value as number);\n                    } else if (fieldDef.type === 'bool') {\n                        arr[index] = value ? 1 : 0;\n                    } else {\n                        arr[index] = value;\n                    }\n                    break; // Route to first matching component\n                }\n            }\n        }\n\n        // Store components\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, typeName, componentTypes, this);\n\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\n        // Use raw props values (before fixed-point conversion) for render coordinates\n        if (props.x !== undefined || props.y !== undefined) {\n            const spawnX = props.x ?? 0;\n            const spawnY = props.y ?? 0;\n            entity.render.prevX = spawnX;\n            entity.render.prevY = spawnY;\n            entity.render.interpX = spawnX;\n            entity.render.interpY = spawnY;\n        }\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\n\n        return entity;\n    }\n\n    /**\n     * Spawn an entity with a specific eid (for snapshot restore).\n     * This is used when restoring entities to preserve their original IDs.\n     */\n    spawnWithId(typeOrBuilder: string | EntityBuilder, targetEid: number, props: Record<string, any> = {}): Entity {\n        let typeName: string;\n        if (typeof typeOrBuilder === 'string') {\n            typeName = typeOrBuilder;\n        } else {\n            const def = typeOrBuilder._getDefinition();\n            this._registerEntityDef(def);\n            typeName = def.name;\n        }\n\n        // Get entity definition\n        const def = this.entityDefs.get(typeName);\n        if (!def) {\n            throw new Error(`Unknown entity type: '${typeName}'`);\n        }\n\n        // Allocate specific entity ID\n        const eid = this.idAllocator.allocateSpecific(targetEid);\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, typeName);\n\n        // Initialize components\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n\n            // Add to storage\n            addComponentToEntity(component.storage, index);\n            initializeComponentDefaults(component.storage, index);\n\n            // Apply definition defaults\n            if (compDef.defaults) {\n                for (const [key, value] of Object.entries(compDef.defaults)) {\n                    const arr = component.storage.fields[key];\n                    if (arr) {\n                        const fieldDef = component.storage.schema[key];\n                        if (fieldDef.type === 'i32') {\n                            arr[index] = toFixed(value as number);\n                        } else if (fieldDef.type === 'bool') {\n                            arr[index] = value ? 1 : 0;\n                        } else {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Apply spawn props (route to components)\n        let clientId: number | undefined;\n        for (const [key, value] of Object.entries(props)) {\n            if (key === 'clientId') {\n                clientId = value as number;\n                this.entityClientIds.set(eid, clientId);\n            }\n\n            // Route to first component that has this field\n            for (const compDef of def.components) {\n                const arr = compDef.type.storage.fields[key];\n                if (arr) {\n                    const fieldDef = compDef.type.storage.schema[key];\n                    if (fieldDef.type === 'i32') {\n                        arr[index] = toFixed(value as number);\n                    } else if (fieldDef.type === 'bool') {\n                        arr[index] = value ? 1 : 0;\n                    } else {\n                        arr[index] = value;\n                    }\n                    break; // Route to first matching component\n                }\n            }\n        }\n\n        // Store components\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, typeName, componentTypes, this);\n\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\n        // Use raw props values (before fixed-point conversion) for render coordinates\n        if (props.x !== undefined || props.y !== undefined) {\n            const spawnX = props.x ?? 0;\n            const spawnY = props.y ?? 0;\n            entity.render.prevX = spawnX;\n            entity.render.prevY = spawnY;\n            entity.render.interpX = spawnX;\n            entity.render.interpY = spawnY;\n        }\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\n\n        return entity;\n    }\n\n    /**\n     * Destroy an entity.\n     */\n    destroyEntity(entity: Entity): void {\n        const eid = entity.eid;\n\n        if (!this.activeEntities.has(eid)) {\n            return; // Already destroyed\n        }\n\n        const typeName = this.entityTypes.get(eid) || '';\n        const components = this.entityComponents.get(eid) || [];\n        const clientId = this.entityClientIds.get(eid);\n        const index = eid & INDEX_MASK;\n\n        // Remove from component storage\n        for (const component of components) {\n            removeComponentFromEntity(component.storage, index);\n        }\n\n        // Remove from query engine\n        this.queryEngine.removeEntity(eid, typeName, components, clientId);\n\n        // Clean up tracking\n        this.activeEntities.delete(eid);\n        this.entityTypes.delete(eid);\n        this.entityComponents.delete(eid);\n        this.entityClientIds.delete(eid);\n\n        // Return entity wrapper to pool\n        this.entityPool.release(eid);\n\n        // Free entity ID\n        this.idAllocator.free(eid);\n    }\n\n    /**\n     * Get entity by eid.\n     */\n    getEntity(eid: number): Entity | null {\n        if (!this.activeEntities.has(eid)) {\n            return null;\n        }\n\n        const entity = this.entityPool.get(eid);\n        if (entity && !entity.destroyed) {\n            return entity;\n        }\n\n        return null;\n    }\n\n    /**\n     * Check if entity is destroyed.\n     */\n    isDestroyed(eid: number): boolean {\n        return !this.activeEntities.has(eid);\n    }\n\n    /**\n     * Get entity by clientId (O(1) lookup).\n     */\n    getEntityByClientId(clientId: number): Entity | null {\n        const eid = this.queryEngine.getByClientId(clientId);\n        if (eid === undefined) return null;\n        return this.getEntity(eid);\n    }\n\n    /**\n     * Set clientId for an entity (for snapshot restore).\n     * Updates both entityClientIds map and queryEngine index.\n     */\n    setEntityClientId(eid: number, clientId: number): void {\n        this.entityClientIds.set(eid, clientId);\n        this.queryEngine.setClientId(eid, clientId);\n    }\n\n    // ==========================================\n    // Query API\n    // ==========================================\n\n    /**\n     * Query entities by type or component.\n     */\n    query(\n        typeOrComponent: string | ComponentType,\n        ...moreComponents: ComponentType[]\n    ): QueryIterator<Entity> {\n        return this.queryEngine.query(typeOrComponent, ...moreComponents);\n    }\n\n    /**\n     * Get all active entities.\n     */\n    getAllEntities(): Entity[] {\n        const result: Entity[] = [];\n        // Sort eids for determinism\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\n        for (const eid of sortedEids) {\n            const entity = this.entityPool.get(eid);\n            if (entity) {\n                result.push(entity);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get all active entity IDs.\n     */\n    getAllEntityIds(): number[] {\n        return Array.from(this.activeEntities).sort((a, b) => a - b);\n    }\n\n    // ==========================================\n    // System API\n    // ==========================================\n\n    /**\n     * Add a system.\n     */\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\n        return this.scheduler.add(fn, options);\n    }\n\n    /**\n     * Run all systems.\n     */\n    runSystems(): void {\n        this.scheduler.runAll();\n    }\n\n    // ==========================================\n    // String Interning API\n    // ==========================================\n\n    /**\n     * Intern a string, get back an integer ID.\n     */\n    internString(namespace: string, str: string): number {\n        return this.strings.intern(namespace, str);\n    }\n\n    /**\n     * Look up string by ID.\n     */\n    getString(namespace: string, id: number): string | null {\n        return this.strings.getString(namespace, id);\n    }\n\n    // ==========================================\n    // Input Registry\n    // ==========================================\n\n    /**\n     * Set input data for a client.\n     */\n    setInput(clientId: number, data: any): void {\n        this.inputRegistry.set(clientId, data);\n        // Also set on entity if it exists\n        const entity = this.getEntityByClientId(clientId);\n        if (entity) {\n            entity._setInputData(data);\n        }\n    }\n\n    /**\n     * Get input data for a client.\n     */\n    getInput(clientId: number): any {\n        return this.inputRegistry.get(clientId);\n    }\n\n    /**\n     * Clear all input data (call at end of tick).\n     */\n    clearInputs(): void {\n        this.inputRegistry.clear();\n    }\n\n    /**\n     * Get input state for snapshot.\n     * Returns a map of clientId -> input data.\n     */\n    getInputState(): Record<number, any> {\n        const state: Record<number, any> = {};\n        for (const [clientId, data] of this.inputRegistry) {\n            state[clientId] = data;\n        }\n        return state;\n    }\n\n    /**\n     * Set input state from snapshot.\n     * Restores the input registry and entity input caches.\n     */\n    setInputState(state: Record<number, any>): void {\n        this.inputRegistry.clear();\n        for (const [clientIdStr, data] of Object.entries(state)) {\n            const clientId = parseInt(clientIdStr, 10);\n            this.inputRegistry.set(clientId, data);\n            // Also set on entity if it exists\n            const entity = this.getEntityByClientId(clientId);\n            if (entity) {\n                entity._setInputData(data);\n            }\n        }\n    }\n\n\n    // ==========================================\n    // State Management\n    // ==========================================\n\n    /**\n     * Get full world state for snapshotting.\n     */\n    getState(): WorldState {\n        const entities: EntityState[] = [];\n\n        for (const eid of this.activeEntities) {\n            const typeName = this.entityTypes.get(eid)!;\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            const componentData: Record<string, Record<string, number>> = {};\n\n            for (const component of components) {\n                const data: Record<string, number> = {};\n                for (const [fieldName, arr] of Object.entries(component.storage.fields)) {\n                    data[fieldName] = arr[index];\n                }\n                componentData[component.name] = data;\n            }\n\n            entities.push({\n                eid,\n                type: typeName,\n                components: componentData,\n                clientId: this.entityClientIds.get(eid)\n            });\n        }\n\n        return {\n            entities,\n            allocator: this.idAllocator.getState(),\n            strings: this.strings.getState()\n        };\n    }\n\n    /**\n     * Restore world state from snapshot.\n     */\n    setState(state: WorldState): void {\n        // Clear current state\n        this.clear();\n\n        // Restore allocator\n        this.idAllocator.setState(state.allocator);\n\n        // Restore strings\n        this.strings.setState(state.strings);\n\n        // Restore entities\n        for (const entityState of state.entities) {\n            const def = this.entityDefs.get(entityState.type);\n            if (!def) {\n                console.warn(`Unknown entity type in snapshot: ${entityState.type}`);\n                continue;\n            }\n\n            const eid = entityState.eid;\n            const index = eid & INDEX_MASK;\n\n            // Get entity wrapper\n            const entity = this.entityPool.acquire(eid);\n\n            // Track entity\n            this.activeEntities.add(eid);\n            this.entityTypes.set(eid, entityState.type);\n\n            if (entityState.clientId !== undefined) {\n                this.entityClientIds.set(eid, entityState.clientId);\n            }\n\n            // Restore components\n            const componentTypes: ComponentType[] = [];\n            for (const compDef of def.components) {\n                const component = compDef.type;\n                componentTypes.push(component);\n\n                addComponentToEntity(component.storage, index);\n\n                // Restore component data\n                const savedData = entityState.components[component.name];\n                if (savedData) {\n                    for (const [fieldName, value] of Object.entries(savedData)) {\n                        const arr = component.storage.fields[fieldName];\n                        if (arr) {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n\n            this.entityComponents.set(eid, componentTypes);\n\n            // Initialize entity wrapper\n            entity._init(eid, entityState.type, componentTypes, this);\n\n            // Register in query engine\n            this.queryEngine.addEntity(eid, entityState.type, componentTypes, entityState.clientId);\n        }\n    }\n\n    /**\n     * Clear all world state.\n     */\n    clear(): void {\n        // Release all entities\n        for (const eid of this.activeEntities) {\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            for (const component of components) {\n                removeComponentFromEntity(component.storage, index);\n            }\n\n            this.entityPool.release(eid);\n        }\n\n        // Clear tracking\n        this.activeEntities.clear();\n        this.entityTypes.clear();\n        this.entityComponents.clear();\n        this.entityClientIds.clear();\n\n        // Clear indices\n        this.queryEngine.clear();\n\n        // Reset allocator\n        this.idAllocator.reset();\n\n        // Clear strings\n        this.strings.clear();\n    }\n\n    /**\n     * Reset world (keeps definitions, clears entities).\n     */\n    reset(): void {\n        this.clear();\n    }\n\n    /**\n     * Get entity count.\n     */\n    get entityCount(): number {\n        return this.activeEntities.size;\n    }\n\n    // ==========================================\n    // Sparse Snapshot API (Efficient)\n    // ==========================================\n\n    /** Snapshot codec */\n    private snapshotCodec: SparseSnapshotCodec = new SparseSnapshotCodec();\n\n    /** Current frame number */\n    frame: number = 0;\n\n    /** Current sequence number */\n    seq: number = 0;\n\n    /** RNG state (for determinism) - deprecated, now uses global random state */\n    rngState?: { s0: number; s1: number };\n\n    /**\n     * Get sparse snapshot (efficient format).\n     */\n    getSparseSnapshot(): SparseSnapshot {\n        return this.snapshotCodec.encode(\n            Array.from(this.activeEntities),\n            (eid) => this.entityTypes.get(eid) || '',\n            (eid) => this.entityClientIds.get(eid),\n            (eid) => this.entityComponents.get(eid) || [],\n            this.idAllocator.getState(),\n            this.strings.getState(),\n            this.frame,\n            this.seq,\n            saveRandomState() // CRITICAL: Save actual RNG state for deterministic rollback\n        );\n    }\n\n    /**\n     * Load sparse snapshot (efficient format).\n     */\n    loadSparseSnapshot(snapshot: SparseSnapshot): void {\n        this.snapshotCodec.decode(\n            snapshot,\n            () => this.clearForSnapshot(),\n            (state) => this.idAllocator.setState(state),\n            (state) => this.strings.setState(state),\n            (eid, type, clientId) => this.createEntityFromSnapshot(eid, type, clientId),\n            (rng) => {\n                // CRITICAL: Actually restore the global RNG state for deterministic rollback\n                if (rng) {\n                    loadRandomState(rng);\n                }\n            }\n        );\n\n        this.frame = snapshot.frame;\n        this.seq = snapshot.seq;\n\n        // Sync render state with restored transform positions\n        this.syncRenderStateFromTransforms();\n    }\n\n    /**\n     * Sync render state with current transform positions.\n     * Called after snapshot restore to prevent interpolation artifacts.\n     */\n    private syncRenderStateFromTransforms(): void {\n        for (const eid of this.activeEntities) {\n            const entity = this.getEntity(eid);\n            if (!entity) continue;\n\n            // Find Transform2D component and read x,y values\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            for (const component of components) {\n                if (component.name === 'Transform2D') {\n                    const xArr = component.storage.fields['x'];\n                    const yArr = component.storage.fields['y'];\n                    if (xArr && yArr) {\n                        // Convert from fixed-point to float for render\n                        const x = xArr[index] / 65536;\n                        const y = yArr[index] / 65536;\n                        entity.render.prevX = x;\n                        entity.render.prevY = y;\n                        entity.render.interpX = x;\n                        entity.render.interpY = y;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear world for snapshot restore (doesn't reset allocator).\n     */\n    private clearForSnapshot(): void {\n        // Release all entities\n        for (const eid of this.activeEntities) {\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            for (const component of components) {\n                removeComponentFromEntity(component.storage, index);\n            }\n\n            this.entityPool.release(eid);\n        }\n\n        // Clear tracking\n        this.activeEntities.clear();\n        this.entityTypes.clear();\n        this.entityComponents.clear();\n        this.entityClientIds.clear();\n\n        // Clear query indices\n        this.queryEngine.clear();\n    }\n\n    /**\n     * Create entity from snapshot data (without allocating new ID).\n     */\n    private createEntityFromSnapshot(eid: number, type: string, clientId?: number): void {\n        const def = this.entityDefs.get(type);\n        if (!def) {\n            console.warn(`Unknown entity type in snapshot: ${type}`);\n            return;\n        }\n\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, type);\n\n        if (clientId !== undefined) {\n            this.entityClientIds.set(eid, clientId);\n        }\n\n        // Setup components (data will be restored by codec)\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n            addComponentToEntity(component.storage, index);\n        }\n\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, type, componentTypes, this);\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, type, componentTypes, clientId);\n    }\n\n    /**\n     * Serialize snapshot to binary for network transfer.\n     */\n    snapshotToBinary(snapshot: SparseSnapshot): ArrayBuffer {\n        return this.snapshotCodec.toBinary(snapshot);\n    }\n\n    /**\n     * Deserialize snapshot from binary.\n     */\n    snapshotFromBinary(buffer: ArrayBuffer): SparseSnapshot {\n        return this.snapshotCodec.fromBinary(buffer);\n    }\n\n    /**\n     * Get snapshot size estimate.\n     */\n    getSnapshotSize(snapshot: SparseSnapshot): number {\n        return this.snapshotCodec.getSize(snapshot);\n    }\n\n    // ==========================================\n    // Network Integration (Phase 3)\n    // ==========================================\n\n    /**\n     * Network input format.\n     */\n    private inputBuffer: Map<number, Record<string, any>> = new Map();\n\n    /**\n     * Run a single game tick with network inputs.\n     *\n     * Executes all system phases in order:\n     * 1. INPUT - Apply network inputs to entities\n     * 2. UPDATE - Game logic systems\n     * 3. PREPHYSICS - Save state for interpolation\n     * 4. PHYSICS - Physics simulation (external hook)\n     * 5. POSTPHYSICS - Post-physics cleanup\n     * 6. RENDER - Rendering (client only)\n     */\n    /** True while running deterministic simulation phases */\n    _isSimulating: boolean = false;\n\n    tick(frame: number, inputs: NetworkInput[] = []): void {\n        this.frame = frame;\n\n        // Apply network inputs (O(1) per input via clientIdIndex)\n        this.applyNetworkInputs(inputs);\n\n        // Run deterministic simulation phases\n        this._isSimulating = true;\n        try {\n            this.scheduler.runPhase('input');\n            this.scheduler.runPhase('update');\n            this.scheduler.runPhase('prePhysics');\n            this.scheduler.runPhase('physics');\n            this.scheduler.runPhase('postPhysics');\n        } finally {\n            this._isSimulating = false;\n        }\n\n        // Render phase only runs on client (not deterministic)\n        if (this._isClient) {\n            this.scheduler.runPhase('render');\n        }\n\n        // Clear input buffer after tick\n        this.inputBuffer.clear();\n    }\n\n    /**\n     * Apply network inputs to entities via O(1) clientId lookup.\n     */\n    private applyNetworkInputs(inputs: NetworkInput[]): void {\n        for (const input of inputs) {\n            // O(1) lookup via clientIdIndex\n            const entity = this.getEntityByClientId(input.clientId);\n\n            if (entity) {\n                // Store input data for systems to read\n                this.inputBuffer.set(input.clientId, input.data);\n\n                // Apply input to entity's render state for interpolation reference\n                const data = input.data;\n                if (data) {\n                    // Store in entity's input cache for system access\n                    entity._setInputData(data);\n                }\n            }\n            // If no entity for this clientId, silently ignore (disconnected player)\n        }\n    }\n\n    /**\n     * Get input data for a clientId.\n     */\n    getInputForClient(clientId: number): Record<string, any> | undefined {\n        return this.inputBuffer.get(clientId);\n    }\n\n    /**\n     * Check if we have input for a clientId this tick.\n     */\n    hasInputForClient(clientId: number): boolean {\n        return this.inputBuffer.has(clientId);\n    }\n\n    /**\n     * Run only physics phase (for external physics integration).\n     */\n    runPhysics(): void {\n        this.scheduler.runPhase('physics');\n    }\n\n    /**\n     * Set physics step callback (called during PHYSICS phase).\n     */\n    setPhysicsStep(fn: () => void): () => void {\n        return this.addSystem(fn, { phase: 'physics', order: 0 });\n    }\n\n    /**\n     * Save previous positions for interpolation (called in prePhysics).\n     */\n    saveInterpolationState(): void {\n        for (const eid of this.activeEntities) {\n            const entity = this.getEntity(eid);\n            if (entity) {\n                entity._savePreviousState();\n            }\n        }\n    }\n\n    // ==========================================\n    // Client-Side Prediction (Phase 4)\n    // ==========================================\n\n    /** Local client ID for prediction */\n    localClientId: number | null = null;\n\n    /** Pending predictions awaiting server confirmation */\n    private predictions: PredictionEntry[] = [];\n\n    /** Rollback buffer for state restoration */\n    private rollbackBuffer: Map<number, SparseSnapshot> = new Map();\n\n    /** Maximum frames to keep in rollback buffer */\n    rollbackBufferSize: number = 60;\n\n    /** Callback for when rollback occurs */\n    onRollback?: (toFrame: number) => void;\n\n    /** Input history for rollback resimulation */\n    private inputHistory: InputHistory = new InputHistory(120);\n\n    /**\n     * Handle local player input (client-side prediction).\n     * Applies input immediately for responsiveness.\n     */\n    handleLocalInput(input: Record<string, any>): void {\n        if (this.localClientId === null) {\n            console.error('[modu] Cannot handle local input: localClientId not set. Ensure game.connect() completed before processing input.');\n            return;\n        }\n\n        // Apply input immediately (prediction)\n        const entity = this.getEntityByClientId(this.localClientId);\n        if (entity) {\n            entity._setInputData(input);\n        }\n\n        // Also store in registry so getInput() works for local player\n        this.inputRegistry.set(this.localClientId, input);\n        // Store input in history for potential resimulation\n        this.inputHistory.setInput(this.frame, this.localClientId, input);\n\n        // Store prediction for verification\n        this.predictions.push({\n            frame: this.frame,\n            input,\n            hash: this.getStateHash()\n        });\n    }\n\n    /**\n     * Process server-confirmed inputs.\n     * Detects mispredictions and triggers rollback if needed.\n     */\n    onServerTick(serverFrame: number, inputs: NetworkInput[]): boolean {\n        // Save current state before processing\n        this.saveSnapshot(this.frame);\n\n        // Convert NetworkInput[] to Map for input history\n        const inputMap = new Map<number, Record<string, any>>();\n        for (const input of inputs) {\n            inputMap.set(input.clientId, input.data);\n        }\n\n        // Store confirmed inputs in history for potential resimulation\n        this.inputHistory.confirmFrame(serverFrame, inputMap);\n\n        // Prune old input history to manage memory\n        const minFrame = serverFrame - 120;\n        if (minFrame > 0) {\n            this.inputHistory.prune(minFrame);\n        }\n\n        // Check if we predicted this frame\n        const predictionIdx = this.predictions.findIndex(p => p.frame === serverFrame);\n\n        if (predictionIdx !== -1) {\n            // We predicted this frame - verify our prediction was correct\n            const prediction = this.predictions[predictionIdx];\n\n            // Rollback to frame before this tick\n            const snapshot = this.rollbackBuffer.get(serverFrame);\n            if (snapshot) {\n                this.loadSparseSnapshot(snapshot);\n            }\n\n            // Apply server inputs\n            this.tick(serverFrame, inputs);\n\n            // Check if state matches our prediction\n            const serverHash = this.getStateHash();\n            const mispredicted = serverHash !== prediction.hash;\n\n            if (mispredicted) {\n                // Notify about rollback\n                this.onRollback?.(serverFrame);\n\n                // Resimulate from this frame forward\n                this.resimulateFrom(serverFrame);\n            }\n\n            // Remove verified predictions up to this frame\n            this.predictions = this.predictions.filter(p => p.frame > serverFrame);\n\n            return mispredicted;\n        } else {\n            // We didn't predict this frame, just apply normally\n            this.tick(serverFrame, inputs);\n            return false;\n        }\n    }\n\n    /**\n     * Save snapshot for potential rollback.\n     */\n    saveSnapshot(frame: number): void {\n        const snapshot = this.getSparseSnapshot();\n        this.rollbackBuffer.set(frame, snapshot);\n\n        // Prune old snapshots\n        const minFrame = frame - this.rollbackBufferSize + 1;\n        for (const f of this.rollbackBuffer.keys()) {\n            if (f < minFrame) {\n                this.rollbackBuffer.delete(f);\n            }\n        }\n    }\n\n    /**\n     * Restore state from snapshot at frame.\n     */\n    restoreSnapshot(frame: number): boolean {\n        const snapshot = this.rollbackBuffer.get(frame);\n        if (!snapshot) {\n            return false;\n        }\n\n        this.loadSparseSnapshot(snapshot);\n        return true;\n    }\n\n    /**\n     * Check if snapshot exists for frame.\n     */\n    hasSnapshot(frame: number): boolean {\n        return this.rollbackBuffer.has(frame);\n    }\n\n    /**\n     * Get oldest frame in rollback buffer.\n     */\n    getOldestSnapshotFrame(): number | undefined {\n        let oldest: number | undefined;\n        for (const frame of this.rollbackBuffer.keys()) {\n            if (oldest === undefined || frame < oldest) {\n                oldest = frame;\n            }\n        }\n        return oldest;\n    }\n\n    /**\n     * Resimulate from a frame forward to current frame.\n     * Uses stored inputs from input history.\n     *\n     * NOTE: This retrieves data from InputHistory but full tick logic\n     * will be implemented in Phase 2 of the rollback implementation plan.\n     */\n    private resimulateFrom(fromFrame: number): void {\n        const currentFrame = this.frame;\n\n        // Get all frames we need to resimulate (fromFrame+1 to current)\n        // We already applied fromFrame, so start at next frame\n        const framesToResim = this.inputHistory.getRange(fromFrame + 1, currentFrame);\n\n        // TODO Phase 2: Actually resimulate each frame\n        // For now, just log that we have the data available\n        if (framesToResim.length > 0) {\n            // Frames are available for resimulation\n            // Full implementation will call this.tick() for each frame\n            for (const frameInput of framesToResim) {\n                // Convert FrameInput to NetworkInput[] format\n                const inputs: NetworkInput[] = [];\n                for (const [clientId, data] of frameInput.getSortedInputs()) {\n                    inputs.push({ clientId, data });\n                }\n\n                // Tick the world with these inputs\n                this.tick(frameInput.frame, inputs);\n            }\n        }\n\n        // Restore frame counter (tick may have incremented it)\n        this.frame = currentFrame;\n    }\n\n    /**\n     * Get deterministic hash of world state.\n     * Used for comparing state between clients.\n     * Excludes components with sync: false (client-only state).\n     */\n    getStateHash(): string {\n        // Get all entity data in deterministic order\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\n\n        let hash = 0;\n\n        for (const eid of sortedEids) {\n            const index = eid & INDEX_MASK;\n            const components = this.entityComponents.get(eid) || [];\n\n            // Hash eid\n            hash = (hash * 31 + eid) | 0;\n\n            // Hash each component's fields in deterministic order\n            for (const component of components) {\n                // Skip components that are not synced (client-only state)\n                if (!component.sync) continue;\n\n                const fieldNames = [...component.fieldNames].sort();\n                for (const fieldName of fieldNames) {\n                    const arr = component.storage.fields[fieldName];\n                    const value = arr[index];\n                    hash = (hash * 31 + value) | 0;\n                }\n            }\n        }\n\n        // Convert to hex string\n        return (hash >>> 0).toString(16).padStart(8, '0');\n    }\n\n    /**\n     * Clear rollback buffer.\n     */\n    clearRollbackBuffer(): void {\n        this.rollbackBuffer.clear();\n        this.predictions = [];\n    }\n\n    /**\n     * Get pending prediction count.\n     */\n    getPendingPredictionCount(): number {\n        return this.predictions.length;\n    }\n\n    /**\n     * Check if we have pending predictions.\n     */\n    hasPendingPredictions(): boolean {\n        return this.predictions.length > 0;\n    }\n}\n\n/**\n * Network input format.\n */\nexport interface NetworkInput {\n    clientId: number;\n    data: Record<string, any>;\n}\n\n/**\n * Prediction entry for tracking local predictions.\n */\nexport interface PredictionEntry {\n    frame: number;\n    input: Record<string, any>;\n    hash: string;\n}\n\n/**\n * World state for snapshotting.\n */\nexport interface WorldState {\n    entities: EntityState[];\n    allocator: EntityIdAllocatorState;\n    strings: {\n        tables: Record<string, Record<string, number>>;\n        nextIds: Record<string, number>;\n    };\n}\n\n/**\n * Entity state for snapshotting.\n */\nexport interface EntityState {\n    eid: number;\n    type: string;\n    components: Record<string, Record<string, number>>;\n    clientId?: number;\n}\n", "/**\r\n * Binary Codec\r\n *\r\n * Compact binary encoding for arbitrary JSON-like data.\r\n * Used for inputs, snapshots, and all engine-network communication.\r\n */\r\n\r\n// Type markers\r\nconst TYPE_NULL = 0x00;\r\nconst TYPE_FALSE = 0x01;\r\nconst TYPE_TRUE = 0x02;\r\nconst TYPE_INT8 = 0x03;\r\nconst TYPE_INT16 = 0x04;\r\nconst TYPE_INT32 = 0x05;\r\nconst TYPE_FLOAT64 = 0x06;\r\nconst TYPE_STRING = 0x07;\r\nconst TYPE_ARRAY = 0x08;\r\nconst TYPE_OBJECT = 0x09;\r\nconst TYPE_UINT8 = 0x0A;\r\nconst TYPE_UINT16 = 0x0B;\r\nconst TYPE_UINT32 = 0x0C;\r\n\r\n/**\r\n * Binary encoder - accumulates bytes\r\n */\r\nclass BinaryEncoder {\r\n    private buffer: number[] = [];\r\n\r\n    writeByte(b: number): void {\r\n        this.buffer.push(b & 0xFF);\r\n    }\r\n\r\n    writeUint16(n: number): void {\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeUint32(n: number): void {\r\n        this.buffer.push((n >> 24) & 0xFF);\r\n        this.buffer.push((n >> 16) & 0xFF);\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeInt32(n: number): void {\r\n        this.writeUint32(n >>> 0);\r\n    }\r\n\r\n    writeFloat64(n: number): void {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        view.setFloat64(0, n, false); // big-endian\r\n        for (let i = 0; i < 8; i++) {\r\n            this.buffer.push(view.getUint8(i));\r\n        }\r\n    }\r\n\r\n    writeString(s: string): void {\r\n        const encoded = new TextEncoder().encode(s);\r\n        this.writeUint16(encoded.length);\r\n        for (let i = 0; i < encoded.length; i++) {\r\n            this.buffer.push(encoded[i]);\r\n        }\r\n    }\r\n\r\n    writeValue(value: any): void {\r\n        if (value === null || value === undefined) {\r\n            this.writeByte(TYPE_NULL);\r\n        } else if (value === false) {\r\n            this.writeByte(TYPE_FALSE);\r\n        } else if (value === true) {\r\n            this.writeByte(TYPE_TRUE);\r\n        } else if (typeof value === 'number') {\r\n            if (Number.isInteger(value)) {\r\n                if (value >= 0 && value <= 255) {\r\n                    this.writeByte(TYPE_UINT8);\r\n                    this.writeByte(value);\r\n                } else if (value >= 0 && value <= 65535) {\r\n                    this.writeByte(TYPE_UINT16);\r\n                    this.writeUint16(value);\r\n                } else if (value >= -2147483648 && value <= 2147483647) {\r\n                    this.writeByte(TYPE_INT32);\r\n                    this.writeInt32(value);\r\n                } else {\r\n                    this.writeByte(TYPE_FLOAT64);\r\n                    this.writeFloat64(value);\r\n                }\r\n            } else {\r\n                this.writeByte(TYPE_FLOAT64);\r\n                this.writeFloat64(value);\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            this.writeByte(TYPE_STRING);\r\n            this.writeString(value);\r\n        } else if (Array.isArray(value)) {\r\n            this.writeByte(TYPE_ARRAY);\r\n            this.writeUint16(value.length);\r\n            for (const item of value) {\r\n                this.writeValue(item);\r\n            }\r\n        } else if (typeof value === 'object') {\r\n            this.writeByte(TYPE_OBJECT);\r\n            const keys = Object.keys(value);\r\n            this.writeUint16(keys.length);\r\n            for (const key of keys) {\r\n                this.writeString(key);\r\n                this.writeValue(value[key]);\r\n            }\r\n        } else {\r\n            // Unknown type - encode as null\r\n            this.writeByte(TYPE_NULL);\r\n        }\r\n    }\r\n\r\n    toUint8Array(): Uint8Array {\r\n        return new Uint8Array(this.buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * Binary decoder - reads bytes\r\n */\r\nclass BinaryDecoder {\r\n    private data: Uint8Array;\r\n    private pos: number = 0;\r\n\r\n    constructor(data: Uint8Array) {\r\n        this.data = data;\r\n    }\r\n\r\n    readByte(): number {\r\n        return this.data[this.pos++];\r\n    }\r\n\r\n    readUint16(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        return (b1 << 8) | b2;\r\n    }\r\n\r\n    readUint32(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        const b3 = this.data[this.pos++];\r\n        const b4 = this.data[this.pos++];\r\n        return ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >>> 0;\r\n    }\r\n\r\n    readInt32(): number {\r\n        const u = this.readUint32();\r\n        return u > 0x7FFFFFFF ? u - 0x100000000 : u;\r\n    }\r\n\r\n    readFloat64(): number {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        for (let i = 0; i < 8; i++) {\r\n            view.setUint8(i, this.data[this.pos++]);\r\n        }\r\n        return view.getFloat64(0, false);\r\n    }\r\n\r\n    readString(): string {\r\n        const len = this.readUint16();\r\n        const bytes = this.data.slice(this.pos, this.pos + len);\r\n        this.pos += len;\r\n        return new TextDecoder().decode(bytes);\r\n    }\r\n\r\n    readValue(): any {\r\n        const type = this.readByte();\r\n\r\n        switch (type) {\r\n            case TYPE_NULL:\r\n                return null;\r\n            case TYPE_FALSE:\r\n                return false;\r\n            case TYPE_TRUE:\r\n                return true;\r\n            case TYPE_UINT8:\r\n                return this.readByte();\r\n            case TYPE_UINT16:\r\n                return this.readUint16();\r\n            case TYPE_INT32:\r\n                return this.readInt32();\r\n            case TYPE_UINT32:\r\n                return this.readUint32();\r\n            case TYPE_FLOAT64:\r\n                return this.readFloat64();\r\n            case TYPE_STRING:\r\n                return this.readString();\r\n            case TYPE_ARRAY: {\r\n                const len = this.readUint16();\r\n                const arr = [];\r\n                for (let i = 0; i < len; i++) {\r\n                    arr.push(this.readValue());\r\n                }\r\n                return arr;\r\n            }\r\n            case TYPE_OBJECT: {\r\n                const len = this.readUint16();\r\n                const obj: Record<string, any> = {};\r\n                for (let i = 0; i < len; i++) {\r\n                    const key = this.readString();\r\n                    obj[key] = this.readValue();\r\n                }\r\n                return obj;\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Encode any JSON-compatible value to binary.\r\n */\r\nexport function encode(value: any): Uint8Array {\r\n    const encoder = new BinaryEncoder();\r\n    encoder.writeValue(value);\r\n    return encoder.toUint8Array();\r\n}\r\n\r\n/**\r\n * Decode binary data to a value.\r\n */\r\nexport function decode(data: Uint8Array): any {\r\n    const decoder = new BinaryDecoder(data);\r\n    return decoder.readValue();\r\n}\r\n", "/**\n * Game - High-level wrapper for ECS World with Network Integration\n *\n * Provides the game API that examples use:\n * - game.defineEntity(name) \u2192 EntityBuilder\n * - game.spawn(type, props) \u2192 Entity\n * - game.query(type) \u2192 Iterator\n * - game.addSystem(fn, options)\n * - game.physics \u2192 Physics2D integration\n * - game.connect() \u2192 Network connection with rollback sync\n */\n\nimport { World, EntityBuilder, NetworkInput } from './core/world';\nimport { Entity } from './core/entity';\nimport { ComponentType } from './core/component';\nimport { SystemFn, SystemOptions } from './core/system';\nimport { Transform2D, Body2D, Player } from './components';\nimport { SparseSnapshot } from './core/snapshot';\nimport { QueryIterator } from './core/query';\nimport { encode, decode } from './codec';\nimport { loadRandomState, saveRandomState } from './math/random';\nimport { INDEX_MASK } from './core/constants';\n\n// ==========================================\n// Types\n// ==========================================\n\n/** Physics system interface */\ninterface Physics2DLike {\n    physicsWorld: any;\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this;\n    setGravity(x: number, y: number): this;\n    getBody(entity: Entity): any;\n    clear(): void;\n    wakeAllBodies(): void;\n}\n\n/** Network connection interface (from modu-network SDK) */\ninterface Connection {\n    send(data: any): void;\n    sendSnapshot(snapshot: any, hash: string, seq?: number, frame?: number): void;\n    leaveRoom(): void;\n    clientId: string | null;\n    totalBytesIn: number;\n    totalBytesOut: number;\n    bandwidthIn: number;\n    bandwidthOut: number;\n}\n\n/** Network SDK interface */\ninterface NetworkSDK {\n    connect(roomId: string, options: any): Promise<Connection>;\n}\n\n/** Network input from server */\ninterface ServerInput {\n    seq: number;\n    clientId: string;\n    data: any;\n    frame?: number;\n}\n\n/** Game callbacks for lifecycle events */\nexport interface GameCallbacks {\n    /** Called when room is first created (first client joins) */\n    onRoomCreate?(): void;\n    /** Called when a client connects */\n    onConnect?(clientId: string): void;\n    /** Called when a client disconnects */\n    onDisconnect?(clientId: string): void;\n    /** Called after snapshot restore with all restored entities */\n    onSnapshot?(entities: Entity[]): void;\n    /** Called each game tick */\n    onTick?(frame: number): void;\n    /** Called each render frame */\n    render?(): void;\n}\n\n/** Connection options */\nexport interface ConnectOptions {\n    /** Direct node URL (bypasses central service) */\n    nodeUrl?: string;\n    /** Central service URL */\n    centralServiceUrl?: string;\n    /** JWT token for authentication */\n    joinToken?: string;\n}\n\n// Debug flag - set to false for production\nconst DEBUG_NETWORK = false;\n\n// ==========================================\n// Prefab Class\n// ==========================================\n\n/**\n * Prefab - spawnable entity definition\n */\nexport class Prefab {\n    constructor(\n        private game: Game,\n        private typeName: string,\n        private builder: EntityBuilder\n    ) {}\n\n    /**\n     * Spawn a new entity from this prefab.\n     */\n    spawn(props: Record<string, any> = {}): Entity {\n        return this.game.spawn(this.typeName, props);\n    }\n}\n\n// ==========================================\n// Game Class\n// ==========================================\n\n/**\n * Game class - main entry point for games using the ECS.\n */\nexport class Game {\n    /** ECS World instance */\n    readonly world: World;\n\n    /** Physics system (optional) */\n    physics: Physics2DLike | null = null;\n\n    // ==========================================\n    // Network State\n    // ==========================================\n\n    /** WebSocket connection */\n    private connection: Connection | null = null;\n\n    /** Game callbacks */\n    private callbacks: GameCallbacks = {};\n\n    /** Connected room ID */\n    private connectedRoomId: string | null = null;\n\n    /** Local client ID (string form) */\n    private localClientIdStr: string | null = null;\n\n    /** All connected client IDs (in join order for determinism) */\n    private connectedClients: string[] = [];\n\n    /** Authority client (first joiner, sends snapshots) */\n    private authorityClientId: string | null = null;\n\n    /** Current server frame */\n    private currentFrame: number = 0;\n\n    /** Last processed frame (for skipping old frames after catchup) */\n    private lastProcessedFrame: number = 0;\n\n    /** Last processed input sequence */\n    private lastInputSeq: number = 0;\n\n    /** Server tick rate */\n    private serverFps: number = 20;\n\n    /** RequestAnimationFrame handle */\n    private gameLoop: number | null = null;\n\n    /** Deferred snapshot flag (send after tick completes) */\n    private pendingSnapshotUpload: boolean = false;\n\n    /** Last snapshot info for debug UI */\n    private lastSnapshotHash: string | null = null;\n    private lastSnapshotFrame: number = 0;\n    private lastSnapshotSize: number = 0;\n    private lastSnapshotEntityCount: number = 0;\n\n    /** Drift tracking stats for debug UI */\n    private driftStats = {\n        determinismPercent: 100,\n        totalChecks: 0,\n        matchingFieldCount: 0,\n        totalFieldCount: 0\n    };\n\n    /** Tick timing for render interpolation */\n    private lastTickTime: number = 0;\n    private tickIntervalMs: number = 50; // 20fps default\n\n    // ==========================================\n    // String Interning\n    // ==========================================\n\n    /** String to ID mapping for clientIds */\n    private clientIdToNum: Map<string, number> = new Map();\n    private numToClientId: Map<number, string> = new Map();\n    private nextClientNum: number = 1;\n\n    /** Prefab registry */\n    private prefabs: Map<string, Prefab> = new Map();\n\n    /** Collision handlers (type:type -> handler) */\n    private collisionHandlers: Map<string, (a: Entity, b: Entity) => void> = new Map();\n\n    /** Clients that already have entities from snapshot (skip onConnect for them during catchup) */\n    private clientsWithEntitiesFromSnapshot: Set<string> = new Set();\n\n    /** Attached renderer */\n    private renderer: any = null;\n\n    /** Installed plugins */\n    private plugins: Map<string, any> = new Map();\n\n    constructor() {\n        this.world = new World();\n    }\n\n    // ==========================================\n    // Plugin API\n    // ==========================================\n\n    /**\n     * Add a plugin to the game.\n     *\n     * Plugins can be classes or factory functions that integrate with the game.\n     * Common plugins include Physics2DSystem and AutoRenderer.\n     *\n     * @example\n     * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n     * game.addPlugin(AutoRenderer, canvas);\n     *\n     * @param Plugin - Plugin class or factory\n     * @param args - Arguments to pass to the plugin constructor\n     * @returns The created plugin instance\n     */\n    addPlugin<T>(\n        Plugin: new (game: Game, ...args: any[]) => T,\n        ...args: any[]\n    ): T {\n        const plugin = new Plugin(this, ...args);\n        const name = Plugin.name || 'anonymous';\n        this.plugins.set(name, plugin);\n        return plugin;\n    }\n\n    /**\n     * Get a previously added plugin by class.\n     */\n    getPlugin<T>(Plugin: new (...args: any[]) => T): T | undefined {\n        return this.plugins.get(Plugin.name) as T | undefined;\n    }\n\n    /**\n     * Current frame number.\n     */\n    get frame(): number {\n        return this.currentFrame;\n    }\n\n    /**\n     * Deterministic time in milliseconds.\n     * Use this instead of Date.now() for game logic.\n     *\n     * @example\n     * const RESPAWN_TIME = 3000; // 3 seconds\n     * deadPlayers.set(clientId, game.time + RESPAWN_TIME);\n     * if (game.time >= respawnTime) spawnPlayer(clientId);\n     */\n    get time(): number {\n        return this.currentFrame * this.tickIntervalMs;\n    }\n\n    // ==========================================\n    // Entity Definition API\n    // ==========================================\n\n    /**\n     * Define a new entity type.\n     *\n     * @example\n     * const Cell = game.defineEntity('cell')\n     *     .with(Transform2D)\n     *     .with(Body2D, { shapeType: 1, radius: 20 })\n     *     .with(Player);\n     */\n    defineEntity(name: string): GameEntityBuilder {\n        return new GameEntityBuilder(this, name);\n    }\n\n    /**\n     * Register a prefab (internal).\n     */\n    _registerPrefab(name: string, builder: EntityBuilder): Prefab {\n        const prefab = new Prefab(this, name, builder);\n        this.prefabs.set(name, prefab);\n        return prefab;\n    }\n\n    // ==========================================\n    // Entity Spawning\n    // ==========================================\n\n    /**\n     * Spawn an entity.\n     *\n     * @param type Entity type name\n     * @param props Property overrides\n     */\n    spawn(type: string, props: Record<string, any> = {}): Entity {\n        // Convert string clientId to number\n        let numericProps = { ...props };\n        if (props.clientId && typeof props.clientId === 'string') {\n            numericProps.clientId = this.internClientId(props.clientId);\n        }\n\n        return this.world.spawn(type, numericProps);\n    }\n\n    /**\n     * Get a prefab by name.\n     */\n    getPrefab(name: string): Prefab | undefined {\n        return this.prefabs.get(name);\n    }\n\n    // ==========================================\n    // Query API\n    // ==========================================\n\n    /**\n     * Query entities by type.\n     */\n    query(type: string): QueryIterator<Entity> {\n        return this.world.query(type);\n    }\n\n    /**\n     * Get entities by type as array.\n     */\n    getEntitiesByType(type: string): Entity[] {\n        return this.world.query(type).toArray();\n    }\n\n    /**\n     * Get all entities.\n     */\n    getAllEntities(): Entity[] {\n        return this.world.getAllEntities();\n    }\n\n    /**\n     * Get entity by client ID.\n     */\n    getEntityByClientId(clientId: string): Entity | null {\n        const numId = this.clientIdToNum.get(clientId);\n        if (numId === undefined) return null;\n        return this.world.getEntityByClientId(numId);\n    }\n\n    /**\n     * Get player by client ID (alias for getEntityByClientId).\n     */\n    getPlayer(clientId: string): Entity | null {\n        return this.getEntityByClientId(clientId);\n    }\n\n    /**\n     * Get all players (entities with Player component).\n     */\n    getPlayers(): Entity[] {\n        return this.world.query(Player).toArray();\n    }\n\n    // ==========================================\n    // System API\n    // ==========================================\n\n    /**\n     * Add a system.\n     */\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\n        return this.world.addSystem(fn, options);\n    }\n\n    // ==========================================\n    // Collision API\n    // ==========================================\n\n    /**\n     * Register a collision handler.\n     */\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this {\n        if (this.physics) {\n            this.physics.onCollision(typeA, typeB, handler);\n        } else {\n            const key = `${typeA}:${typeB}`;\n            this.collisionHandlers.set(key, handler);\n        }\n        return this;\n    }\n\n    // ==========================================\n    // String Interning\n    // ==========================================\n\n    /**\n     * Intern a client ID string, get back a number.\n     */\n    internClientId(clientId: string): number {\n        let num = this.clientIdToNum.get(clientId);\n        if (num === undefined) {\n            num = this.nextClientNum++;\n            this.clientIdToNum.set(clientId, num);\n            this.numToClientId.set(num, clientId);\n        }\n        return num;\n    }\n\n    /**\n     * Get client ID string from number.\n     */\n    getClientIdString(num: number): string | undefined {\n        return this.numToClientId.get(num);\n    }\n\n    /**\n     * Intern any string in a namespace.\n     */\n    internString(namespace: string, str: string): number {\n        return this.world.internString(namespace, str);\n    }\n\n    /**\n     * Get string by ID from namespace.\n     */\n    getString(namespace: string, id: number): string | null {\n        return this.world.getString(namespace, id);\n    }\n\n    // ==========================================\n    // State Management\n    // ==========================================\n\n    /**\n     * Get deterministic state hash.\n     */\n    getStateHash(): string {\n        return this.world.getStateHash();\n    }\n\n    /**\n     * Reset game state.\n     */\n    reset(): void {\n        this.world.reset();\n        this.currentFrame = 0;\n    }\n\n    // ==========================================\n    // Network Connection\n    // ==========================================\n\n    /**\n     * Connect to a multiplayer room.\n     */\n    async connect(\n        roomId: string,\n        callbacks: GameCallbacks,\n        options: ConnectOptions = {}\n    ): Promise<void> {\n        this.callbacks = callbacks;\n\n        // Allow URL params to override (for testing)\n        if (typeof window !== 'undefined') {\n            const params = new URLSearchParams(window.location.search);\n            if (params.get('room')) roomId = params.get('room')!;\n            if (params.get('nodeUrl')) options.nodeUrl = params.get('nodeUrl')!;\n        }\n\n        this.connectedRoomId = roomId;\n\n        // Get network SDK\n        const network: NetworkSDK = (window as any).moduNetwork;\n        if (!network) {\n            throw new Error('moduNetwork not found. Include modu-network SDK before calling connect().');\n        }\n\n        console.log(`[ecs] Connecting to room \"${roomId}\"...`);\n\n        try {\n            this.connection = await network.connect(roomId, {\n                nodeUrl: options.nodeUrl,\n                centralServiceUrl: options.centralServiceUrl,\n                appId: 'dev',\n                joinToken: options.joinToken,\n\n                onConnect: (\n                    snapshot: any,\n                    inputs: ServerInput[],\n                    frame: number,\n                    nodeUrl: string | null,\n                    fps: number,\n                    clientId: string\n                ) => {\n                    this.handleConnect(snapshot, inputs, frame, fps, clientId);\n                },\n\n                onTick: (frame: number, inputs: ServerInput[]) => {\n                    this.handleTick(frame, inputs);\n                },\n\n                onDisconnect: () => {\n                    this.handleDisconnect();\n                },\n\n                onBinarySnapshot: (data: Uint8Array) => {\n                    this.handleServerSnapshot(data);\n                },\n\n                onError: (error: string) => {\n                    console.error('[ecs] Network error:', error);\n                }\n            });\n\n            this.localClientIdStr = this.connection.clientId;\n            if (this.localClientIdStr) this.world.localClientId = this.internClientId(this.localClientIdStr);\n        } catch (err: any) {\n            console.warn('[ecs] Connection failed:', err?.message || err);\n            this.connection = null;\n            this.connectedRoomId = null;\n        }\n    }\n\n    /**\n     * Handle initial connection (first join or late join).\n     */\n    private handleConnect(\n        snapshot: any,\n        inputs: ServerInput[],\n        frame: number,\n        fps: number,\n        clientId: string\n    ): void {\n        // Decode binary snapshot if needed\n        let snapshotSize = 0;\n        if (snapshot instanceof Uint8Array) {\n            snapshotSize = snapshot.length;\n            if (snapshot.length < 2) {\n                snapshot = null;\n            } else {\n                try {\n                    snapshot = decode(snapshot)?.snapshot || null;\n                } catch (e) {\n                    console.error('[ecs] Failed to decode snapshot:', e);\n                    snapshot = null;\n                }\n            }\n        }\n\n        // Store connection state\n        this.localClientIdStr = clientId;\n        this.world.localClientId = this.internClientId(clientId);\n        this.serverFps = fps;\n        this.tickIntervalMs = 1000 / fps;\n        this.currentFrame = frame;\n\n        // Store snapshot hash for debug UI\n        if (snapshot?.hash !== undefined) {\n            this.lastSnapshotHash = typeof snapshot.hash === 'number'\n                ? snapshot.hash.toString(16).padStart(8, '0')\n                : String(snapshot.hash);\n            this.lastSnapshotFrame = snapshot.frame || frame;\n            this.lastSnapshotSize = snapshotSize;\n            this.lastSnapshotEntityCount = snapshot.entities?.length || 0;\n        }\n\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Connected as ${clientId}, frame ${frame}, fps ${fps}`);\n            console.log(`[ecs] Snapshot:`, snapshot ? { frame: snapshot.frame, entityCount: snapshot.entities?.length } : 'none');\n            console.log(`[ecs] Inputs: ${inputs.length}`);\n        }\n\n        const hasValidSnapshot = snapshot?.entities && snapshot.entities.length > 0;\n\n        if (hasValidSnapshot) {\n            // === LATE JOINER PATH ===\n            if (DEBUG_NETWORK) console.log(`[ecs] Late join: restoring snapshot frame=${snapshot.frame}`);\n\n            // 1. Restore snapshot\n            this.currentFrame = snapshot.frame || frame;\n            this.loadNetworkSnapshot(snapshot);\n\n            // 2. Build authority chain from ALL inputs\n            for (const input of inputs) {\n                this.processAuthorityChainInput(input);\n            }\n\n            // 3. Call onSnapshot callback\n            if (this.callbacks.onSnapshot) {\n                this.callbacks.onSnapshot(this.world.getAllEntities());\n            }\n\n            // 4. Filter inputs already in snapshot\n            const snapshotSeq = snapshot.seq || 0;\n            const pendingInputs = inputs\n                .filter(i => i.seq > snapshotSeq)\n                .sort((a, b) => a.seq - b.seq);\n\n            // 5. Run catchup simulation\n            const snapshotFrame = this.currentFrame;\n            const isPostTick = snapshot.postTick === true;\n            const startFrame = isPostTick ? snapshotFrame + 1 : snapshotFrame;\n            const ticksToRun = frame - startFrame + 1;\n\n            // Log snapshot loading info\n            const snapshotSizeKB = (snapshotSize / 1024).toFixed(2);\n            console.log(`[ecs] Loaded snapshot: ${snapshotSizeKB} KB, ${ticksToRun} frames behind`);\n            console.log(`[ecs] Applying ${pendingInputs.length} inputs to catch up`);\n\n            if (DEBUG_NETWORK) {\n                console.log(`[ecs] Catchup: from ${startFrame} to ${frame} (${ticksToRun} ticks), ${pendingInputs.length} pending inputs`);\n            }\n\n            if (ticksToRun > 0) {\n                this.runCatchup(startFrame, frame, pendingInputs);\n            }\n        } else {\n            // === FIRST JOINER PATH ===\n            if (DEBUG_NETWORK) console.log('[ecs] First join: creating room');\n\n            this.currentFrame = frame;\n            this.callbacks.onRoomCreate?.();\n\n            // Process all inputs\n            for (const input of inputs) {\n                this.processInput(input);\n            }\n        }\n\n        // Send initial snapshot if we're authority\n        if (this.checkIsAuthority()) {\n            this.sendSnapshot('init');\n        }\n\n        // Start game loop\n        this.startGameLoop();\n        if (DEBUG_NETWORK) console.log('[ecs] Game loop started');\n    }\n\n    /**\n     * Handle server tick.\n     */\n    private handleTick(frame: number, inputs: ServerInput[]): void {\n        // Skip frames we've already processed (e.g., during catchup)\n        if (frame <= this.lastProcessedFrame) {\n            if (DEBUG_NETWORK) {\n                console.log(`[ecs] Skipping old frame ${frame} (already at ${this.lastProcessedFrame})`);\n            }\n            return;\n        }\n\n        this.currentFrame = frame;\n        this.lastProcessedFrame = frame;\n\n        if (DEBUG_NETWORK && inputs.length > 0) {\n            const types = inputs.map(i => i.data?.type || 'game').join(',');\n            console.log(`[ecs] onTick frame=${frame}: ${inputs.length} inputs (${types})`);\n        }\n\n        // 1. Process all inputs for this frame (sorted by seq for determinism)\n        // Multiple inputs can arrive in a single tick - seq determines order\n        const sortedInputs = inputs.length > 1\n            ? [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0))\n            : inputs;\n        for (const input of sortedInputs) {\n            this.processInput(input);\n        }\n\n        // 2. Run ECS world tick (systems)\n        this.world.tick(frame, []);\n\n        // 3. Call game's onTick callback\n        this.callbacks.onTick?.(frame);\n\n        // 4. Send deferred snapshot if pending\n        if (this.pendingSnapshotUpload && this.checkIsAuthority()) {\n            this.sendSnapshot('join');\n            this.pendingSnapshotUpload = false;\n        }\n\n        // 5. Record tick time for interpolation\n        this.lastTickTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\n    }\n\n    /**\n     * Process a network input (join/leave/game).\n     */\n    private processInput(input: ServerInput): void {\n        // Decode binary data if needed\n        let data = input.data;\n        if (data instanceof Uint8Array) {\n            try {\n                data = decode(data);\n            } catch (e) {\n                console.warn('[ecs] Failed to decode input:', e);\n                return;\n            }\n        }\n\n        const clientId = data?.clientId || input.clientId;\n        const type = data?.type;\n\n        // Track input sequence\n        if (input.seq > this.lastInputSeq) {\n            this.lastInputSeq = input.seq;\n        }\n\n        if (type === 'join') {\n            // Track connected clients\n            if (!this.connectedClients.includes(clientId)) {\n                this.connectedClients.push(clientId);\n            }\n\n            // First joiner becomes authority\n            if (this.authorityClientId === null) {\n                this.authorityClientId = clientId;\n            }\n\n            if (DEBUG_NETWORK) {\n                console.log(`[ecs] Join: ${clientId.slice(0, 8)}, authority=${this.authorityClientId?.slice(0, 8)}`);\n            }\n\n            // Call callback ONLY if this client doesn't already have an entity from snapshot\n            // This prevents duplicate entity creation during catchup\n            if (this.clientsWithEntitiesFromSnapshot.has(clientId)) {\n                if (DEBUG_NETWORK) {\n                    console.log(`[ecs] Skipping onConnect for ${clientId.slice(0, 8)} - already has entity from snapshot`);\n                }\n            } else {\n                this.callbacks.onConnect?.(clientId);\n            }\n\n            // Mark snapshot needed\n            if (this.checkIsAuthority()) {\n                this.pendingSnapshotUpload = true;\n            }\n        } else if (type === 'leave' || type === 'disconnect') {\n            // Remove from connected clients\n            const idx = this.connectedClients.indexOf(clientId);\n            if (idx !== -1) {\n                this.connectedClients.splice(idx, 1);\n            }\n\n            // Transfer authority if needed\n            if (clientId === this.authorityClientId) {\n                this.authorityClientId = this.connectedClients[0] || null;\n            }\n\n            if (DEBUG_NETWORK) {\n                console.log(`[ecs] Leave: ${clientId.slice(0, 8)}, new authority=${this.authorityClientId?.slice(0, 8)}`);\n            }\n\n            // Call callback\n            this.callbacks.onDisconnect?.(clientId);\n        } else if (data) {\n            // Game input - store in world's input registry\n            this.routeInputToEntity(clientId, data);\n        }\n    }\n\n    /**\n     * Route game input to the world's input registry for systems to read.\n     */\n    private routeInputToEntity(clientId: string, data: any): void {\n        const numId = this.internClientId(clientId);\n\n        // Use O(1) clientId index lookup instead of iterating\n        const entity = this.world.getEntityByClientId(numId);\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] routeInput: clientId=${clientId.slice(0, 8)}, numId=${numId}, entity=${entity?.eid || 'null'}, data=${JSON.stringify(data)}`);\n        }\n        if (entity) {\n            // Store input in world's input registry for systems to read\n            this.world.setInput(numId, data);\n        } else if (DEBUG_NETWORK) {\n            console.log(`[ecs] WARNING: No entity for clientId ${clientId.slice(0, 8)} (numId=${numId})`);\n        }\n    }\n\n    /**\n     * Process input for authority chain only (no game logic).\n     */\n    private processAuthorityChainInput(input: ServerInput): void {\n        let data = input.data;\n        if (data instanceof Uint8Array) {\n            try { data = decode(data); } catch { return; }\n        }\n\n        const clientId = data?.clientId || input.clientId;\n        const type = data?.type;\n\n        if (type === 'join') {\n            if (!this.connectedClients.includes(clientId)) {\n                this.connectedClients.push(clientId);\n            }\n            if (this.authorityClientId === null) {\n                this.authorityClientId = clientId;\n            }\n        } else if (type === 'leave' || type === 'disconnect') {\n            const idx = this.connectedClients.indexOf(clientId);\n            if (idx !== -1) {\n                this.connectedClients.splice(idx, 1);\n            }\n            if (clientId === this.authorityClientId) {\n                this.authorityClientId = this.connectedClients[0] || null;\n            }\n        }\n    }\n\n    /**\n     * Run catchup simulation.\n     */\n    private runCatchup(startFrame: number, endFrame: number, inputs: ServerInput[]): void {\n        const ticksToRun = endFrame - startFrame + 1;\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Catchup: ${ticksToRun} ticks from ${startFrame} to ${endFrame}, ${inputs.length} inputs`);\n        }\n\n        // CRITICAL: Sort all inputs by seq to ensure correct order within frames\n        // Multiple inputs can occur in a single frame - seq determines order\n        const sortedInputs = [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0));\n\n        // Build map of frame -> inputs for that frame (sorted by seq)\n        const inputsByFrame = new Map<number, ServerInput[]>();\n        for (const input of sortedInputs) {\n            // Inputs without frame are assigned to startFrame (first catchup frame)\n            const frame = input.frame ?? startFrame;\n            if (!inputsByFrame.has(frame)) {\n                inputsByFrame.set(frame, []);\n            }\n            inputsByFrame.get(frame)!.push(input);\n        }\n\n        // Run each tick\n        for (let f = 0; f < ticksToRun; f++) {\n            const tickFrame = startFrame + f;\n\n            // Process inputs for this frame (already sorted by seq)\n            const frameInputs = inputsByFrame.get(tickFrame) || [];\n            for (const input of frameInputs) {\n                this.processInput(input);\n            }\n\n            // Run world tick\n            this.world.tick(tickFrame, []);\n\n            // Call game's onTick\n            this.callbacks.onTick?.(tickFrame);\n        }\n\n        this.currentFrame = endFrame;\n        this.lastProcessedFrame = endFrame;  // Prevent re-processing old frames\n\n        // Clear the snapshot entity tracking - catchup is done\n        // Future join events should trigger onConnect normally\n        this.clientsWithEntitiesFromSnapshot.clear();\n\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Catchup complete at frame ${this.currentFrame}, hash=${this.getStateHash()}`);\n        }\n    }\n\n    // ==========================================\n    // Snapshot Methods\n    // ==========================================\n\n    /**\n     * Convert ECS snapshot to network wire format.\n     */\n    private getNetworkSnapshot(): any {\n        // Format 5: Type-indexed encoding with optional syncFields\n        // - types: [\"snake-head\", \"snake-segment\", ...] - type names array\n        // - schema: [[compSchema], [compSchema], ...] - indexed by type index\n        // - entities: [[eid, typeIndex, values], ...] - typeIndex instead of string\n        // If entity type has syncFields, only those fields are included in schema/values\n\n        // Build type index and schema\n        const types: string[] = [];\n        const typeToIndex = new Map<string, number>();\n        const schema: [string, string[]][][] = [];\n        const typeSyncFields = new Map<string, Set<string>>();  // Cache syncFields per type\n        const entities: any[] = [];\n\n        for (const entity of this.world.getAllEntities()) {\n            const index = entity.eid & INDEX_MASK;\n            const type = entity.type;\n\n            // Assign type index if new type\n            if (!typeToIndex.has(type)) {\n                const typeIdx = types.length;\n                types.push(type);\n                typeToIndex.set(type, typeIdx);\n\n                // Get syncFields for this type (if defined)\n                const entityDef = this.world.getEntityDef(type);\n                const syncFieldsSet = entityDef?.syncFields\n                    ? new Set(entityDef.syncFields)\n                    : null;\n                typeSyncFields.set(type, syncFieldsSet!);\n\n                // Build schema for this type (only synced fields)\n                const typeSchema: [string, string[]][] = [];\n                for (const comp of entity.getComponents()) {\n                    const fieldsToSync = syncFieldsSet\n                        ? comp.fieldNames.filter(f => syncFieldsSet.has(f))\n                        : comp.fieldNames;\n                    if (fieldsToSync.length > 0) {\n                        typeSchema.push([comp.name, fieldsToSync]);\n                    }\n                }\n                schema.push(typeSchema);\n            }\n\n            // Encode values as flat array matching schema order (only synced fields)\n            const syncFieldsSet = typeSyncFields.get(type);\n            const values: any[] = [];\n            for (const comp of entity.getComponents()) {\n                for (const fieldName of comp.fieldNames) {\n                    // Only include if no syncFields defined OR field is in syncFields\n                    if (!syncFieldsSet || syncFieldsSet.has(fieldName)) {\n                        values.push(comp.storage.fields[fieldName][index]);\n                    }\n                }\n            }\n\n            entities.push([\n                entity.eid,  // eid as number (no need for hex conversion)\n                typeToIndex.get(type)!,  // type INDEX (1 byte) instead of string\n                values\n            ]);\n        }\n\n        // Compute minimal ID allocator state from entities\n        let maxIndex = 0;\n        const activeGenerations: Record<number, number> = {};\n        for (const e of entities) {\n            const eid = e[0];\n            const index = eid & INDEX_MASK;\n            const gen = eid >>> 20;\n            if (index >= maxIndex) maxIndex = index + 1;\n            activeGenerations[index] = gen;\n        }\n\n        return {\n            frame: this.currentFrame,\n            seq: this.lastInputSeq,\n            format: 5, // Format 5: type-indexed compact encoding\n            types,     // Type names array (sent once)\n            schema,    // Component schemas indexed by type index\n            entities,  // Array of [eid, typeIndex, values[]]\n            idAllocatorState: {\n                nextIndex: maxIndex,\n                freeList: [],\n                generations: activeGenerations\n            },\n            rng: saveRandomState(),\n            strings: this.world.strings.getState(),\n            clientIdMap: {\n                toNum: Object.fromEntries(this.clientIdToNum),\n                nextNum: this.nextClientNum\n            },\n            inputState: this.world.getInputState()\n        };\n    }\n\n    /**\n     * Load network snapshot into ECS world.\n     */\n    private loadNetworkSnapshot(snapshot: any): void {\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Loading snapshot: ${snapshot.entities?.length} entities`);\n        }\n\n        // Reset world FIRST (clears everything including ID allocator and strings)\n        this.world.reset();\n\n        // CRITICAL: Clear physics state before recreating entities\n        // Without this, old physics bodies with stale state (positions, sleeping, etc.)\n        // would be reused when entities are recreated with the same eids\n        if (this.physics) {\n            this.physics.clear();\n        }\n\n        // Restore RNG state\n        if (snapshot.rng) {\n            loadRandomState(snapshot.rng);\n        }\n\n        // Restore strings AFTER reset\n        if (snapshot.strings) {\n            this.world.strings.setState(snapshot.strings);\n        }\n\n        // Restore clientId interning\n        if (snapshot.clientIdMap) {\n            this.clientIdToNum = new Map(Object.entries(snapshot.clientIdMap.toNum).map(([k, v]) => [k, v as number]));\n            this.numToClientId = new Map(Array.from(this.clientIdToNum.entries()).map(([k, v]) => [v, k]));\n            this.nextClientNum = snapshot.clientIdMap.nextNum || 1;\n        }\n\n        // Format 5: type-indexed encoding\n        const types = snapshot.types;\n        const schema = snapshot.schema;\n        const entitiesData = snapshot.entities;\n\n        // Track loaded entities by type for onRestore callbacks\n        const loadedEntitiesByType = new Map<string, Entity[]>();\n\n        for (const entityData of entitiesData) {\n            const [eid, typeIndex, values] = entityData;\n            const type = types[typeIndex];\n            const typeSchema = schema[typeIndex];\n\n            // Spawn entity with specific eid\n            let entity;\n            try {\n                entity = this.world.spawnWithId(type, eid, {});\n            } catch (e) {\n                console.warn(`[ecs] Failed to spawn ${type} with eid ${eid}:`, e);\n                continue;\n            }\n\n            // Track for onRestore callback\n            if (!loadedEntitiesByType.has(type)) {\n                loadedEntitiesByType.set(type, []);\n            }\n            loadedEntitiesByType.get(type)!.push(entity);\n\n            // Restore values using schema\n            const index = eid & INDEX_MASK;\n            let valueIdx = 0;\n\n            for (const [compName, fieldNames] of typeSchema) {\n                // Find component on entity\n                for (const comp of entity.getComponents()) {\n                    if (comp.name === compName) {\n                        for (const fieldName of fieldNames) {\n                            comp.storage.fields[fieldName][index] = values[valueIdx++];\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // CRITICAL: Update clientIdIndex for Player entities after component restore\n            // The spawnWithId call above didn't have clientId in props, so the index wasn't set\n            if (entity.has(Player)) {\n                const player = entity.get(Player);\n                if (player.clientId !== 0) {\n                    this.world.setEntityClientId(entity.eid, player.clientId);\n                }\n            }\n        }\n\n        // Call onRestore callbacks for entity types that have them\n        // This allows reconstructing non-synced fields from synced data\n        for (const [type, entities] of loadedEntitiesByType) {\n            const entityDef = this.world.getEntityDef(type);\n            if (entityDef?.onRestore) {\n                for (const entity of entities) {\n                    entityDef.onRestore(entity, this);\n                }\n            }\n        }\n\n        // Restore input sequence\n        this.lastInputSeq = snapshot.seq || 0;\n\n        // Restore ID allocator state for proper future allocations\n        // Format 3+: minimal format with generations as object { index: gen }\n        // Format 2-: full format with generations as array\n        if (snapshot.idAllocatorState) {\n            const state = snapshot.idAllocatorState;\n            if (snapshot.format >= 3 && typeof state.generations === 'object' && !Array.isArray(state.generations)) {\n                // Minimal format - reconstruct full state\n                this.world.idAllocator.reset();\n                this.world.idAllocator.setNextId(state.nextIndex);\n                // Set generations for active entities\n                for (const [indexStr, gen] of Object.entries(state.generations)) {\n                    const index = parseInt(indexStr, 10);\n                    (this.world.idAllocator as any).generations[index] = gen;\n                }\n                // Compute free list: indices from 0 to nextIndex that aren't in active generations\n                const freeList: number[] = [];\n                for (let i = 0; i < state.nextIndex; i++) {\n                    if (!(i.toString() in state.generations)) {\n                        freeList.push(i);\n                    }\n                }\n                (this.world.idAllocator as any).freeList = freeList;\n            } else {\n                // Legacy full format\n                this.world.idAllocator.setState(state);\n            }\n        }\n\n        // Track which clients already have entities from the snapshot\n        // This prevents duplicate entity creation during catchup\n        this.clientsWithEntitiesFromSnapshot.clear();\n        for (const entity of this.world.query(Player)) {\n            const player = entity.get(Player);\n            if (player.clientId !== 0) {\n                const clientIdStr = this.getClientIdString(player.clientId);\n                if (clientIdStr) {\n                    this.clientsWithEntitiesFromSnapshot.add(clientIdStr);\n                    if (DEBUG_NETWORK) {\n                        console.log(`[ecs] Snapshot has entity for client ${clientIdStr.slice(0, 8)}`);\n                    }\n                }\n            }\n        }\n\n        // CRITICAL: Wake all physics bodies after snapshot restore\n        // Without this, late joiners have awake bodies while existing clients may have\n        // sleeping bodies, causing physics simulation divergence after catchup\n        if (this.physics) {\n            this.physics.wakeAllBodies();\n        }\n\n        // CRITICAL: Restore input state so movement systems behave identically\n        // Without this, systems that check `game.world.getInput(clientId)` won't find\n        // the last input, causing movement to stop on late joiners while authority continues\n        if (snapshot.inputState) {\n            this.world.setInputState(snapshot.inputState);\n        }\n\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Snapshot loaded: ${this.world.getAllEntities().length} entities, hash=${this.getStateHash()}`);\n            // Debug: log first restored entity\n            const firstEntity = this.world.getAllEntities()[0];\n            if (firstEntity) {\n                const components: Record<string, Record<string, any>> = {};\n                for (const comp of firstEntity.getComponents()) {\n                    const data: Record<string, any> = {};\n                    for (const fieldName of comp.fieldNames) {\n                        data[fieldName] = (firstEntity.get(comp) as any)[fieldName];\n                    }\n                    components[comp.name] = data;\n                }\n                console.log(`[ecs] Restored first entity: type=${firstEntity.type}, components=`, JSON.stringify(components));\n            }\n        }\n    }\n\n    /**\n     * Send snapshot to network.\n     */\n    private sendSnapshot(source: string): void {\n        if (!this.connection) return;\n\n        // CRITICAL: Wake all physics bodies when sending snapshot\n        // This ensures the authority's bodies are in the same state as the late joiner's\n        // bodies will be after they restore and wake. Without this, authority has sleeping\n        // bodies while late joiner has awake bodies, causing physics divergence.\n        if (this.physics) {\n            this.physics.wakeAllBodies();\n        }\n\n        const snapshot = this.getNetworkSnapshot();\n        const hash = this.world.getStateHash();\n        const binary = encode({ snapshot, hash });\n\n        // DEBUG: Log snapshot size breakdown\n        const entitiesSize = encode(snapshot.entities).length;\n        const schemaSize = encode(snapshot.schema).length;\n        const entityCount = snapshot.entities.length;\n        console.log(`[SNAPSHOT-SIZE] Total: ${binary.length}B | entities: ${entitiesSize}B (${entityCount}) | schema: ${schemaSize}B`);\n\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Sending snapshot (${source}): ${binary.length} bytes, ${entityCount} entities, hash=${hash}`);\n        }\n\n        this.connection.sendSnapshot(binary, hash, snapshot.seq, snapshot.frame);\n\n        // Update debug UI tracking - show last SENT snapshot for authority\n        this.lastSnapshotHash = hash;\n        this.lastSnapshotFrame = snapshot.frame;\n        this.lastSnapshotSize = binary.length;\n        this.lastSnapshotEntityCount = entityCount;\n    }\n\n    /**\n     * Handle server snapshot (for drift detection).\n     */\n    private handleServerSnapshot(data: Uint8Array): void {\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Received server snapshot: ${data.length} bytes`);\n        }\n\n        // Decode and compare for drift detection\n        try {\n            const decoded = decode(data);\n            const serverSnapshot = decoded?.snapshot;\n            const serverHash = decoded?.hash;\n\n            if (serverSnapshot) {\n                this.lastSnapshotHash = serverHash;\n                this.lastSnapshotFrame = serverSnapshot.frame;\n                this.lastSnapshotSize = data.length;\n                this.lastSnapshotEntityCount = serverSnapshot.entities?.length || 0;\n\n                // Only compare if frames match - otherwise comparison is meaningless\n                if (this.currentFrame === serverSnapshot.frame) {\n                    // Field-by-field comparison for drift stats\n                    this.compareSnapshotFields(serverSnapshot);\n\n                    // Compare hashes\n                    const localHash = this.getStateHash();\n                    if (localHash !== serverHash) {\n                        console.warn(`[ecs] DRIFT detected at frame ${serverSnapshot.frame}: local=${localHash}, server=${serverHash}`);\n                    }\n                } else {\n                    // Frames don't match - skip comparison (would give false positives)\n                    // Keep existing drift stats - don't reset to 100% as that hides real divergence\n                    if (DEBUG_NETWORK) {\n                        console.log(`[ecs] Snapshot frame ${serverSnapshot.frame} != current ${this.currentFrame}, skipping comparison`);\n                    }\n                }\n            }\n        } catch (e) {\n            console.warn('[ecs] Failed to decode server snapshot:', e);\n        }\n    }\n\n    /**\n     * Compare server snapshot fields with local state for drift tracking.\n     */\n    private compareSnapshotFields(serverSnapshot: any): void {\n        let matchingFields = 0;\n        let totalFields = 0;\n        const diffs: string[] = [];\n\n        const types = serverSnapshot.types || [];\n        const serverEntities = serverSnapshot.entities || [];\n        const schema = serverSnapshot.schema || [];\n\n        // Build map of server entities by eid (numeric)\n        const serverEntityMap = new Map<number, any>();\n        for (const e of serverEntities) {\n            serverEntityMap.set(e[0], e);\n        }\n\n        // Compare each local entity with server entity\n        for (const entity of this.world.getAllEntities()) {\n            const eid = entity.eid;\n            const serverEntity = serverEntityMap.get(eid);\n            const index = eid & INDEX_MASK;\n\n            if (!serverEntity) {\n                for (const comp of entity.getComponents()) {\n                    totalFields += comp.fieldNames.length;\n                }\n                if (diffs.length < 10) {\n                    diffs.push(`Entity ${eid.toString(16)} (${entity.type}) exists locally but not on server`);\n                }\n                continue;\n            }\n\n            const [, typeIndex, serverValues] = serverEntity;\n            const serverType = types[typeIndex];\n            const typeSchema = schema[typeIndex];\n\n            if (!typeSchema) {\n                // No schema for this type - can't compare\n                continue;\n            }\n\n            // Build index into serverValues based on schema\n            let valueIdx = 0;\n            for (const [compName, fieldNames] of typeSchema) {\n                // Find matching local component\n                const localComp = entity.getComponents().find(c => c.name === compName);\n\n                for (const fieldName of fieldNames) {\n                    totalFields++;\n                    const serverValue = serverValues[valueIdx++];\n\n                    if (localComp) {\n                        const localValue = localComp.storage.fields[fieldName][index];\n                        const fieldDef = localComp.schema[fieldName];\n\n                        let valuesMatch = false;\n                        if (fieldDef?.type === 'bool') {\n                            // Booleans: local is 0/1, server is true/false or 0/1\n                            const localBool = localValue !== 0;\n                            const serverBool = serverValue !== 0 && serverValue !== false;\n                            valuesMatch = localBool === serverBool;\n                        } else {\n                            valuesMatch = localValue === serverValue;\n                        }\n\n                        if (valuesMatch) {\n                            matchingFields++;\n                        } else if (diffs.length < 10) {\n                            diffs.push(`${entity.type}.${compName}.${fieldName}: local=${localValue}, server=${serverValue}`);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Count server entities not in local state\n        for (const [eid, serverEntity] of serverEntityMap) {\n            if (this.world.getEntity(eid) === null) {\n                const [, typeIndex, serverValues] = serverEntity;\n                const serverType = types[typeIndex] || `type${typeIndex}`;\n                totalFields += serverValues.length;\n                if (diffs.length < 10) {\n                    diffs.push(`Entity ${eid.toString(16)} (${serverType}) exists on server but not locally`);\n                }\n            }\n        }\n\n        // Update drift stats\n        this.driftStats.totalChecks++;\n        this.driftStats.matchingFieldCount = matchingFields;\n        this.driftStats.totalFieldCount = totalFields;\n        this.driftStats.determinismPercent = totalFields > 0\n            ? (matchingFields / totalFields) * 100\n            : 100;\n\n        // Log diffs if sync is not 100%\n        if (diffs.length > 0 && this.driftStats.determinismPercent < 100) {\n            console.warn(`[ecs] Sync ${matchingFields}/${totalFields} (${this.driftStats.determinismPercent.toFixed(1)}%):`);\n            for (const diff of diffs) {\n                console.warn(`  - ${diff}`);\n            }\n        }\n    }\n\n    // ==========================================\n    // Game Loop\n    // ==========================================\n\n    /**\n     * Start the render loop.\n     */\n    private startGameLoop(): void {\n        if (this.gameLoop) return;\n\n        let lastSnapshotFrame = 0;\n        const SNAPSHOT_INTERVAL = 100; // Every 5 seconds at 20fps\n\n        const loop = () => {\n            // Render\n            if (this.renderer?.render) {\n                this.renderer.render();\n            } else if (this.callbacks.render) {\n                this.callbacks.render();\n            }\n\n            // Periodic snapshot upload (authority only)\n            if (this.checkIsAuthority() && this.currentFrame - lastSnapshotFrame >= SNAPSHOT_INTERVAL) {\n                this.sendSnapshot('loop');\n                lastSnapshotFrame = this.currentFrame;\n            }\n\n            this.gameLoop = requestAnimationFrame(loop);\n        };\n\n        this.gameLoop = requestAnimationFrame(loop);\n    }\n\n    /**\n     * Stop the render loop.\n     */\n    private stopGameLoop(): void {\n        if (this.gameLoop) {\n            cancelAnimationFrame(this.gameLoop);\n            this.gameLoop = null;\n        }\n    }\n\n    /**\n     * Handle disconnect.\n     */\n    private handleDisconnect(): void {\n        if (DEBUG_NETWORK) console.log('[ecs] Disconnected');\n        this.stopGameLoop();\n    }\n\n    // ==========================================\n    // Utility Methods\n    // ==========================================\n\n    /**\n     * Check if this client is the authority.\n     * Handles potential length mismatch between SDK and server client IDs.\n     */\n    checkIsAuthority(): boolean {\n        if (this.localClientIdStr === null || this.authorityClientId === null) {\n            return false;\n        }\n        // Server may send shorter client IDs, compare by prefix\n        const minLen = Math.min(this.localClientIdStr.length, this.authorityClientId.length);\n        return this.localClientIdStr.substring(0, minLen) === this.authorityClientId.substring(0, minLen);\n    }\n\n    /**\n     * Check if this client is the authority (public).\n     */\n    isAuthority(): boolean {\n        return this.checkIsAuthority();\n    }\n\n    /**\n     * Check if connected.\n     */\n    isConnected(): boolean {\n        return this.connection !== null;\n    }\n\n    /**\n     * Get current frame.\n     */\n    getFrame(): number {\n        return this.currentFrame;\n    }\n\n    /**\n     * Get server tick rate.\n     */\n    getServerFps(): number {\n        return this.serverFps;\n    }\n\n    /**\n     * Get render interpolation alpha (0-1).\n     */\n    getRenderAlpha(): number {\n        if (this.lastTickTime === 0) return 1;\n        const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n        const elapsed = now - this.lastTickTime;\n        return Math.min(elapsed / this.tickIntervalMs, 1.0);\n    }\n\n    /**\n     * Send input to network.\n     */\n    sendInput(input: any): void {\n        if (!this.connection) return;\n        const binary = encode(input);\n        this.connection.send(binary);\n    }\n\n    /**\n     * Leave current room.\n     */\n    leaveRoom(): void {\n        if (this.connection) {\n            this.connection.leaveRoom();\n            this.connection = null;\n            this.stopGameLoop();\n        }\n    }\n\n    /**\n     * Get local client ID.\n     */\n    get localClientId(): string | null {\n        return this.localClientIdStr;\n    }\n\n    /**\n     * Set local client ID.\n     */\n    setLocalClientId(clientId: string): void {\n        this.localClientIdStr = clientId;\n        const numId = this.internClientId(clientId);\n        this.world.localClientId = numId;\n    }\n\n    /**\n     * Get room ID.\n     */\n    getRoomId(): string | null {\n        return this.connectedRoomId;\n    }\n\n    /**\n     * Get last snapshot info.\n     */\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number } {\n        return {\n            hash: this.lastSnapshotHash,\n            frame: this.lastSnapshotFrame,\n            size: this.lastSnapshotSize,\n            entityCount: this.lastSnapshotEntityCount\n        };\n    }\n\n    /**\n     * Get connected clients.\n     */\n    getClients(): string[] {\n        return this.connectedClients;\n    }\n\n    /**\n     * Get client ID (for debug UI).\n     */\n    getClientId(): string | null {\n        return this.localClientIdStr;\n    }\n\n    /**\n     * Get node URL (for debug UI).\n     */\n    getNodeUrl(): string | null {\n        // Could be tracked from connection, for now return null\n        return null;\n    }\n\n    /**\n     * Get upload rate in bytes/second (for debug UI).\n     */\n    getUploadRate(): number {\n        return this.connection?.bandwidthOut || 0;\n    }\n\n    /**\n     * Get download rate in bytes/second (for debug UI).\n     */\n    getDownloadRate(): number {\n        return this.connection?.bandwidthIn || 0;\n    }\n\n    /**\n     * Get drift stats (for debug UI).\n     * Authority clients show 100% until they receive a comparison snapshot.\n     */\n    getDriftStats(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number } {\n        // If no snapshots have been compared yet, assume 100% sync\n        // Authority clients are the source of truth, so they're always \"in sync\"\n        if (this.driftStats.totalChecks === 0) {\n            const entityCount = this.world.getAllEntities().length;\n            // Estimate total fields from local entities if no comparison done yet\n            let estimatedFields = 0;\n            for (const entity of this.world.getAllEntities()) {\n                for (const comp of entity.getComponents()) {\n                    estimatedFields += comp.fieldNames.length;\n                }\n            }\n            return {\n                determinismPercent: 100,\n                totalChecks: 0,\n                matchingFieldCount: estimatedFields,\n                totalFieldCount: estimatedFields\n            };\n        }\n        return { ...this.driftStats };\n    }\n\n    /**\n     * Attach a renderer.\n     */\n    setRenderer(renderer: any): void {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Get canvas from attached renderer.\n     */\n    getCanvas(): HTMLCanvasElement | null {\n        return this.renderer?.element ?? null;\n    }\n}\n\n// ==========================================\n// GameEntityBuilder\n// ==========================================\n\n/**\n * Game-specific entity builder with fluent API.\n */\nexport class GameEntityBuilder {\n    private worldBuilder: EntityBuilder;\n    private inputCommandsDef: any = null;\n\n    constructor(\n        private game: Game,\n        private name: string\n    ) {\n        this.worldBuilder = game.world.defineEntity(name);\n    }\n\n    /**\n     * Add a component to the entity definition.\n     */\n    with<T extends Record<string, any>>(\n        component: ComponentType<T>,\n        defaults?: Partial<T>\n    ): this {\n        this.worldBuilder.with(component, defaults);\n        return this;\n    }\n\n    /**\n     * Define input commands for this entity type.\n     */\n    commands(def: any): this {\n        this.inputCommandsDef = def;\n        return this;\n    }\n\n    /**\n     * Specify which fields to sync in snapshots (field-level sync).\n     * Only the specified fields are included in network snapshots.\n     *\n     * Use this to reduce bandwidth by only syncing essential fields.\n     * Non-synced fields can be reconstructed via onRestore().\n     *\n     * @example\n     * game.defineEntity('snake-segment')\n     *     .with(Transform2D)\n     *     .with(Sprite)\n     *     .with(SnakeSegment)\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\n     *     .register();\n     */\n    syncOnly(fields: string[]): this {\n        this.worldBuilder._setSyncFields(fields);\n        return this;\n    }\n\n    /**\n     * Exclude all fields from syncing for this entity type.\n     * The entity will not be included in network snapshots at all.\n     *\n     * Use this for purely client-local entities like cameras, UI, or effects.\n     *\n     * @example\n     * game.defineEntity('local-camera')\n     *     .with(Camera2D)\n     *     .syncNone()\n     *     .register();\n     */\n    syncNone(): this {\n        this.worldBuilder._setSyncFields([]);\n        return this;\n    }\n\n    /**\n     * @deprecated Use syncOnly() instead for clarity\n     */\n    sync(fields: string[]): this {\n        return this.syncOnly(fields);\n    }\n\n    /**\n     * Set a callback to reconstruct non-synced fields after snapshot load.\n     * Called for each entity of this type after loading a snapshot.\n     *\n     * @example\n     * game.defineEntity('snake-segment')\n     *     .with(Transform2D)\n     *     .with(Sprite)\n     *     .with(SnakeSegment)\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\n     *     .onRestore((entity, game) => {\n     *         const owner = game.world.getEntityByClientId(entity.get(SnakeSegment).ownerId);\n     *         if (owner) {\n     *             entity.get(Sprite).color = owner.get(Sprite).color;\n     *             entity.get(Sprite).radius = SEGMENT_RADIUS;\n     *         }\n     *     })\n     *     .register();\n     */\n    onRestore(callback: (entity: Entity, game: Game) => void): this {\n        this.worldBuilder._setOnRestore(callback);\n        return this;\n    }\n\n    /**\n     * Finalize and register the entity definition.\n     */\n    register(): Prefab {\n        this.worldBuilder._ensureRegistered();\n        return this.game._registerPrefab(this.name, this.worldBuilder);\n    }\n}\n\n// ==========================================\n// Factory Function\n// ==========================================\n\n/**\n * Initialize a new game instance.\n */\nexport function createGame(): Game {\n    return new Game();\n}\n", "/**\n * Simple2DRenderer - Basic 2D canvas renderer for entities with Sprite component\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Sprite, Camera2D, SHAPE_RECT, SHAPE_CIRCLE, SPRITE_IMAGE } from '../components';\n\nexport interface Simple2DRendererOptions {\n    /** Background color (default: '#111') */\n    background?: string;\n    /** Whether to clear canvas each frame (default: true) */\n    autoClear?: boolean;\n}\n\n/**\n * Simple 2D renderer that draws all entities with Sprite component.\n *\n * Can be used as a plugin via game.addPlugin() or standalone.\n *\n * @example\n * // Plugin pattern (recommended)\n * game.addPlugin(Simple2DRenderer, canvas);\n *\n * // Standalone pattern\n * new Simple2DRenderer(game, canvas);\n */\nexport class Simple2DRenderer {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    private game: Game;\n    private options: Required<Simple2DRendererOptions>;\n    private imageCache: Map<string, HTMLImageElement> = new Map();\n    private _cameraEntity: Entity | null = null;\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string, options: Simple2DRendererOptions = {}) {\n        this.game = game;\n\n        // Accept either element or selector\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) throw new Error('Could not get 2d context');\n        this.ctx = ctx;\n\n        this.options = {\n            background: options.background ?? '#111',\n            autoClear: options.autoClear ?? true\n        };\n\n        // Attach to game\n        game.setRenderer(this);\n    }\n\n    /** Canvas width */\n    get width(): number { return this.canvas.width; }\n\n    /** Canvas height */\n    get height(): number { return this.canvas.height; }\n\n    /** The canvas element */\n    get element(): HTMLCanvasElement { return this.canvas; }\n\n    /** The 2D context (for custom drawing) */\n    get context(): CanvasRenderingContext2D { return this.ctx; }\n\n    /**\n     * Set the camera entity to use for rendering.\n     * When set, the renderer will apply camera transform (position, zoom).\n     */\n    set camera(entity: Entity | null) {\n        this._cameraEntity = entity;\n        if (entity) {\n            // Update viewport size in camera component\n            try {\n                const cam = entity.get(Camera2D);\n                cam.viewportWidth = this.canvas.width;\n                cam.viewportHeight = this.canvas.height;\n            } catch {\n                // Entity doesn't have Camera2D\n            }\n        }\n    }\n\n    get camera(): Entity | null {\n        return this._cameraEntity;\n    }\n\n    /**\n     * Render all entities with Sprite component.\n     */\n    render(): void {\n        const { ctx, canvas, options, game } = this;\n\n        // Clear\n        if (options.autoClear) {\n            ctx.fillStyle = options.background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Get interpolation alpha (0-1 between physics ticks)\n        const alpha = game.getRenderAlpha();\n\n        // Get camera data if available\n        let camX = 0, camY = 0, camZoom = 1;\n        if (this._cameraEntity && !this._cameraEntity.destroyed) {\n            try {\n                const cam = this._cameraEntity.get(Camera2D);\n                camX = cam.x;\n                camY = cam.y;\n                camZoom = cam.zoom;\n\n                // Update viewport size in case canvas was resized\n                cam.viewportWidth = canvas.width;\n                cam.viewportHeight = canvas.height;\n            } catch {\n                // Camera entity doesn't have Camera2D\n            }\n        }\n\n        // Collect entities with Sprite, sorted by layer\n        const entities: Array<{ entity: any; layer: number }> = [];\n\n        for (const entity of game.getAllEntities()) {\n            // Skip destroyed entities\n            if (entity.destroyed) continue;\n\n            try {\n                const sprite = entity.get(Sprite);\n                if (sprite && sprite.visible) {\n                    // Calculate interpolated position for smooth rendering\n                    entity.interpolate(alpha);\n                    entities.push({ entity, layer: sprite.layer });\n                }\n            } catch {\n                // Entity doesn't have Sprite\n            }\n        }\n\n        // Sort by layer (lower first)\n        entities.sort((a, b) => a.layer - b.layer);\n\n        // Apply camera transform\n        ctx.save();\n        ctx.translate(canvas.width / 2, canvas.height / 2);\n        ctx.scale(camZoom, camZoom);\n        ctx.translate(-camX, -camY);\n\n        // Draw each entity\n        for (const { entity } of entities) {\n            this.drawEntity(entity);\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Draw a single entity.\n     */\n    private drawEntity(entity: any): void {\n        const { ctx, game } = this;\n\n        const sprite = entity.get(Sprite);\n\n        // Use interpolated position for smooth rendering between physics ticks\n        const x = entity.render.interpX + sprite.offsetX;\n        const y = entity.render.interpY + sprite.offsetY;\n        const scaleX = sprite.scaleX;\n        const scaleY = sprite.scaleY;\n\n        // Get color string\n        const colorStr = game.getString('color', sprite.color) || '#fff';\n\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.scale(scaleX, scaleY);\n\n        const shape = sprite.shape;\n\n        if (shape === SHAPE_CIRCLE) {\n            const radius = sprite.radius;\n            ctx.fillStyle = colorStr;\n            ctx.beginPath();\n            ctx.arc(0, 0, radius, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (shape === SHAPE_RECT) {\n            const w = sprite.width;\n            const h = sprite.height;\n            ctx.fillStyle = colorStr;\n            ctx.fillRect(-w / 2, -h / 2, w, h);\n        } else if (shape === SPRITE_IMAGE) {\n            const imageId = game.getString('sprite', sprite.spriteId);\n            if (imageId) {\n                const img = this.getImage(imageId);\n                if (img && img.complete) {\n                    const w = sprite.width || img.width;\n                    const h = sprite.height || img.height;\n                    ctx.drawImage(img, -w / 2, -h / 2, w, h);\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Get or load an image.\n     */\n    private getImage(src: string): HTMLImageElement | null {\n        let img = this.imageCache.get(src);\n        if (!img) {\n            img = new Image();\n            img.src = src;\n            this.imageCache.set(src, img);\n        }\n        return img;\n    }\n\n    /**\n     * Preload images for faster rendering.\n     */\n    preload(images: string[]): Promise<void> {\n        return Promise.all(\n            images.map(src => new Promise<void>((resolve) => {\n                const img = this.getImage(src);\n                if (img?.complete) {\n                    resolve();\n                } else if (img) {\n                    img.onload = () => resolve();\n                    img.onerror = () => resolve();\n                }\n            }))\n        ).then(() => {});\n    }\n}\n", "/**\n * InputPlugin - Handles input collection and network sending\n *\n * Provides an action-based input system where:\n * - Game defines actions with default bindings\n * - Players can rebind actions to different keys\n * - Input is automatically sent to server at tick rate\n *\n * @example\n * const input = game.addPlugin(InputPlugin, canvas);\n *\n * input.action('move', { type: 'vector', bindings: ['keys:wasd+arrows'] });\n * input.action('boost', { type: 'button', bindings: ['key:shift'] });\n * input.action('target', { type: 'vector', bindings: ['mouse'] });\n *\n * // Player rebinds\n * input.rebind('boost', ['key:space']);\n *\n * // Save/load\n * localStorage.setItem('keybinds', JSON.stringify(input.getBindings()));\n * input.loadBindings(JSON.parse(localStorage.getItem('keybinds')));\n */\n\nimport { Game } from '../game';\n\n// Forward declaration to avoid circular import\ninterface GameLike {\n    isConnected(): boolean;\n    localClientId: string | null;\n    sendInput(input: any): void;\n    getServerFps(): number;\n}\n\n/** Action types */\nexport type ActionType = 'button' | 'vector';\n\n/** Binding source - string shorthand or custom callback */\nexport type BindingSource = string | (() => any);\n\n/** Action definition */\nexport interface ActionDef {\n    type: ActionType;\n    bindings: BindingSource[];\n}\n\n/** Vector value */\nexport interface Vec2 {\n    x: number;\n    y: number;\n}\n\n/**\n * InputPlugin - Action-based input system\n */\nexport class InputPlugin {\n    private game: GameLike;\n    private canvas: HTMLCanvasElement;\n\n    /** Action definitions */\n    private actions: Map<string, ActionDef> = new Map();\n\n    /** Current bindings (may differ from defaults after rebind) */\n    private bindings: Map<string, BindingSource[]> = new Map();\n\n    /** Raw input state */\n    private mousePos: Vec2 = { x: 0, y: 0 };\n    private keysDown: Set<string> = new Set();\n    private mouseButtons: Set<number> = new Set();\n\n    /** Send interval handle */\n    private sendInterval: number | null = null;\n\n    /** Last sent input (for deduplication) */\n    private lastSentInput: string = '';\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string) {\n        this.game = game;\n\n        // Resolve canvas\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        this.setupListeners();\n        this.startSendLoop();\n    }\n\n    /**\n     * Define an action with default bindings.\n     */\n    action(name: string, def: ActionDef): this {\n        this.actions.set(name, def);\n        // Set default bindings if not already rebound\n        if (!this.bindings.has(name)) {\n            this.bindings.set(name, [...def.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Rebind an action to new bindings.\n     */\n    rebind(name: string, bindings: BindingSource[]): this {\n        if (!this.actions.has(name)) {\n            console.warn(`[InputPlugin] Unknown action: ${name}`);\n            return this;\n        }\n        this.bindings.set(name, bindings);\n        return this;\n    }\n\n    /**\n     * Reset action to default bindings.\n     */\n    resetBinding(name: string): this {\n        const action = this.actions.get(name);\n        if (action) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Reset all bindings to defaults.\n     */\n    resetAllBindings(): this {\n        for (const [name, action] of this.actions) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Get current bindings for serialization.\n     * Only includes string bindings (callbacks can't be serialized).\n     */\n    getBindings(): Record<string, string[]> {\n        const result: Record<string, string[]> = {};\n        for (const [name, sources] of this.bindings) {\n            result[name] = sources.filter(s => typeof s === 'string') as string[];\n        }\n        return result;\n    }\n\n    /**\n     * Load bindings from serialized data.\n     */\n    loadBindings(data: Record<string, string[]>): this {\n        for (const [name, sources] of Object.entries(data)) {\n            if (this.actions.has(name)) {\n                this.bindings.set(name, sources);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Get current value of an action.\n     */\n    get(name: string): boolean | Vec2 | null {\n        const action = this.actions.get(name);\n        const sources = this.bindings.get(name);\n        if (!action || !sources) return null;\n\n        if (action.type === 'button') {\n            return this.resolveButton(sources);\n        } else {\n            return this.resolveVector(sources);\n        }\n    }\n\n    /**\n     * Get all action values as an object.\n     */\n    getAll(): Record<string, any> {\n        const result: Record<string, any> = {};\n        for (const name of this.actions.keys()) {\n            result[name] = this.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Resolve button value from sources (OR logic).\n     */\n    private resolveButton(sources: BindingSource[]): boolean {\n        for (const source of sources) {\n            if (typeof source === 'function') {\n                if (source()) return true;\n            } else if (this.resolveStringButton(source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve vector value from sources (additive, clamped).\n     */\n    private resolveVector(sources: BindingSource[]): Vec2 {\n        let x = 0, y = 0;\n\n        for (const source of sources) {\n            let vec: Vec2 | null = null;\n\n            if (typeof source === 'function') {\n                vec = source();\n            } else {\n                vec = this.resolveStringVector(source);\n            }\n\n            if (vec) {\n                x += vec.x;\n                y += vec.y;\n            }\n        }\n\n        // Clamp to -1..1 for direction vectors, but not for mouse position\n        // We detect mouse by checking if values are large\n        if (Math.abs(x) <= 1 && Math.abs(y) <= 1) {\n            const len = Math.sqrt(x * x + y * y);\n            if (len > 1) {\n                x /= len;\n                y /= len;\n            }\n        }\n\n        return { x, y };\n    }\n\n    /**\n     * Resolve a string binding to button value.\n     */\n    private resolveStringButton(source: string): boolean {\n        // key:X - single key\n        if (source.startsWith('key:')) {\n            const key = source.slice(4).toLowerCase();\n            return this.keysDown.has(key);\n        }\n\n        // mouse:left, mouse:right, mouse:middle\n        if (source.startsWith('mouse:')) {\n            const button = source.slice(6);\n            if (button === 'left') return this.mouseButtons.has(0);\n            if (button === 'right') return this.mouseButtons.has(2);\n            if (button === 'middle') return this.mouseButtons.has(1);\n        }\n\n        return false;\n    }\n\n    /**\n     * Resolve a string binding to vector value.\n     */\n    private resolveStringVector(source: string): Vec2 | null {\n        // mouse - current position\n        if (source === 'mouse') {\n            return { ...this.mousePos };\n        }\n\n        // keys:wasd\n        if (source === 'keys:wasd') {\n            return this.getWASD();\n        }\n\n        // keys:arrows\n        if (source === 'keys:arrows') {\n            return this.getArrows();\n        }\n\n        // keys:wasd+arrows\n        if (source === 'keys:wasd+arrows') {\n            const wasd = this.getWASD();\n            const arrows = this.getArrows();\n            return {\n                x: Math.max(-1, Math.min(1, wasd.x + arrows.x)),\n                y: Math.max(-1, Math.min(1, wasd.y + arrows.y))\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Get WASD direction.\n     */\n    private getWASD(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('a')) x -= 1;\n        if (this.keysDown.has('d')) x += 1;\n        if (this.keysDown.has('w')) y -= 1;\n        if (this.keysDown.has('s')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Get arrow keys direction.\n     */\n    private getArrows(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('arrowleft')) x -= 1;\n        if (this.keysDown.has('arrowright')) x += 1;\n        if (this.keysDown.has('arrowup')) y -= 1;\n        if (this.keysDown.has('arrowdown')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Set up event listeners.\n     */\n    private setupListeners(): void {\n        // Mouse move\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            this.mousePos.x = e.clientX - rect.left;\n            this.mousePos.y = e.clientY - rect.top;\n        });\n\n        // Mouse buttons\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.mouseButtons.add(e.button);\n        });\n\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.mouseButtons.delete(e.button);\n        });\n\n        // Keyboard - use window to catch all keys\n        window.addEventListener('keydown', (e) => {\n            this.keysDown.add(e.key.toLowerCase());\n        });\n\n        window.addEventListener('keyup', (e) => {\n            this.keysDown.delete(e.key.toLowerCase());\n        });\n\n        // Clear keys on blur (prevent stuck keys)\n        window.addEventListener('blur', () => {\n            this.keysDown.clear();\n            this.mouseButtons.clear();\n        });\n    }\n\n    /**\n     * Start the send loop.\n     */\n    private startSendLoop(): void {\n        // Send at server tick rate (default 50ms = 20fps)\n        const sendRate = 1000 / (this.game.getServerFps?.() || 20);\n\n        this.sendInterval = window.setInterval(() => {\n            if (this.game.isConnected() && this.game.localClientId && this.actions.size > 0) {\n                const input = this.getAll();\n                // Only send if input changed (deduplication to save bandwidth)\n                const inputStr = this.inputToString(input);\n                if (inputStr !== this.lastSentInput) {\n                    this.lastSentInput = inputStr;\n                    this.game.sendInput(input);\n                }\n            }\n        }, sendRate);\n    }\n\n    /**\n     * Convert input to string for comparison.\n     * Uses rounding for vectors to avoid sending tiny mouse movements.\n     */\n    private inputToString(input: Record<string, any>): string {\n        const normalized: Record<string, any> = {};\n        for (const [key, value] of Object.entries(input)) {\n            if (value && typeof value === 'object' && 'x' in value && 'y' in value) {\n                // Round vectors to avoid sending tiny movements\n                normalized[key] = { x: Math.round(value.x / 10) * 10, y: Math.round(value.y / 10) * 10 };\n            } else {\n                normalized[key] = value;\n            }\n        }\n        return JSON.stringify(normalized);\n    }\n\n    /**\n     * Stop the send loop.\n     */\n    destroy(): void {\n        if (this.sendInterval !== null) {\n            clearInterval(this.sendInterval);\n            this.sendInterval = null;\n        }\n    }\n}\n", "/**\r\n * Determinism Guard\r\n *\r\n * Warns developers when non-deterministic functions are called during simulation.\r\n * Suggests deterministic alternatives like dRandom() and dSqrt().\r\n */\r\n\r\nimport type { Game } from '../game';\r\n\r\ninterface OriginalFunctions {\r\n    mathRandom?: typeof Math.random;\r\n    mathSqrt?: typeof Math.sqrt;\r\n    dateNow?: typeof Date.now;\r\n    performanceNow?: typeof performance.now;\r\n}\r\n\r\nconst originalFunctions: OriginalFunctions = {};\r\nlet installedGame: Game | null = null;\r\nlet warnedFunctions: Set<string> = new Set();\r\n\r\nfunction isSimulating(): boolean {\r\n    return installedGame?.world?._isSimulating ?? false;\r\n}\r\n\r\nfunction warnOnce(key: string, message: string) {\r\n    if (!warnedFunctions.has(key)) {\r\n        warnedFunctions.add(key);\r\n        console.warn(message);\r\n    }\r\n}\r\n\r\n/**\r\n * Enable determinism guard for a game instance.\r\n * Warns when dangerous functions are called during simulation.\r\n *\r\n * @example\r\n * const game = createGame();\r\n * enableDeterminismGuard(game);\r\n */\r\nexport function enableDeterminismGuard(game: Game): void {\r\n    if (installedGame) {\r\n        console.warn('Determinism guard already installed for another game instance');\r\n        return;\r\n    }\r\n\r\n    installedGame = game;\r\n    warnedFunctions.clear();\r\n\r\n    // Intercept Math.random\r\n    originalFunctions.mathRandom = Math.random;\r\n    Math.random = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.random',\r\n                '\u26A0\uFE0F Math.random() is non-deterministic!\\n' +\r\n                '   Use dRandom() instead for deterministic random numbers.\\n' +\r\n                '   Example: const r = dRandom();'\r\n            );\r\n        }\r\n        return originalFunctions.mathRandom!();\r\n    };\r\n\r\n    // Intercept Math.sqrt\r\n    originalFunctions.mathSqrt = Math.sqrt;\r\n    Math.sqrt = function(x: number): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.sqrt',\r\n                '\u26A0\uFE0F Math.sqrt() is non-deterministic!\\n' +\r\n                '   Use dSqrt() instead for deterministic square root.\\n' +\r\n                '   Example: const dist = dSqrt(dx * dx + dy * dy);'\r\n            );\r\n        }\r\n        return originalFunctions.mathSqrt!(x);\r\n    };\r\n\r\n    // Intercept Date.now\r\n    originalFunctions.dateNow = Date.now;\r\n    Date.now = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Date.now',\r\n                '\u26A0\uFE0F Date.now() is non-deterministic!\\n' +\r\n                '   Use game.time instead for deterministic timing.\\n' +\r\n                '   Example: const respawnAt = game.time + 3000;'\r\n            );\r\n        }\r\n        return originalFunctions.dateNow!();\r\n    };\r\n\r\n    // Intercept performance.now\r\n    if (typeof performance !== 'undefined') {\r\n        originalFunctions.performanceNow = performance.now.bind(performance);\r\n        performance.now = function(): number {\r\n            if (isSimulating()) {\r\n                warnOnce('performance.now',\r\n                    '\u26A0\uFE0F performance.now() is non-deterministic!\\n' +\r\n                    '   Use game.time instead for deterministic timing.'\r\n                );\r\n            }\r\n            return originalFunctions.performanceNow!();\r\n        };\r\n    }\r\n\r\n    console.log('\uD83D\uDEE1\uFE0F Determinism guard enabled');\r\n}\r\n\r\n/**\r\n * Disable determinism guard and restore original functions.\r\n */\r\nexport function disableDeterminismGuard(): void {\r\n    if (originalFunctions.mathRandom) {\r\n        Math.random = originalFunctions.mathRandom;\r\n    }\r\n    if (originalFunctions.mathSqrt) {\r\n        Math.sqrt = originalFunctions.mathSqrt;\r\n    }\r\n    if (originalFunctions.dateNow) {\r\n        Date.now = originalFunctions.dateNow;\r\n    }\r\n    if (originalFunctions.performanceNow && typeof performance !== 'undefined') {\r\n        performance.now = originalFunctions.performanceNow;\r\n    }\r\n\r\n    installedGame = null;\r\n    warnedFunctions.clear();\r\n\r\n    // Clear stored references\r\n    Object.keys(originalFunctions).forEach(key => {\r\n        delete (originalFunctions as any)[key];\r\n    });\r\n}\r\n", "/**\r\n * Debug UI - Simple stats overlay for game instances\r\n *\r\n * Usage:\r\n *   Modu.enableDebugUI(game);  // Pass game instance\r\n *   Modu.setDebugHash(() => computeMyHash()); // Optional: show live state hash\r\n *\r\n * Also enables determinism guard to warn about non-deterministic function calls.\r\n */\r\n\r\nimport { enableDeterminismGuard } from './determinism-guard';\r\nimport type { Game } from '../game';\r\n\r\n/** Interface for objects that can be displayed in debug UI */\r\nexport interface DebugUITarget {\r\n    getClientId(): string | null;\r\n    getFrame(): number;\r\n    getNodeUrl(): string | null;\r\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number };\r\n    getServerFps(): number;\r\n    getRoomId(): string | null;\r\n    getUploadRate(): number;\r\n    getDownloadRate(): number;\r\n    getClients(): string[];\r\n    getStateHash(): string;\r\n    isAuthority?(): boolean;\r\n    getDriftStats?(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number };\r\n}\r\n\r\nexport interface DebugUIOptions {\r\n    /** Position: 'top-right' (default), 'top-left', 'bottom-right', 'bottom-left' */\r\n    position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\r\n}\r\n\r\nlet debugDiv: HTMLDivElement | null = null;\r\nlet updateInterval: number | null = null;\r\nlet hashCallback: (() => string | number) | null = null;\r\nlet debugTarget: DebugUITarget | null = null;\r\n\r\n// FPS tracking\r\nlet lastFrameTime = 0;\r\nlet frameCount = 0;\r\nlet renderFps = 0;\r\nlet fpsUpdateTime = 0;\r\n\r\n/**\r\n * Set a callback to compute the current state hash for debug display.\r\n * The hash will be shown in the debug UI and should change as bodies move.\r\n */\r\nexport function setDebugHash(callback: () => string | number): void {\r\n    hashCallback = callback;\r\n}\r\n\r\n/**\r\n * Enable debug UI overlay - shows frame, client, node, snapshot info automatically\r\n * @param target - Object implementing DebugUITarget interface\r\n * @param options - UI options\r\n */\r\nexport function enableDebugUI(target?: DebugUITarget, options: DebugUIOptions = {}): HTMLDivElement {\r\n    if (debugDiv) return debugDiv;\r\n\r\n    // Store target reference for updates\r\n    debugTarget = target || null;\r\n\r\n    // Enable determinism guard if target is a Game instance\r\n    if (target && 'world' in target) {\r\n        enableDeterminismGuard(target as unknown as Game);\r\n    }\r\n\r\n    const pos = options.position || 'top-right';\r\n\r\n    debugDiv = document.createElement('div');\r\n    debugDiv.id = 'modu-debug-ui';\r\n    debugDiv.style.cssText = `\r\n        position: fixed;\r\n        ${pos.includes('top') ? 'top: 10px' : 'bottom: 10px'};\r\n        ${pos.includes('right') ? 'right: 10px' : 'left: 10px'};\r\n        background: rgba(0, 0, 0, 0.8);\r\n        color: #0f0;\r\n        font: 12px monospace;\r\n        padding: 8px 12px;\r\n        border-radius: 4px;\r\n        z-index: 10000;\r\n        min-width: 180px;\r\n        pointer-events: none;\r\n    `;\r\n    document.body.appendChild(debugDiv);\r\n\r\n    // Update loop\r\n    const update = (now: number) => {\r\n        if (!debugDiv) return;\r\n\r\n        // Calculate render FPS\r\n        frameCount++;\r\n        if (now - fpsUpdateTime >= 1000) {\r\n            renderFps = frameCount;\r\n            frameCount = 0;\r\n            fpsUpdateTime = now;\r\n        }\r\n\r\n        const eng = debugTarget;\r\n        if (!eng) {\r\n            debugDiv.innerHTML = '<div style=\"color:#f00\">No engine instance</div>';\r\n            return;\r\n        }\r\n\r\n        const clientId = eng.getClientId();\r\n        const frame = eng.getFrame();\r\n        const nodeUrl = eng.getNodeUrl();\r\n        const lastSnap = eng.getLastSnapshot();\r\n        const fps = eng.getServerFps();\r\n        const roomId = eng.getRoomId();\r\n        const up = eng.getUploadRate();\r\n        const down = eng.getDownloadRate();\r\n        const clients = eng.getClients();\r\n        const isAuthority = (eng as any).isAuthority?.() || false;\r\n\r\n        // Compute live state hash (use custom callback if set, otherwise use engine's hash)\r\n        let currentHash = '--------';\r\n        try {\r\n            if (hashCallback) {\r\n                const hash = hashCallback();\r\n                currentHash = typeof hash === 'number' ? hash.toString(16).padStart(8, '0') : String(hash).slice(0, 8);\r\n            } else {\r\n                currentHash = eng.getStateHash();\r\n            }\r\n        } catch (e) {\r\n            currentHash = 'error';\r\n        }\r\n\r\n        // Format bandwidth with appropriate unit\r\n        const formatBandwidth = (bytes: number): string => {\r\n            if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' kB/s';\r\n            }\r\n            return Math.round(bytes) + ' B/s';\r\n        };\r\n        const upStr = formatBandwidth(up);\r\n        const downStr = formatBandwidth(down);\r\n\r\n        // Get drift stats (field-by-field comparison)\r\n        const driftStats = (eng as any).getDriftStats?.() || { determinismPercent: 100, totalChecks: 0, matchingFieldCount: 0, totalFieldCount: 0 };\r\n        const detPct = driftStats.determinismPercent.toFixed(1);\r\n        const detColor = driftStats.determinismPercent >= 99.9 ? '#0f0' :\r\n                        driftStats.determinismPercent >= 95 ? '#ff0' : '#f00';\r\n\r\n        // Format sync status\r\n        let syncStatus: string;\r\n        if (isAuthority) {\r\n            syncStatus = '<span style=\"color:#888\">I\\'m authority</span>';\r\n        } else if (driftStats.totalChecks === 0) {\r\n            syncStatus = '<span style=\"color:#888\">waiting...</span>';\r\n        } else {\r\n            syncStatus = `<span style=\"color:${detColor}\">${detPct}%</span> <span style=\"color:#888\">(${driftStats.matchingFieldCount}/${driftStats.totalFieldCount})</span>`;\r\n        }\r\n\r\n        // Format received snapshot info with frames ago\r\n        const framesAgo = lastSnap.frame ? frame - lastSnap.frame : 0;\r\n        const snapInfo = lastSnap.hash ? `${lastSnap.hash.slice(0, 8)} <span style=\"color:#888\">(${framesAgo} ago)</span>` : 'none';\r\n\r\n        // Format size with appropriate units\r\n        const formatSize = (bytes: number): string => {\r\n            if (bytes >= 1024 * 1024) {\r\n                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';\r\n            } else if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' KB';\r\n            }\r\n            return bytes + ' B';\r\n        };\r\n        const sizeStr = lastSnap.size > 0 ? formatSize(lastSnap.size) : '-';\r\n        const entityStr = lastSnap.entityCount > 0 ? String(lastSnap.entityCount) : '-';\r\n\r\n        // Section header style\r\n        const sectionStyle = 'color:#666;font-size:10px;margin-top:6px;margin-bottom:2px;border-bottom:1px solid #333;';\r\n\r\n        debugDiv.innerHTML = `\r\n            <div style=\"${sectionStyle}\">ROOM</div>\r\n            <div>ID: <span style=\"color:#fff\">${roomId || '-'}</span></div>\r\n            <div>Players: <span style=\"color:#ff0\">${clients.length}</span></div>\r\n            <div>Frame: <span style=\"color:#fff\">${frame}</span></div>\r\n            <div>URL: <span style=\"color:#0ff\">${nodeUrl || '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ME</div>\r\n            <div>Authority: <span style=\"color:${isAuthority ? '#0ff' : '#888'}\">${isAuthority ? 'Yes' : 'No'}</span></div>\r\n            <div>Client: <span style=\"color:#ff0\">${clientId ? clientId.slice(0, 8) : '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ENGINE</div>\r\n            <div>FPS: <span style=\"color:#0f0\">${renderFps}</span> render, <span style=\"color:#0f0\">${fps}</span> tick</div>\r\n            <div>Net: <span style=\"color:#0f0\">${upStr}</span> up, <span style=\"color:#f80\">${downStr}</span> down</div>\r\n\r\n            <div style=\"${sectionStyle}\">SNAPSHOT</div>\r\n            <div>Current: <span style=\"color:#f0f\">${currentHash}</span></div>\r\n            <div>Received: <span style=\"color:#f80\">${snapInfo}</span></div>\r\n            <div>Size: <span style=\"color:#fff\">${sizeStr}</span>, Entities: <span style=\"color:#fff\">${entityStr}</span></div>\r\n            <div>Last Sync: ${syncStatus}</div>\r\n        `;\r\n    };\r\n\r\n    // Update every frame\r\n    const loop = (now: number) => {\r\n        update(now);\r\n        updateInterval = requestAnimationFrame(loop) as unknown as number;\r\n    };\r\n    fpsUpdateTime = performance.now();\r\n    requestAnimationFrame(loop);\r\n\r\n    return debugDiv;\r\n}\r\n\r\n/**\r\n * Disable debug UI\r\n */\r\nexport function disableDebugUI(): void {\r\n    if (updateInterval) {\r\n        cancelAnimationFrame(updateInterval);\r\n        updateInterval = null;\r\n    }\r\n    if (debugDiv) {\r\n        debugDiv.remove();\r\n        debugDiv = null;\r\n    }\r\n    debugTarget = null;\r\n}\r\n\r\n/**\r\n * Check if debug UI is enabled\r\n */\r\nexport function isDebugUIEnabled(): boolean {\r\n    return debugDiv !== null;\r\n}\r\n", "/**\r\n * 2D Physics Shapes\r\n *\r\n * Defines 2D collision shapes: Circle and Box (AABB).\r\n * Uses fixed-point math for determinism.\r\n */\r\n\r\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpMin, fpMax } from '../../math/fixed';\r\n\r\n// ============================================\r\n// Types\r\n// ============================================\r\n\r\nexport enum Shape2DType {\r\n    Circle = 0,\r\n    Box = 1,\r\n}\r\n\r\nexport interface CircleShape {\r\n    type: Shape2DType.Circle;\r\n    radius: Fixed;\r\n}\r\n\r\nexport interface BoxShape2D {\r\n    type: Shape2DType.Box;\r\n    halfWidth: Fixed;   // Half extent on X axis\r\n    halfHeight: Fixed;  // Half extent on Y axis\r\n}\r\n\r\nexport type Shape2D = CircleShape | BoxShape2D;\r\n\r\n// ============================================\r\n// AABB (Axis-Aligned Bounding Box)\r\n// ============================================\r\n\r\nexport interface AABB2D {\r\n    minX: Fixed;\r\n    minY: Fixed;\r\n    maxX: Fixed;\r\n    maxY: Fixed;\r\n}\r\n\r\n/**\r\n * Check if two AABBs overlap.\r\n */\r\nexport function aabb2DOverlap(a: AABB2D, b: AABB2D): boolean {\r\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\r\n           a.minY <= b.maxY && a.maxY >= b.minY;\r\n}\r\n\r\n/**\r\n * Compute the union of two AABBs.\r\n */\r\nexport function aabb2DUnion(a: AABB2D, b: AABB2D): AABB2D {\r\n    return {\r\n        minX: fpMin(a.minX, b.minX),\r\n        minY: fpMin(a.minY, b.minY),\r\n        maxX: fpMax(a.maxX, b.maxX),\r\n        maxY: fpMax(a.maxY, b.maxY),\r\n    };\r\n}\r\n\r\n/**\r\n * Compute the area of an AABB.\r\n */\r\nexport function aabb2DArea(aabb: AABB2D): Fixed {\r\n    const width = aabb.maxX - aabb.minX;\r\n    const height = aabb.maxY - aabb.minY;\r\n    return fpMul(width as Fixed, height as Fixed);\r\n}\r\n\r\n// ============================================\r\n// Shape Factories\r\n// ============================================\r\n\r\n/**\r\n * Create a circle shape.\r\n */\r\nexport function createCircle(radius: number): CircleShape {\r\n    return {\r\n        type: Shape2DType.Circle,\r\n        radius: toFixed(radius),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from half-extents.\r\n */\r\nexport function createBox2D(halfWidth: number, halfHeight: number): BoxShape2D {\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth: toFixed(halfWidth),\r\n        halfHeight: toFixed(halfHeight),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from full dimensions.\r\n * Uses bit shift for deterministic halving.\r\n */\r\nexport function createBox2DFromSize(width: number, height: number): BoxShape2D {\r\n    // Use bit shift instead of floating-point division for determinism\r\n    const halfWidth = (toFixed(width) >> 1) as Fixed;\r\n    const halfHeight = (toFixed(height) >> 1) as Fixed;\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth,\r\n        halfHeight,\r\n    };\r\n}\r\n", "/**\r\n * Collision Layers\r\n *\r\n * Controls which bodies can collide with each other using bitmasks.\r\n * Layer = \"what am I\", Mask = \"what do I collide with\"\r\n *\r\n * Shared between 2D and 3D physics engines.\r\n */\r\n\r\n// ============================================\r\n// Collision Filter\r\n// ============================================\r\n\r\nexport interface CollisionFilter {\r\n    /** Which layer this body belongs to (single bit) */\r\n    layer: number;\r\n    /** Which layers this body collides with (bitmask) */\r\n    mask: number;\r\n}\r\n\r\n// ============================================\r\n// Default Layers\r\n// ============================================\r\n\r\nexport const Layers = {\r\n    NONE: 0,\r\n    DEFAULT: 1 << 0,      // 1\r\n    PLAYER: 1 << 1,       // 2\r\n    ENEMY: 1 << 2,        // 4\r\n    PROJECTILE: 1 << 3,   // 8\r\n    ITEM: 1 << 4,         // 16\r\n    TRIGGER: 1 << 5,      // 32\r\n    WORLD: 1 << 6,        // 64\r\n    PROP: 1 << 7,         // 128\r\n    // Layers 8-15 reserved for game-specific use\r\n    CUSTOM_1: 1 << 8,\r\n    CUSTOM_2: 1 << 9,\r\n    CUSTOM_3: 1 << 10,\r\n    CUSTOM_4: 1 << 11,\r\n    CUSTOM_5: 1 << 12,\r\n    CUSTOM_6: 1 << 13,\r\n    CUSTOM_7: 1 << 14,\r\n    CUSTOM_8: 1 << 15,\r\n    ALL: 0xFFFF           // All layers\r\n} as const;\r\n\r\n// ============================================\r\n// Default Filter\r\n// ============================================\r\n\r\n/**\r\n * Default collision filter - collides with everything\r\n */\r\nexport const DEFAULT_FILTER: CollisionFilter = {\r\n    layer: Layers.DEFAULT,\r\n    mask: Layers.ALL\r\n};\r\n\r\n// ============================================\r\n// Filter Helpers\r\n// ============================================\r\n\r\n/**\r\n * Create a collision filter\r\n */\r\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Check if two filters allow collision\r\n * Both must have the other in their mask\r\n */\r\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\r\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\r\n}\r\n\r\n/**\r\n * Create a filter that collides with specific layers\r\n */\r\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\r\n    let mask = 0;\r\n    for (const l of collidesWithLayers) {\r\n        mask |= l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Create a filter that collides with everything except specific layers\r\n */\r\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\r\n    let mask = Layers.ALL;\r\n    for (const l of excludeLayers) {\r\n        mask &= ~l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n", "/**\n * 2D Rigid Body\n *\n * Defines 2D rigid body with position, rotation (angle), velocity.\n * Uses fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2D, Shape2DType, CircleShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);\nconst FRICTION_DEFAULT = toFixed(0.5);\n\n// Pre-computed fixed-point constants for deterministic inertia calculations\nconst FP_ONE_TWELFTH = 5461 as Fixed;  // 65536 / 12 = 5461.33... -> 5461\n\n// ============================================\n// Types\n// ============================================\n\nexport enum BodyType2D {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n/**\n * 2D Vector using fixed-point math.\n */\nexport interface Vec2 {\n    x: Fixed;\n    y: Fixed;\n}\n\nexport function vec2Zero(): Vec2 {\n    return { x: 0, y: 0 };\n}\n\nexport function vec2(x: number, y: number): Vec2 {\n    return { x: toFixed(x), y: toFixed(y) };\n}\n\nexport function vec2Clone(v: Vec2): Vec2 {\n    return { x: v.x, y: v.y };\n}\n\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x + b.x) as Fixed, y: (a.y + b.y) as Fixed };\n}\n\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x - b.x) as Fixed, y: (a.y - b.y) as Fixed };\n}\n\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\n}\n\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\n    return (fpMul(a.x, b.x) + fpMul(a.y, b.y)) as Fixed;\n}\n\nexport function vec2LengthSq(v: Vec2): Fixed {\n    return (fpMul(v.x, v.x) + fpMul(v.y, v.y)) as Fixed;\n}\n\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\n    // 2D cross product returns scalar (z component of 3D cross)\n    return (fpMul(a.x, b.y) - fpMul(a.y, b.x)) as Fixed;\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody2D {\n    id: number;\n    type: BodyType2D;\n    shape: Shape2D;\n    label: string;\n\n    // Transform\n    position: Vec2;\n    angle: Fixed;  // Rotation in radians (not quaternion like 3D)\n\n    // Velocity\n    linearVelocity: Vec2;\n    angularVelocity: Fixed;  // Radians per second\n\n    // Mass properties\n    mass: Fixed;\n    invMass: Fixed;\n    inertia: Fixed;\n    invInertia: Fixed;\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotation: boolean;\n    isSensor: boolean;\n    isBullet: boolean;  // Enable CCD (continuous collision detection) for fast-moving objects\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId2D = 1;\n\nexport function resetBody2DIdCounter(): void {\n    nextBodyId2D = 1;\n}\n\nexport function getBody2DIdCounter(): number {\n    return nextBodyId2D;\n}\n\nexport function setBody2DIdCounter(value: number): void {\n    nextBodyId2D = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody2D(\n    type: BodyType2D,\n    shape: Shape2D,\n    x: number,\n    y: number,\n    label?: string\n): RigidBody2D {\n    const mass = type === BodyType2D.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType2D.Dynamic ? FP_ONE : 0;\n\n    // Calculate moment of inertia using pre-computed constants\n    let inertia = 0;\n    if (type === BodyType2D.Dynamic) {\n        if (shape.type === Shape2DType.Circle) {\n            // I = (1/2) * m * r\u00B2\n            const r = (shape as CircleShape).radius;\n            inertia = fpMul(fpMul(mass, FP_HALF), fpMul(r, r));\n        } else {\n            // I = (1/12) * m * (w\u00B2 + h\u00B2)\n            // Use bit shift for *2 instead of fpMul with toFixed(2)\n            const w = (shape.halfWidth << 1) as Fixed;\n            const h = (shape.halfHeight << 1) as Fixed;\n            inertia = fpMul(fpMul(mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\n        }\n    }\n\n    // Always increment counter for new bodies (ID will be overwritten for snapshot restoration)\n    const bodyId = nextBodyId2D++;\n    const bodyLabel = label || 'body2d_' + bodyId;\n\n    return {\n        id: bodyId,\n        type,\n        shape,\n        label: bodyLabel,\n        position: vec2(x, y),\n        angle: 0,\n        linearVelocity: vec2Zero(),\n        angularVelocity: 0,\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotation: false,\n        isSensor: false,\n        isBullet: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBody2DMass(body: RigidBody2D, mass: number): void {\n    if (body.type !== BodyType2D.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBody2DVelocity(body: RigidBody2D, vx: number, vy: number): void {\n    body.linearVelocity = vec2(vx, vy);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse2D(body: RigidBody2D, impulse: Vec2, point?: Vec2): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(impulse, body.invMass));\n\n    if (point && !body.lockRotation) {\n        const r = vec2Sub(point, body.position);\n        const torque = vec2Cross(r, impulse);\n        body.angularVelocity = (body.angularVelocity + fpMul(torque, body.invInertia)) as Fixed;\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce2D(body: RigidBody2D, force: Vec2, dt: Fixed): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n    const impulse = vec2Scale(force, dt);\n    applyImpulse2D(body, impulse);\n}\n", "/**\n * 2D Collision Detection and Response\n *\n * Uses Box2D-style collision detection:\n * - SAT (Separating Axis Theorem) for box-box\n * - Closest point on box for circle-box\n * - Direct distance for circle-circle\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt, fpMin, fpMax, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2DType, Shape2D, CircleShape, BoxShape2D, AABB2D } from './shapes';\nimport { RigidBody2D, Vec2, vec2, vec2Zero, vec2Sub, vec2Add, vec2Scale, vec2Dot, vec2LengthSq, BodyType2D } from './rigid-body';\n\n// ============================================\n// Contact\n// ============================================\n\nexport interface Contact2D {\n    bodyA: RigidBody2D;\n    bodyB: RigidBody2D;\n    point: Vec2;\n    normal: Vec2;  // Points from A to B\n    depth: Fixed;\n}\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB2D(body: RigidBody2D): AABB2D {\n    const { position, shape, angle } = body;\n\n    if (shape.type === Shape2DType.Circle) {\n        const radius = (shape as CircleShape).radius;\n        return {\n            minX: (position.x - radius) as Fixed,\n            minY: (position.y - radius) as Fixed,\n            maxX: (position.x + radius) as Fixed,\n            maxY: (position.y + radius) as Fixed,\n        };\n    } else {\n        const box = shape as BoxShape2D;\n        const halfWidth = box.halfWidth;\n        const halfHeight = box.halfHeight;\n\n        if (angle === 0) {\n            return {\n                minX: (position.x - halfWidth) as Fixed,\n                minY: (position.y - halfHeight) as Fixed,\n                maxX: (position.x + halfWidth) as Fixed,\n                maxY: (position.y + halfHeight) as Fixed,\n            };\n        }\n\n        // Rotated box - compute bounding box\n        const cosAngle = fpCos(angle);\n        const sinAngle = fpSin(angle);\n        const absCos = fpAbs(cosAngle);\n        const absSin = fpAbs(sinAngle);\n\n        const extentX = (fpMul(halfWidth, absCos) + fpMul(halfHeight, absSin)) as Fixed;\n        const extentY = (fpMul(halfWidth, absSin) + fpMul(halfHeight, absCos)) as Fixed;\n\n        return {\n            minX: (position.x - extentX) as Fixed,\n            minY: (position.y - extentY) as Fixed,\n            maxX: (position.x + extentX) as Fixed,\n            maxY: (position.y + extentY) as Fixed,\n        };\n    }\n}\n\n// ============================================\n// Collision Detection\n// ============================================\n\nexport function detectCollision2D(bodyA: RigidBody2D, bodyB: RigidBody2D): Contact2D | null {\n    const shapeA = bodyA.shape;\n    const shapeB = bodyB.shape;\n\n    // Circle-Circle\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Circle) {\n        return detectCircleCircle(bodyA, bodyB);\n    }\n\n    // Box-Box\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Box) {\n        return detectBoxBox(bodyA, bodyB);\n    }\n\n    // Circle-Box (ensure circle is always first for consistent normal direction)\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Box) {\n        return detectCircleBox(bodyA, bodyB);\n    }\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Circle) {\n        const contact = detectCircleBox(bodyB, bodyA);\n        if (contact) {\n            // Swap bodies and flip normal to maintain A->B convention\n            return {\n                bodyA: bodyA,\n                bodyB: bodyB,\n                point: contact.point,\n                normal: { x: (-contact.normal.x) as Fixed, y: (-contact.normal.y) as Fixed },\n                depth: contact.depth\n            };\n        }\n        return null;\n    }\n\n    return null;\n}\n\n/**\n * Circle vs Circle collision detection\n */\nfunction detectCircleCircle(circleA: RigidBody2D, circleB: RigidBody2D): Contact2D | null {\n    const radiusA = (circleA.shape as CircleShape).radius;\n    const radiusB = (circleB.shape as CircleShape).radius;\n    const sumRadius = (radiusA + radiusB) as Fixed;\n\n    // Vector from A to B\n    const deltaX = (circleB.position.x - circleA.position.x) as Fixed;\n    const deltaY = (circleB.position.y - circleA.position.y) as Fixed;\n    const distanceSq = (fpMul(deltaX, deltaX) + fpMul(deltaY, deltaY)) as Fixed;\n    const minDistSq = fpMul(sumRadius, sumRadius);\n\n    if (distanceSq >= minDistSq) return null;\n\n    const distance = fpSqrt(distanceSq);\n    const penetration = (sumRadius - distance) as Fixed;\n\n    // Normal points from A to B\n    let normalX: Fixed, normalY: Fixed;\n    if (distance > 0) {\n        const invDist = fpDiv(FP_ONE, distance);\n        normalX = fpMul(deltaX, invDist);\n        normalY = fpMul(deltaY, invDist);\n    } else {\n        // Circles at same position - arbitrary normal\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n    }\n\n    // Contact point on surface of A\n    const contactX = (circleA.position.x + fpMul(normalX, radiusA)) as Fixed;\n    const contactY = (circleA.position.y + fpMul(normalY, radiusA)) as Fixed;\n\n    return {\n        bodyA: circleA,\n        bodyB: circleB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Box vs Box collision detection (AABB - assumes no rotation)\n */\nfunction detectBoxBox(boxA: RigidBody2D, boxB: RigidBody2D): Contact2D | null {\n    const shapeA = boxA.shape as BoxShape2D;\n    const shapeB = boxB.shape as BoxShape2D;\n\n    // Vector from A to B\n    const deltaX = (boxB.position.x - boxA.position.x) as Fixed;\n    const deltaY = (boxB.position.y - boxA.position.y) as Fixed;\n\n    // Overlap on each axis\n    const overlapX = ((shapeA.halfWidth + shapeB.halfWidth) - fpAbs(deltaX)) as Fixed;\n    const overlapY = ((shapeA.halfHeight + shapeB.halfHeight) - fpAbs(deltaY)) as Fixed;\n\n    if (overlapX <= 0 || overlapY <= 0) return null;\n\n    // Use axis with minimum overlap (SAT)\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (overlapX < overlapY) {\n        penetration = overlapX;\n        normalX = deltaX > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n        normalY = 0 as Fixed;\n    } else {\n        penetration = overlapY;\n        normalX = 0 as Fixed;\n        normalY = deltaY > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n    }\n\n    // Contact point at midpoint\n    const contactX = ((boxA.position.x + boxB.position.x) >> 1) as Fixed;\n    const contactY = ((boxA.position.y + boxB.position.y) >> 1) as Fixed;\n\n    return {\n        bodyA: boxA,\n        bodyB: boxB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Circle vs Box collision detection\n * Box2D-style: find closest point on box, check distance to circle center\n */\nfunction detectCircleBox(circle: RigidBody2D, box: RigidBody2D): Contact2D | null {\n    const radius = (circle.shape as CircleShape).radius;\n    const boxShape = box.shape as BoxShape2D;\n\n    // Circle center in box's local space (box at origin)\n    const localX = (circle.position.x - box.position.x) as Fixed;\n    const localY = (circle.position.y - box.position.y) as Fixed;\n\n    // Clamp to box bounds to find closest point\n    const clampedX = fpMax((-boxShape.halfWidth) as Fixed, fpMin(boxShape.halfWidth, localX));\n    const clampedY = fpMax((-boxShape.halfHeight) as Fixed, fpMin(boxShape.halfHeight, localY));\n\n    // Check if circle center is inside box\n    const centerInside = fpAbs(localX) < boxShape.halfWidth && fpAbs(localY) < boxShape.halfHeight;\n\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (centerInside) {\n        // Circle center is inside box - find closest face\n        const distToRight = (boxShape.halfWidth - localX) as Fixed;\n        const distToLeft = (boxShape.halfWidth + localX) as Fixed;\n        const distToTop = (boxShape.halfHeight - localY) as Fixed;\n        const distToBottom = (boxShape.halfHeight + localY) as Fixed;\n\n        // Find minimum distance to any face\n        let minDist = distToRight;\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n\n        if (distToLeft < minDist) {\n            minDist = distToLeft;\n            normalX = (-FP_ONE) as Fixed;\n            normalY = 0 as Fixed;\n        }\n        if (distToTop < minDist) {\n            minDist = distToTop;\n            normalX = 0 as Fixed;\n            normalY = FP_ONE;\n        }\n        if (distToBottom < minDist) {\n            minDist = distToBottom;\n            normalX = 0 as Fixed;\n            normalY = (-FP_ONE) as Fixed;\n        }\n\n        // Penetration is distance to face plus radius\n        penetration = (minDist + radius) as Fixed;\n    } else {\n        // Circle center is outside box - normal case\n        const diffX = (localX - clampedX) as Fixed;\n        const diffY = (localY - clampedY) as Fixed;\n        const distanceSq = (fpMul(diffX, diffX) + fpMul(diffY, diffY)) as Fixed;\n\n        // No collision if distance > radius\n        if (distanceSq >= fpMul(radius, radius)) return null;\n\n        const distance = fpSqrt(distanceSq);\n        penetration = (radius - distance) as Fixed;\n\n        if (distance > 0) {\n            const invDist = fpDiv(FP_ONE, distance);\n            // Normal points from circle toward box (from A to B)\n            // diffX/diffY points from box surface toward circle, so negate\n            normalX = fpMul((-diffX) as Fixed, invDist);\n            normalY = fpMul((-diffY) as Fixed, invDist);\n        } else {\n            // Edge case: circle exactly on box corner\n            normalX = FP_ONE;\n            normalY = 0 as Fixed;\n        }\n    }\n\n    // Contact point on circle surface (toward box)\n    const contactX = (circle.position.x + fpMul(normalX, radius)) as Fixed;\n    const contactY = (circle.position.y + fpMul(normalY, radius)) as Fixed;\n\n    return {\n        bodyA: circle,\n        bodyB: box,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\n/**\n * Resolve collision by applying position correction and velocity impulses.\n *\n * For kinematic bodies: position correction only (no velocity response)\n * For dynamic bodies: both position and velocity correction\n */\nexport function resolveCollision2D(contact: Contact2D): void {\n    const { bodyA, bodyB, normal, depth } = contact;\n\n    // Skip triggers\n    if (bodyA.isSensor || bodyB.isSensor) return;\n\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Static-Static: nothing to do\n    if (typeA === BodyType2D.Static && typeB === BodyType2D.Static) return;\n\n    // Apply position correction based on body types\n    applyPositionCorrection(bodyA, bodyB, normal, depth);\n\n    // Apply velocity impulses only for dynamic bodies\n    if (typeA === BodyType2D.Dynamic || typeB === BodyType2D.Dynamic) {\n        applyVelocityImpulse(bodyA, bodyB, normal);\n    }\n}\n\n/**\n * Apply position correction to separate overlapping bodies.\n * Called once per contact, not iterated.\n */\nfunction applyPositionCorrection(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    depth: Fixed\n): void {\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Determine how to distribute the correction\n    const aMovable = typeA !== BodyType2D.Static;\n    const bMovable = typeB !== BodyType2D.Static;\n\n    if (!aMovable && !bMovable) return;\n\n    // Tiny slop to prevent jitter (0.01 units)\n    const slop = toFixed(0.01);\n    const correctionDepth = fpMax(0 as Fixed, (depth - slop) as Fixed);\n\n    if (correctionDepth <= 0) return;\n\n    if (aMovable && bMovable) {\n        // Both movable: split correction equally\n        const halfCorrection = (correctionDepth >> 1) as Fixed;\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, halfCorrection)) as Fixed;\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, halfCorrection)) as Fixed;\n    } else if (aMovable) {\n        // Only A moves\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, correctionDepth)) as Fixed;\n    } else {\n        // Only B moves\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, correctionDepth)) as Fixed;\n    }\n}\n\n/**\n * Apply velocity impulse for dynamic body collisions.\n */\nfunction applyVelocityImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2\n): void {\n    // Get effective inverse masses (0 for non-dynamic)\n    const invMassA = bodyA.type === BodyType2D.Dynamic ? bodyA.invMass : 0 as Fixed;\n    const invMassB = bodyB.type === BodyType2D.Dynamic ? bodyB.invMass : 0 as Fixed;\n    const totalInvMass = (invMassA + invMassB) as Fixed;\n\n    if (totalInvMass === 0) return;\n\n    // Relative velocity (B relative to A)\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    // Velocity along collision normal\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Don't resolve if separating\n    if (velAlongNormal > 0) return;\n\n    // Coefficient of restitution (bounciness)\n    const restitution = fpMin(bodyA.restitution, bodyB.restitution);\n\n    // Impulse magnitude\n    const impulseMag = fpDiv(\n        fpMul((-(FP_ONE + restitution)) as Fixed, velAlongNormal),\n        totalInvMass\n    );\n\n    // Apply impulse\n    const impulseX = fpMul(normal.x, impulseMag);\n    const impulseY = fpMul(normal.y, impulseMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(impulseX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(impulseY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(impulseX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(impulseY, invMassB)) as Fixed;\n    }\n\n    // Friction impulse\n    applyFrictionImpulse(bodyA, bodyB, normal, impulseMag, invMassA, invMassB, totalInvMass);\n}\n\n/**\n * Apply friction impulse tangent to collision normal.\n */\nfunction applyFrictionImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    normalImpulse: Fixed,\n    invMassA: Fixed,\n    invMassB: Fixed,\n    totalInvMass: Fixed\n): void {\n    // Recalculate relative velocity after normal impulse\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Tangent velocity\n    const tangentX = (relVelX - fpMul(normal.x, velAlongNormal)) as Fixed;\n    const tangentY = (relVelY - fpMul(normal.y, velAlongNormal)) as Fixed;\n    const tangentLenSq = (fpMul(tangentX, tangentX) + fpMul(tangentY, tangentY)) as Fixed;\n\n    if (tangentLenSq === 0) return;\n\n    const tangentLen = fpSqrt(tangentLenSq);\n    const invTangentLen = fpDiv(FP_ONE, tangentLen);\n    const tangentNormX = fpMul(tangentX, invTangentLen);\n    const tangentNormY = fpMul(tangentY, invTangentLen);\n\n    // Friction coefficient\n    const friction = fpMul(bodyA.friction, bodyB.friction);\n\n    // Friction impulse magnitude\n    const tangentVel = (fpMul(relVelX, tangentNormX) + fpMul(relVelY, tangentNormY)) as Fixed;\n    let frictionMag = fpDiv(-tangentVel, totalInvMass);\n\n    // Coulomb friction: clamp to mu * normal force\n    const maxFriction = fpMul(friction, fpAbs(normalImpulse));\n    if (fpAbs(frictionMag) > maxFriction) {\n        frictionMag = frictionMag > 0 ? maxFriction : (-maxFriction) as Fixed;\n    }\n\n    // Apply friction\n    const frictionX = fpMul(tangentNormX, frictionMag);\n    const frictionY = fpMul(tangentNormY, frictionMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(frictionX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(frictionY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(frictionX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(frictionY, invMassB)) as Fixed;\n    }\n}\n", "/**\r\n * Spatial Hash Grid for O(1) Broad Phase Collision Detection\r\n *\r\n * Divides the world into fixed-size cells. Bodies are hashed to cells\r\n * based on their position. Collision queries only check nearby cells.\r\n *\r\n * Handles oversized entities (larger than cell size) by checking them\r\n * against all other entities - since there are typically few of these,\r\n * the O(n) cost is acceptable.\r\n *\r\n * Optimal for .io games with many uniform-sized entities (food, bullets)\r\n * plus a few large obstacles or grown players.\r\n */\r\n\r\nimport { RigidBody2D } from './rigid-body';\r\nimport { Fixed, toFloat } from '../../math/fixed';\r\nimport { Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\n\r\n// ============================================\r\n// Helper: Get body radius for size comparison\r\n// ============================================\r\n\r\nfunction getBodyRadius(body: RigidBody2D): number {\r\n    if (body.shape.type === Shape2DType.Circle) {\r\n        return toFloat((body.shape as CircleShape).radius);\r\n    } else {\r\n        const box = body.shape as BoxShape2D;\r\n        // Use diagonal half-length as radius\r\n        const hw = toFloat(box.halfWidth);\r\n        const hh = toFloat(box.halfHeight);\r\n        return Math.sqrt(hw * hw + hh * hh);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Spatial Hash Grid\r\n// ============================================\r\n\r\nexport class SpatialHash2D {\r\n    private cellSize: number;\r\n    private invCellSize: number;\r\n    private cells: Map<number, RigidBody2D[]> = new Map();\r\n    private bodyToCell: Map<RigidBody2D, number> = new Map();\r\n\r\n    // Oversized entities (diameter > cellSize) - checked against all others\r\n    private oversized: RigidBody2D[] = [];\r\n    // All regular (non-oversized) bodies for oversized checks\r\n    private allRegular: RigidBody2D[] = [];\r\n\r\n    /**\r\n     * Create a spatial hash grid.\r\n     * @param cellSize Size of each cell. Entities larger than this are\r\n     *                 handled specially (checked against all others).\r\n     */\r\n    constructor(cellSize: number = 64) {\r\n        this.cellSize = cellSize;\r\n        this.invCellSize = 1 / cellSize;\r\n    }\r\n\r\n    /**\r\n     * Hash a position to a cell key.\r\n     * Uses bit packing for fast integer key: (x << 16) | y\r\n     */\r\n    private hashPosition(x: number, y: number): number {\r\n        const cellX = Math.floor(x * this.invCellSize) & 0xFFFF;\r\n        const cellY = Math.floor(y * this.invCellSize) & 0xFFFF;\r\n        return (cellX << 16) | cellY;\r\n    }\r\n\r\n    /**\r\n     * Clear all cells (call at start of each frame).\r\n     */\r\n    clear(): void {\r\n        this.cells.clear();\r\n        this.bodyToCell.clear();\r\n        this.oversized.length = 0;\r\n        this.allRegular.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Insert a body into the grid.\r\n     * Oversized bodies (diameter > cellSize) are tracked separately.\r\n     */\r\n    insert(body: RigidBody2D): void {\r\n        const radius = getBodyRadius(body);\r\n        const diameter = radius * 2;\r\n\r\n        // Oversized entities are checked against everything\r\n        if (diameter > this.cellSize) {\r\n            this.oversized.push(body);\r\n            return;\r\n        }\r\n\r\n        // Regular entities go into spatial hash\r\n        this.allRegular.push(body);\r\n\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const key = this.hashPosition(x, y);\r\n\r\n        let cell = this.cells.get(key);\r\n        if (!cell) {\r\n            cell = [];\r\n            this.cells.set(key, cell);\r\n        }\r\n        cell.push(body);\r\n        this.bodyToCell.set(body, key);\r\n    }\r\n\r\n    /**\r\n     * Insert all bodies into the grid.\r\n     */\r\n    insertAll(bodies: RigidBody2D[]): void {\r\n        for (const body of bodies) {\r\n            this.insert(body);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same cell as a position.\r\n     */\r\n    queryPoint(x: number, y: number): RigidBody2D[] {\r\n        const key = this.hashPosition(x, y);\r\n        return this.cells.get(key) || [];\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same and adjacent cells (3x3 neighborhood).\r\n     * This handles bodies near cell boundaries.\r\n     */\r\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n\r\n        // Check 3x3 grid of cells\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const other of cell) {\r\n                        if (other !== body) {\r\n                            result.push(other);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Query bodies within a radius (for larger entities that span multiple cells).\r\n     */\r\n    queryRadius(x: number, y: number, radius: number): RigidBody2D[] {\r\n        const cellRadius = Math.ceil(radius * this.invCellSize);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n        const seen = new Set<RigidBody2D>();\r\n\r\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\r\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const body of cell) {\r\n                        if (!seen.has(body)) {\r\n                            seen.add(body);\r\n                            result.push(body);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Iterate over potential collision pairs, calling the callback for each.\r\n     * Each pair is visited exactly once. No Set or deduplication needed -\r\n     * the algorithm structure guarantees uniqueness.\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        for (const [key, cell] of this.cells) {\r\n            // Check within same cell - pairs (i, j) where i < j are unique\r\n            for (let i = 0; i < cell.length; i++) {\r\n                for (let j = i + 1; j < cell.length; j++) {\r\n                    callback(cell[i], cell[j]);\r\n                }\r\n            }\r\n\r\n            // Check against neighbor cells with HIGHER keys only\r\n            // This ensures each cross-cell pair is checked exactly once\r\n            const cellX = (key >> 16) & 0xFFFF;\r\n            const cellY = key & 0xFFFF;\r\n\r\n            // Only check neighbors with higher cell keys to avoid duplicates\r\n            const neighbors = [\r\n                ((cellX + 1) & 0xFFFF) << 16 | cellY,           // Right (+x)\r\n                (cellX << 16) | ((cellY + 1) & 0xFFFF),         // Below (+y)\r\n                (((cellX + 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF), // Below-right (+x,+y)\r\n            ];\r\n\r\n            for (const neighborKey of neighbors) {\r\n                // Only process if neighbor key > current key (avoids duplicates)\r\n                if (neighborKey <= key) continue;\r\n\r\n                const neighborCell = this.cells.get(neighborKey);\r\n                if (!neighborCell) continue;\r\n\r\n                for (const a of cell) {\r\n                    for (const b of neighborCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Below-left neighbor needs special handling (has lower x but higher y)\r\n            const belowLeftKey = (((cellX - 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF);\r\n            const belowLeftCell = this.cells.get(belowLeftKey);\r\n            if (belowLeftCell) {\r\n                for (const a of cell) {\r\n                    for (const b of belowLeftCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle oversized entities - check against ALL other entities\r\n        // This is O(oversized * total) but there are typically very few oversized entities\r\n        const oversized = this.oversized;\r\n        const allRegular = this.allRegular;\r\n\r\n        // Oversized vs oversized\r\n        for (let i = 0; i < oversized.length; i++) {\r\n            for (let j = i + 1; j < oversized.length; j++) {\r\n                callback(oversized[i], oversized[j]);\r\n            }\r\n        }\r\n\r\n        // Oversized vs all regular entities\r\n        for (const big of oversized) {\r\n            for (const small of allRegular) {\r\n                callback(big, small);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get potential collision pairs as an array.\r\n     * For large body counts, prefer forEachPair() to avoid array allocation.\r\n     */\r\n    getPotentialPairs(): Array<[RigidBody2D, RigidBody2D]> {\r\n        const pairs: Array<[RigidBody2D, RigidBody2D]> = [];\r\n        this.forEachPair((a, b) => pairs.push([a, b]));\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Get statistics for debugging.\r\n     */\r\n    getStats(): { cellCount: number; maxPerCell: number; avgPerCell: number; oversizedCount: number } {\r\n        let maxPerCell = 0;\r\n        let totalBodies = 0;\r\n\r\n        for (const cell of this.cells.values()) {\r\n            maxPerCell = Math.max(maxPerCell, cell.length);\r\n            totalBodies += cell.length;\r\n        }\r\n\r\n        return {\r\n            cellCount: this.cells.size,\r\n            maxPerCell,\r\n            avgPerCell: this.cells.size > 0 ? totalBodies / this.cells.size : 0,\r\n            oversizedCount: this.oversized.length\r\n        };\r\n    }\r\n}\r\n", "/**\r\n * 2D Physics World\r\n *\r\n * Manages the 2D physics simulation including gravity, collision detection,\r\n * and integration of velocities and positions.\r\n */\r\n\r\nimport { Fixed, FP_ONE, FP_HALF, toFixed, toFloat, fpMul, fpDiv, fpAbs } from '../../math/fixed';\r\nimport { aabb2DOverlap, Shape2D, Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\nimport { RigidBody2D, BodyType2D, Vec2, vec2, vec2Zero, vec2Add, vec2Scale, vec2LengthSq, createBody2D, setBody2DIdCounter, getBody2DIdCounter } from './rigid-body';\r\nimport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\r\nimport { shouldCollide, CollisionFilter, DEFAULT_FILTER } from './layers';\r\nimport { TriggerState, TriggerEvent } from './trigger';\r\nimport { SpatialHash2D } from './spatial-hash';\r\n\r\n// ============================================\r\n// Constants\r\n// ============================================\r\n\r\nconst GRAVITY_2D: Vec2 = { x: 0, y: toFixed(-30) };  // -30 units/s\u00B2 (down in Y)\r\nconst LINEAR_DAMPING = toFixed(0.1);\r\nconst ANGULAR_DAMPING = toFixed(0.1);\r\nconst SLEEP_THRESHOLD = toFixed(0.12);\r\nconst SLEEP_FRAMES_REQUIRED = 20;\r\n\r\n// Default spatial hash cell size - should be >= largest entity diameter\r\nconst DEFAULT_CELL_SIZE = 64;\r\n\r\n// ============================================\r\n// Trigger Event 2D\r\n// ============================================\r\n\r\nexport interface TriggerEvent2D {\r\n    trigger: RigidBody2D;\r\n    other: RigidBody2D;\r\n}\r\n\r\n// ============================================\r\n// Contact Listener\r\n// ============================================\r\n\r\nexport interface ContactListener2D {\r\n    onContact(bodyA: RigidBody2D, bodyB: RigidBody2D): void;\r\n}\r\n\r\n// ============================================\r\n// World Interface\r\n// ============================================\r\n\r\nexport interface World2D {\r\n    bodies: RigidBody2D[];\r\n    gravity: Vec2;\r\n    dt: Fixed;\r\n    contactListener?: ContactListener2D;\r\n    /** Reference to Physics2D system for type-based collision handling */\r\n    physics2d?: any;\r\n    /** Step the physics simulation */\r\n    step(): void;\r\n}\r\n\r\nexport function createWorld2D(dt: number = 1 / 60): World2D {\r\n    const world: World2D = {\r\n        bodies: [],\r\n        gravity: { x: GRAVITY_2D.x, y: GRAVITY_2D.y },\r\n        dt: toFixed(dt),\r\n        step() {\r\n            stepWorld2D(world);\r\n        }\r\n    };\r\n    return world;\r\n}\r\n\r\nexport function addBody2D(world: World2D, body: RigidBody2D): void {\r\n    world.bodies.push(body);\r\n}\r\n\r\nexport function removeBody2D(world: World2D, body: RigidBody2D): void {\r\n    const index = world.bodies.indexOf(body);\r\n    if (index >= 0) {\r\n        world.bodies.splice(index, 1);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// World Step\r\n// ============================================\r\n\r\nexport function stepWorld2D(world: World2D): { contacts: Contact2D[]; triggers: TriggerEvent2D[] } {\r\n    const { gravity, dt } = world;\r\n    const contacts: Contact2D[] = [];\r\n    const triggerOverlaps: TriggerEvent2D[] = [];\r\n\r\n    // Collect collision pairs for deterministic callback firing AFTER detection\r\n    const collisionPairs: Array<{ entityA: any; entityB: any; labelA: string; labelB: string }> = [];\r\n\r\n    // Sort bodies by label for deterministic collision processing\r\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Integrate velocities (apply gravity)\r\n    for (const body of bodies) {\r\n        if (body.type !== BodyType2D.Dynamic) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Apply gravity\r\n        body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(gravity, dt));\r\n\r\n        // Apply damping\r\n        const linearDamp = (FP_ONE - LINEAR_DAMPING) as Fixed;\r\n        const angularDamp = (FP_ONE - ANGULAR_DAMPING) as Fixed;\r\n\r\n        body.linearVelocity = vec2Scale(body.linearVelocity, linearDamp);\r\n        body.angularVelocity = fpMul(body.angularVelocity, angularDamp);\r\n    }\r\n\r\n    // Collision detection using spatial hash for O(1) broad phase\r\n    // Cell size should be >= largest entity diameter for optimal performance\r\n    const spatialHash = new SpatialHash2D(DEFAULT_CELL_SIZE);\r\n    spatialHash.insertAll(bodies);\r\n\r\n    // Process potential collision pairs directly (no intermediate array allocation)\r\n    spatialHash.forEachPair((bodyA, bodyB) => {\r\n        // Skip static-static (no collision needed)\r\n        if (bodyA.type === BodyType2D.Static && bodyB.type === BodyType2D.Static) return;\r\n        if (!shouldCollide(bodyA.filter, bodyB.filter)) return;\r\n\r\n        // Broad phase: AABB overlap test (spatial hash gives candidates, still need precise AABB)\r\n        const aabbA = computeAABB2D(bodyA);\r\n        const aabbB = computeAABB2D(bodyB);\r\n        if (!aabb2DOverlap(aabbA, aabbB)) return;\r\n\r\n        // Narrow phase: precise collision detection\r\n        const contact = detectCollision2D(bodyA, bodyB);\r\n\r\n        if (!contact) return;\r\n\r\n        // Collect entity pairs for callback firing (all collisions including sensors)\r\n        const entityA = bodyA.userData;\r\n        const entityB = bodyB.userData;\r\n        if (entityA || entityB) {\r\n            collisionPairs.push({\r\n                entityA,\r\n                entityB,\r\n                labelA: bodyA.label,\r\n                labelB: bodyB.label\r\n            });\r\n        }\r\n\r\n        // Sensors: detect overlap but skip physics response\r\n        if (bodyA.isSensor || bodyB.isSensor) {\r\n            if (bodyA.isSensor) triggerOverlaps.push({ trigger: bodyA, other: bodyB });\r\n            if (bodyB.isSensor) triggerOverlaps.push({ trigger: bodyB, other: bodyA });\r\n            return;\r\n        }\r\n\r\n        // Store contact and fire contact listener\r\n        contacts.push(contact);\r\n        if (world.contactListener) world.contactListener.onContact(bodyA, bodyB);\r\n\r\n        // Resolve collision (position + velocity)\r\n        resolveCollision2D(contact);\r\n    });\r\n\r\n    // Fire entity collision callbacks AFTER all detection is complete\r\n    // Sort by both labels to ensure deterministic ordering across clients\r\n    collisionPairs.sort((a, b) => {\r\n        const cmp = a.labelA.localeCompare(b.labelA);\r\n        return cmp !== 0 ? cmp : a.labelB.localeCompare(b.labelB);\r\n    });\r\n\r\n    for (const pair of collisionPairs) {\r\n        // Check active status at callback time (may have changed during earlier callbacks)\r\n        if (pair.entityA?.active === false || pair.entityB?.active === false) continue;\r\n\r\n        // Try Physics2D type-based handlers first (preferred - auto-restored)\r\n        if (world.physics2d?.handleCollision?.(pair.entityA, pair.entityB)) {\r\n            continue; // Handler found and called, skip entity.onCollision\r\n        }\r\n\r\n        // Fall back to entity.onCollision (legacy - requires manual restore in onSnapshot)\r\n        if (pair.entityA?.onCollision) {\r\n            pair.entityA.onCollision(pair.entityB);\r\n        }\r\n        if (pair.entityB?.onCollision) {\r\n            pair.entityB.onCollision(pair.entityA);\r\n        }\r\n    }\r\n\r\n    // Integrate positions\r\n    for (const body of bodies) {\r\n        if (body.type === BodyType2D.Static) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Clamp tiny velocities\r\n        const linearClamp = toFixed(0.05);\r\n        const angularClamp = toFixed(0.01);\r\n\r\n        if (fpAbs(body.linearVelocity.x) < linearClamp) body.linearVelocity.x = 0;\r\n        if (fpAbs(body.linearVelocity.y) < linearClamp) body.linearVelocity.y = 0;\r\n        if (fpAbs(body.angularVelocity) < angularClamp) body.angularVelocity = 0;\r\n\r\n        // Update position\r\n        body.position = vec2Add(body.position, vec2Scale(body.linearVelocity, dt));\r\n\r\n        // Update angle\r\n        if (!body.lockRotation && body.angularVelocity !== 0) {\r\n            body.angle = (body.angle + fpMul(body.angularVelocity, dt)) as Fixed;\r\n        }\r\n\r\n        // Sleep detection\r\n        const speedSq = vec2LengthSq(body.linearVelocity);\r\n        const angSpeedSq = fpMul(body.angularVelocity, body.angularVelocity);\r\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\r\n\r\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\r\n            body.sleepFrames++;\r\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\r\n                body.isSleeping = true;\r\n                body.linearVelocity = vec2Zero();\r\n                body.angularVelocity = 0;\r\n            }\r\n        } else {\r\n            body.sleepFrames = 0;\r\n            body.isSleeping = false;\r\n        }\r\n    }\r\n\r\n    return { contacts, triggers: triggerOverlaps };\r\n}\r\n\r\n// ============================================\r\n// State Serialization\r\n// ============================================\r\n\r\n/**\r\n * Serialized shape data for snapshots.\r\n * Contains all information needed to recreate a shape.\r\n */\r\nexport interface ShapeState2D {\r\n    type: Shape2DType;\r\n    // Circle\r\n    radius?: Fixed;\r\n    // Box\r\n    halfWidth?: Fixed;\r\n    halfHeight?: Fixed;\r\n}\r\n\r\n/**\r\n * Complete body state for snapshots.\r\n * Contains ALL information needed to recreate a body from scratch.\r\n * This is critical for late joiners who have an empty world.\r\n */\r\nexport interface BodyState2D {\r\n    // Identity\r\n    id: number;\r\n    label: string;\r\n    bodyType: BodyType2D;\r\n\r\n    // Shape (required for body creation)\r\n    shape: ShapeState2D;\r\n\r\n    // Transform\r\n    px: Fixed;\r\n    py: Fixed;\r\n    angle: Fixed;\r\n\r\n    // Velocity\r\n    vx: Fixed;\r\n    vy: Fixed;\r\n    av: Fixed;\r\n\r\n    // Material properties\r\n    mass: Fixed;\r\n    restitution: Fixed;\r\n    friction: Fixed;\r\n\r\n    // State flags\r\n    isSleeping: boolean;\r\n    sleepFrames: number;\r\n    lockRotation: boolean;\r\n    isSensor: boolean;\r\n    isBullet: boolean;\r\n\r\n    // Collision filter\r\n    filter: CollisionFilter;\r\n\r\n    // User data (game-specific)\r\n    userData?: any;\r\n}\r\n\r\nexport interface WorldState2D {\r\n    bodies: BodyState2D[];\r\n}\r\n\r\nexport interface WorldStateWithHash2D {\r\n    state: WorldState2D;\r\n    hash: number;\r\n}\r\n\r\n/**\r\n * Serialize a shape to ShapeState2D.\r\n */\r\nfunction serializeShape(shape: Shape2D): ShapeState2D {\r\n    if (shape.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: (shape as CircleShape).radius,\r\n        };\r\n    } else {\r\n        const box = shape as BoxShape2D;\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: box.halfWidth,\r\n            halfHeight: box.halfHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Deserialize ShapeState2D back to Shape2D.\r\n */\r\nfunction deserializeShape(state: ShapeState2D): Shape2D {\r\n    if (state.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: state.radius!,\r\n        } as CircleShape;\r\n    } else {\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: state.halfWidth!,\r\n            halfHeight: state.halfHeight!,\r\n        } as BoxShape2D;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize a single body to BodyState2D.\r\n * Contains ALL information needed to recreate the body.\r\n */\r\nfunction serializeBody(b: RigidBody2D): BodyState2D {\r\n    return {\r\n        id: b.id,\r\n        label: b.label,\r\n        bodyType: b.type,\r\n        shape: serializeShape(b.shape),\r\n        px: b.position.x,\r\n        py: b.position.y,\r\n        angle: b.angle,\r\n        vx: b.linearVelocity.x,\r\n        vy: b.linearVelocity.y,\r\n        av: b.angularVelocity,\r\n        mass: b.mass,\r\n        restitution: b.restitution,\r\n        friction: b.friction,\r\n        isSleeping: b.isSleeping,\r\n        sleepFrames: b.sleepFrames,\r\n        lockRotation: b.lockRotation,\r\n        isSensor: b.isSensor,\r\n        isBullet: b.isBullet,\r\n        filter: { ...b.filter },\r\n        userData: b.userData,\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state - use saveWorldStateWithHash2D for efficiency when you need both\r\n */\r\nexport function saveWorldState2D(world: World2D): WorldState2D {\r\n    return {\r\n        bodies: world.bodies.map(serializeBody)\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state AND compute hash in a single pass.\r\n * More efficient than calling saveWorldState2D + separate hash function.\r\n */\r\nexport function saveWorldStateWithHash2D(world: World2D): WorldStateWithHash2D {\r\n    const bodies: BodyState2D[] = [];\r\n    let hash = 0;\r\n\r\n    // Single pass: serialize and hash simultaneously\r\n    for (const b of world.bodies) {\r\n        const bs = serializeBody(b);\r\n        bodies.push(bs);\r\n\r\n        // Compute hash inline - include all determinism-relevant state\r\n        hash = ((hash << 5) - hash + bs.id) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.bodyType) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.shape.type) >>> 0;\r\n        if (bs.shape.radius !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.radius) >>> 0;\r\n        }\r\n        if (bs.shape.halfWidth !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.halfWidth) >>> 0;\r\n            hash = ((hash << 5) - hash + bs.shape.halfHeight!) >>> 0;\r\n        }\r\n        hash = ((hash << 5) - hash + bs.px) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.py) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vx) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vy) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.angle) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.av) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.mass) >>> 0;\r\n    }\r\n\r\n    return { state: { bodies }, hash };\r\n}\r\n\r\n/**\r\n * Create a body from serialized state.\r\n * This is used for late joiners who need to recreate bodies from scratch.\r\n */\r\nfunction createBodyFromState(bs: BodyState2D): RigidBody2D {\r\n    const shape = deserializeShape(bs.shape);\r\n\r\n    // We need to create the body with the correct ID\r\n    // Temporarily set the counter to ensure consistent IDs\r\n    const savedCounter = getBody2DIdCounter();\r\n\r\n    // Create body at position (0, 0) - we'll set exact position after\r\n    // Use toFloat to convert fixed-point back to float for createBody2D\r\n    const body = createBody2D(bs.bodyType, shape, 0, 0, bs.label);\r\n\r\n    // Override the auto-generated ID with the snapshot ID\r\n    body.id = bs.id;\r\n\r\n    // Restore the counter (createBody2D incremented it)\r\n    // The next new body will use the max ID from snapshot + 1\r\n    setBody2DIdCounter(savedCounter);\r\n\r\n    // Set all properties from snapshot\r\n    body.position = { x: bs.px, y: bs.py };\r\n    body.angle = bs.angle;\r\n    body.linearVelocity = { x: bs.vx, y: bs.vy };\r\n    body.angularVelocity = bs.av;\r\n\r\n    // Mass properties - need to recalculate invMass and inertia\r\n    body.mass = bs.mass;\r\n    body.invMass = bs.mass > 0 ? fpDiv(FP_ONE, bs.mass) : 0;\r\n\r\n    // Recalculate inertia based on shape and mass\r\n    if (bs.bodyType === BodyType2D.Dynamic && bs.mass > 0) {\r\n        if (shape.type === Shape2DType.Circle) {\r\n            const r = (shape as CircleShape).radius;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_HALF), fpMul(r, r));\r\n        } else {\r\n            const box = shape as BoxShape2D;\r\n            const w = (box.halfWidth << 1) as Fixed;\r\n            const h = (box.halfHeight << 1) as Fixed;\r\n            const FP_ONE_TWELFTH = 5461 as Fixed;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\r\n        }\r\n        body.invInertia = body.inertia > 0 ? fpDiv(FP_ONE, body.inertia) : 0;\r\n    }\r\n\r\n    // Material\r\n    body.restitution = bs.restitution;\r\n    body.friction = bs.friction;\r\n\r\n    // State\r\n    body.isSleeping = bs.isSleeping;\r\n    body.sleepFrames = bs.sleepFrames;\r\n    body.lockRotation = bs.lockRotation;\r\n    body.isSensor = bs.isSensor;\r\n    body.isBullet = bs.isBullet ?? false;\r\n\r\n    // Collision filter\r\n    body.filter = { ...bs.filter };\r\n\r\n    // User data\r\n    body.userData = bs.userData;\r\n\r\n    return body;\r\n}\r\n\r\n/**\r\n * Load world state from snapshot.\r\n *\r\n * IMPORTANT: This function fully recreates the world from the snapshot.\r\n * It handles both:\r\n * 1. Existing worlds (rollback) - updates existing bodies, removes/adds as needed\r\n * 2. Empty worlds (late joiners) - creates all bodies from scratch\r\n *\r\n * The snapshot contains complete body information including shape data,\r\n * so bodies can be fully recreated without any prior state.\r\n */\r\nexport function loadWorldState2D(world: World2D, state: WorldState2D): void {\r\n    // Sort snapshot bodies by label for deterministic iteration\r\n    const sortedBodies = [...state.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Build a set of labels in the snapshot\r\n    const snapshotLabels = new Set(sortedBodies.map(bs => bs.label));\r\n\r\n    // Remove bodies not in snapshot\r\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\r\n        if (!snapshotLabels.has(world.bodies[i].label)) {\r\n            world.bodies.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    // Build map of existing bodies\r\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\r\n\r\n    // Track the highest ID we see to update the counter\r\n    let maxId = 0;\r\n\r\n    for (const bs of sortedBodies) {\r\n        if (bs.id > maxId) maxId = bs.id;\r\n\r\n        const existingBody = bodyMap.get(bs.label);\r\n\r\n        if (existingBody) {\r\n            // Update existing body\r\n            existingBody.position = { x: bs.px, y: bs.py };\r\n            existingBody.angle = bs.angle;\r\n            existingBody.linearVelocity = { x: bs.vx, y: bs.vy };\r\n            existingBody.angularVelocity = bs.av;\r\n            existingBody.isSleeping = bs.isSleeping;\r\n            existingBody.sleepFrames = bs.sleepFrames;\r\n            existingBody.lockRotation = bs.lockRotation;\r\n            existingBody.isSensor = bs.isSensor;\r\n            existingBody.restitution = bs.restitution;\r\n            existingBody.friction = bs.friction;\r\n            existingBody.filter = { ...bs.filter };\r\n            if (bs.userData !== undefined) {\r\n                existingBody.userData = bs.userData;\r\n            }\r\n        } else {\r\n            // Create new body from snapshot - this is critical for late joiners\r\n            const newBody = createBodyFromState(bs);\r\n            world.bodies.push(newBody);\r\n        }\r\n    }\r\n\r\n    // Update the body ID counter to be higher than any ID in the snapshot\r\n    // This ensures new bodies created after loading won't have conflicting IDs\r\n    const currentCounter = getBody2DIdCounter();\r\n    if (maxId >= currentCounter) {\r\n        setBody2DIdCounter(maxId + 1);\r\n    }\r\n\r\n    // Sort world bodies by label for deterministic order\r\n    world.bodies.sort((a, b) => a.label.localeCompare(b.label));\r\n}\r\n", "/**\n * Physics2D System for ECS\n *\n * Integrates the deterministic 2D physics engine with the ECS.\n * This system:\n * - Reads Transform2D + Body2D components\n * - Creates/manages physics bodies internally\n * - Steps the physics simulation\n * - Writes results back to Transform2D component\n * - Handles collision callbacks\n */\n\nimport { World } from '../../core/world';\nimport { Entity } from '../../core/entity';\nimport { ComponentType, hasComponent } from '../../core/component';\nimport { Transform2D, Body2D, BODY_DYNAMIC, BODY_STATIC, BODY_KINEMATIC, SHAPE_CIRCLE, SHAPE_RECT } from '../../components';\nimport { INDEX_MASK } from '../../core/constants';\nimport { toFixed, toFloat } from '../../math';\n\n// Forward declaration for Game to avoid circular import\ninterface GameLike {\n    world: World;\n    physics: Physics2DSystem | null;\n}\n\n// Import physics engine primitives (same folder now)\nimport {\n    World2D,\n    createWorld2D,\n    stepWorld2D,\n    addBody2D,\n    removeBody2D,\n    RigidBody2D,\n    BodyType2D,\n    createBody2D,\n    createCircle,\n    createBox2DFromSize,\n    resetBody2DIdCounter\n} from '.';\n\n/**\n * Collision handler type.\n */\nexport type CollisionHandler = (entityA: Entity, entityB: Entity) => void;\n\n/**\n * Physics2D System configuration.\n */\nexport interface Physics2DSystemConfig {\n    gravity?: { x: number; y: number };\n    dt?: number;  // Timestep (default: 1/60)\n}\n\n/**\n * Physics2D System - manages physics simulation for ECS entities.\n *\n * Can be used as a plugin via game.addPlugin() or standalone via attach().\n *\n * @example\n * // Plugin pattern (recommended)\n * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n *\n * // Standalone pattern (legacy)\n * const physics = createPhysics2DSystem({ gravity: { x: 0, y: 0 } });\n * physics.attach(game.world);\n * game.physics = physics;\n */\nexport class Physics2DSystem {\n    /** Physics world */\n    readonly physicsWorld: World2D;\n\n    /** ECS World reference */\n    private world: World | null = null;\n\n    /** Map entity ID to physics body */\n    private entityToBody: Map<number, RigidBody2D> = new Map();\n\n    /** Map body ID to entity ID */\n    private bodyToEntity: Map<number, number> = new Map();\n\n    /** Collision handlers by type pair */\n    private collisionHandlers: Map<string, CollisionHandler> = new Map();\n\n    /** Entities pending body creation */\n    private pendingEntities: Set<number> = new Set();\n\n    /**\n     * Create a Physics2D system.\n     *\n     * @param gameOrConfig - Game instance (plugin mode) or config (standalone mode)\n     * @param config - Config when using plugin mode\n     */\n    constructor(gameOrConfig?: GameLike | Physics2DSystemConfig, config?: Physics2DSystemConfig) {\n        // Determine if first arg is a Game or config\n        let actualConfig: Physics2DSystemConfig;\n        let game: GameLike | null = null;\n\n        if (gameOrConfig && 'world' in gameOrConfig) {\n            // Plugin mode: first arg is Game\n            game = gameOrConfig;\n            actualConfig = config ?? {};\n        } else {\n            // Standalone mode: first arg is config\n            actualConfig = (gameOrConfig as Physics2DSystemConfig) ?? {};\n        }\n\n        this.physicsWorld = createWorld2D(actualConfig.dt ?? 1 / 60);\n\n        if (actualConfig.gravity) {\n            this.physicsWorld.gravity = {\n                x: toFixed(actualConfig.gravity.x),\n                y: toFixed(actualConfig.gravity.y)\n            };\n        }\n\n        // Set up collision callback via contactListener (for non-sensor collisions)\n        const system = this;\n        this.physicsWorld.contactListener = {\n            onContact(bodyA: RigidBody2D, bodyB: RigidBody2D) {\n                system.handleCollision(bodyA, bodyB);\n            }\n        };\n\n        // Set up physics2d reference for sensor collisions\n        // The physics world uses this for type-based collision handling\n        (this.physicsWorld as any).physics2d = {\n            handleCollision: (entityA: Entity, entityB: Entity) => {\n                return this.handleCollisionByType(entityA, entityB);\n            }\n        };\n\n        // Auto-attach if game was provided\n        if (game) {\n            this.attach(game.world);\n            game.physics = this;\n        }\n    }\n\n    /**\n     * Attach to an ECS World.\n     * Registers prePhysics and physics systems.\n     */\n    attach(world: World): this {\n        this.world = world;\n\n        // Register prePhysics system - sync component data to bodies\n        world.addSystem(() => this.syncBodiesToPhysics(), { phase: 'prePhysics', order: 0 });\n\n        // Register physics system - step simulation\n        world.addSystem(() => this.step(), { phase: 'physics', order: 0 });\n\n        // Register postPhysics system - sync results back to components\n        world.addSystem(() => this.syncPhysicsToComponents(), { phase: 'postPhysics', order: 0 });\n\n        return this;\n    }\n\n    /**\n     * Register collision handler for two entity types.\n     *\n     * For different types (e.g., 'cell', 'food'), the handler is called once\n     * with arguments in the registered order.\n     *\n     * For same types (e.g., 'cell', 'cell'), the handler is called twice -\n     * once as (A, B) and once as (B, A). This lets you write \"first acts on second\"\n     * logic without manually checking both directions.\n     *\n     * @example\n     * // Cell eats food - called once per collision\n     * physics.onCollision('cell', 'food', (cell, food) => {\n     *     food.destroy();\n     * });\n     *\n     * // Cell eats smaller cell - called twice, just check if first > second\n     * physics.onCollision('cell', 'cell', (eater, prey) => {\n     *     if (eater.get(Sprite).radius > prey.get(Sprite).radius * 1.2) {\n     *         prey.destroy();\n     *     }\n     * });\n     */\n    onCollision(typeA: string, typeB: string, handler: CollisionHandler): this {\n        const key1 = `${typeA}:${typeB}`;\n        const key2 = `${typeB}:${typeA}`;\n\n        this.collisionHandlers.set(key1, handler);\n\n        // For different types, register reverse lookup that swaps arguments\n        if (typeA !== typeB) {\n            this.collisionHandlers.set(key2, (a, b) => handler(b, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Set gravity.\n     */\n    setGravity(x: number, y: number): this {\n        this.physicsWorld.gravity = { x: toFixed(x), y: toFixed(y) };\n        return this;\n    }\n\n    /**\n     * Create or get physics body for entity.\n     */\n    private ensureBody(entity: Entity): RigidBody2D | null {\n        const eid = entity.eid;\n\n        // Check if body already exists\n        let body = this.entityToBody.get(eid);\n        if (body) return body;\n\n        // Check if entity has required components\n        if (!entity.has(Transform2D) || !entity.has(Body2D)) {\n            return null;\n        }\n\n        // Get component data\n        const transform = entity.get(Transform2D);\n        const bodyData = entity.get(Body2D);\n\n        // Determine body type\n        let bodyType: BodyType2D;\n        switch (bodyData.bodyType) {\n            case BODY_STATIC:\n                bodyType = BodyType2D.Static;\n                break;\n            case BODY_KINEMATIC:\n                bodyType = BodyType2D.Kinematic;\n                break;\n            default:\n                bodyType = BodyType2D.Dynamic;\n        }\n\n        // Determine shape\n        let shape;\n        if (bodyData.shapeType === SHAPE_CIRCLE || bodyData.radius > 0) {\n            shape = createCircle(bodyData.radius || 10);\n        } else {\n            shape = createBox2DFromSize(bodyData.width || 10, bodyData.height || 10);\n        }\n\n        // Create body\n        body = createBody2D(bodyType, shape, transform.x, transform.y);\n        body.angle = toFixed(transform.angle);\n        body.linearVelocity = { x: toFixed(bodyData.vx), y: toFixed(bodyData.vy) };\n        body.isSensor = bodyData.isSensor;\n\n        // CRITICAL: All new bodies start awake for determinism\n        // Without this, late joiners would have awake bodies while existing clients\n        // have sleeping bodies, causing physics simulation divergence\n        body.isSleeping = false;\n        body.sleepFrames = 0;\n\n        // Store entity reference in body's userData\n        body.userData = entity;\n        body.label = eid.toString();\n\n        // Add to physics world\n        addBody2D(this.physicsWorld, body);\n\n        // Track mapping\n        this.entityToBody.set(eid, body);\n        this.bodyToEntity.set(body.id, eid);\n\n        return body;\n    }\n\n    /**\n     * Remove physics body for entity.\n     */\n    removeBody(entity: Entity): void {\n        const eid = entity.eid;\n        const body = this.entityToBody.get(eid);\n\n        if (body) {\n            removeBody2D(this.physicsWorld, body);\n            this.entityToBody.delete(eid);\n            this.bodyToEntity.delete(body.id);\n        }\n    }\n\n    /**\n     * Sync component data to physics bodies (prePhysics).\n     */\n    private syncBodiesToPhysics(): void {\n        if (!this.world) return;\n\n        // Iterate all entities with Body2D\n        for (const entity of this.world.query(Body2D)) {\n            // Ensure body exists\n            const body = this.ensureBody(entity);\n            if (!body) continue;\n\n            // Sync position from component for kinematic and static bodies\n            // (both can be moved by game code, only dynamic bodies are physics-driven)\n            const bodyData = entity.get(Body2D);\n            if (bodyData.bodyType === BODY_KINEMATIC || bodyData.bodyType === BODY_STATIC) {\n                const transform = entity.get(Transform2D);\n                body.position.x = toFixed(transform.x);\n                body.position.y = toFixed(transform.y);\n                body.angle = toFixed(transform.angle);\n            }\n\n            // Apply impulses (instant velocity change)\n            if (bodyData.impulseX !== 0 || bodyData.impulseY !== 0) {\n                bodyData.vx += bodyData.impulseX;\n                bodyData.vy += bodyData.impulseY;\n                bodyData.impulseX = 0;\n                bodyData.impulseY = 0;\n            }\n\n            // Apply forces (add to velocity)\n            if (bodyData.forceX !== 0 || bodyData.forceY !== 0) {\n                bodyData.vx += bodyData.forceX;\n                bodyData.vy += bodyData.forceY;\n                bodyData.forceX = 0;\n                bodyData.forceY = 0;\n            }\n\n            // Apply damping\n            if (bodyData.damping > 0) {\n                const damp = 1 - bodyData.damping;\n                bodyData.vx *= damp;\n                bodyData.vy *= damp;\n            }\n\n            // Sync velocity for all body types\n            const newVelX = toFixed(bodyData.vx);\n            const newVelY = toFixed(bodyData.vy);\n            body.linearVelocity.x = newVelX;\n            body.linearVelocity.y = newVelY;\n\n            // Wake up body if velocity is non-zero (prevents sleeping bodies from ignoring velocity)\n            if (newVelX !== 0 || newVelY !== 0) {\n                body.isSleeping = false;\n                body.sleepFrames = 0;\n            }\n\n            // Update shape radius if changed\n            if (body.shape.type === 0) { // Circle\n                const currentRadius = (body.shape as any).radius;\n                const newRadius = toFixed(bodyData.radius);\n                if (currentRadius !== newRadius) {\n                    (body.shape as any).radius = newRadius;\n                }\n            }\n        }\n\n        // Clean up bodies for destroyed entities\n        for (const [eid, body] of this.entityToBody) {\n            if (this.world.isDestroyed(eid)) {\n                removeBody2D(this.physicsWorld, body);\n                this.entityToBody.delete(eid);\n                this.bodyToEntity.delete(body.id);\n            }\n        }\n    }\n\n    /**\n     * Step physics simulation.\n     */\n    private step(): void {\n        stepWorld2D(this.physicsWorld);\n    }\n\n    /**\n     * Sync physics results back to components (postPhysics).\n     */\n    private syncPhysicsToComponents(): void {\n        for (const [eid, body] of this.entityToBody) {\n            const entity = this.world?.getEntity(eid);\n            if (!entity || entity.destroyed) continue;\n\n            const transform = entity.get(Transform2D);\n            const bodyData = entity.get(Body2D);\n\n            // Sync position and angle from physics\n            transform.x = toFloat(body.position.x);\n            transform.y = toFloat(body.position.y);\n            transform.angle = toFloat(body.angle);\n\n            // Sync velocity\n            bodyData.vx = toFloat(body.linearVelocity.x);\n            bodyData.vy = toFloat(body.linearVelocity.y);\n        }\n    }\n\n    /**\n     * Handle collision between two bodies.\n     */\n    private handleCollision(bodyA: RigidBody2D, bodyB: RigidBody2D): void {\n        const entityA = bodyA.userData as Entity;\n        const entityB = bodyB.userData as Entity;\n\n        if (!entityA || !entityB) return;\n        if (entityA.destroyed || entityB.destroyed) return;\n\n        this.handleCollisionByType(entityA, entityB);\n    }\n\n    /**\n     * Handle collision by entity types. Returns true if a handler was found.\n     * Used by physics world for both regular and sensor collisions.\n     */\n    private handleCollisionByType(entityA: Entity, entityB: Entity): boolean {\n        if (!entityA || !entityB) return false;\n        if (entityA.destroyed || entityB.destroyed) return false;\n\n        // Look up handler by type pair\n        const key = `${entityA.type}:${entityB.type}`;\n        const handler = this.collisionHandlers.get(key);\n\n        if (handler) {\n            handler(entityA, entityB);\n\n            // For same-type collisions, call handler in reverse direction too\n            // This lets handlers assume \"first arg acts on second\" without manual checks\n            if (entityA.type === entityB.type && !entityA.destroyed && !entityB.destroyed) {\n                handler(entityB, entityA);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get body for entity (for advanced use).\n     */\n    getBody(entity: Entity): RigidBody2D | undefined {\n        return this.entityToBody.get(entity.eid);\n    }\n\n    /**\n     * Get entity for body (for advanced use).\n     */\n    getEntityForBody(body: RigidBody2D): Entity | null {\n        const eid = this.bodyToEntity.get(body.id);\n        if (eid === undefined) return null;\n        return this.world?.getEntity(eid) ?? null;\n    }\n\n    /**\n     * Clear all physics state.\n     * Used during snapshot restoration to ensure fresh physics state.\n     */\n    clear(): void {\n        for (const body of this.entityToBody.values()) {\n            removeBody2D(this.physicsWorld, body);\n        }\n        this.entityToBody.clear();\n        this.bodyToEntity.clear();\n\n        // CRITICAL: Reset body ID counter to ensure deterministic body IDs\n        // Without this, recreated bodies would have different IDs than the original,\n        // potentially causing collision order differences and simulation divergence\n        resetBody2DIdCounter();\n    }\n\n    /**\n     * Wake all physics bodies.\n     * Used after snapshot load/send to ensure deterministic state.\n     * Without this, existing clients have sleeping bodies while late joiners\n     * have awake bodies, causing physics divergence.\n     */\n    wakeAllBodies(): void {\n        for (const body of this.physicsWorld.bodies) {\n            body.isSleeping = false;\n            body.sleepFrames = 0;\n        }\n    }\n}\n\n/**\n * Create a Physics2D system.\n */\nexport function createPhysics2DSystem(config: Physics2DSystemConfig = {}): Physics2DSystem {\n    return new Physics2DSystem(config);\n}\n", "/**\n * Collision Layers\n *\n * Controls which bodies can collide with each other using bitmasks.\n * Layer = \"what am I\", Mask = \"what do I collide with\"\n *\n * Shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Collision Filter\n// ============================================\n\nexport interface CollisionFilter {\n    /** Which layer this body belongs to (single bit) */\n    layer: number;\n    /** Which layers this body collides with (bitmask) */\n    mask: number;\n}\n\n// ============================================\n// Default Layers\n// ============================================\n\nexport const Layers = {\n    NONE: 0,\n    DEFAULT: 1 << 0,      // 1\n    PLAYER: 1 << 1,       // 2\n    ENEMY: 1 << 2,        // 4\n    PROJECTILE: 1 << 3,   // 8\n    ITEM: 1 << 4,         // 16\n    TRIGGER: 1 << 5,      // 32\n    WORLD: 1 << 6,        // 64\n    PROP: 1 << 7,         // 128\n    // Layers 8-15 reserved for game-specific use\n    CUSTOM_1: 1 << 8,\n    CUSTOM_2: 1 << 9,\n    CUSTOM_3: 1 << 10,\n    CUSTOM_4: 1 << 11,\n    CUSTOM_5: 1 << 12,\n    CUSTOM_6: 1 << 13,\n    CUSTOM_7: 1 << 14,\n    CUSTOM_8: 1 << 15,\n    ALL: 0xFFFF           // All layers\n} as const;\n\n// ============================================\n// Default Filter\n// ============================================\n\n/**\n * Default collision filter - collides with everything\n */\nexport const DEFAULT_FILTER: CollisionFilter = {\n    layer: Layers.DEFAULT,\n    mask: Layers.ALL\n};\n\n// ============================================\n// Filter Helpers\n// ============================================\n\n/**\n * Create a collision filter\n */\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\n    return { layer, mask };\n}\n\n/**\n * Check if two filters allow collision\n * Both must have the other in their mask\n */\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\n}\n\n/**\n * Create a filter that collides with specific layers\n */\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\n    let mask = 0;\n    for (const l of collidesWithLayers) {\n        mask |= l;\n    }\n    return { layer, mask };\n}\n\n/**\n * Create a filter that collides with everything except specific layers\n */\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\n    let mask = Layers.ALL;\n    for (const l of excludeLayers) {\n        mask &= ~l;\n    }\n    return { layer, mask };\n}\n", "/**\n * Rigid Body\n *\n * Defines rigid body types and operations for physics simulation.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv } from '../../math/fixed';\nimport { Vec3, vec3Zero, vec3FromFloats, vec3Add, vec3Scale, vec3Sub, vec3Cross } from '../../math/vec';\nimport { Quat, quatIdentity } from '../../math/quat';\nimport { Shape, ShapeType, SphereShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);  // No bounce for stable resting\nconst FRICTION_DEFAULT = toFixed(0.5);      // Moderate friction\n\n// ============================================\n// Body Types\n// ============================================\n\nexport enum BodyType {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody {\n    id: number;\n    type: BodyType;\n    shape: Shape;\n\n    // Label for deterministic ordering - MUST be unique and consistent across all clients\n    // Examples: \"ground\", \"box_0\", \"box_1\", \"player_abc123\"\n    label: string;\n\n    // Transform\n    position: Vec3;\n    rotation: Quat;\n\n    // Velocity\n    linearVelocity: Vec3;\n    angularVelocity: Vec3;\n\n    // Mass properties\n    mass: Fixed;           // 0 for static/kinematic\n    invMass: Fixed;        // 1/mass, 0 for static/kinematic\n    inertia: Fixed;        // Moment of inertia (simplified scalar)\n    invInertia: Fixed;     // 1/inertia\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotationX: boolean;\n    lockRotationY: boolean;\n    lockRotationZ: boolean;\n    isTrigger: boolean;  // If true, detects overlap but doesn't apply physics response\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId = 1;\n\nexport function resetBodyIdCounter(): void {\n    nextBodyId = 1;\n}\n\nexport function getBodyIdCounter(): number {\n    return nextBodyId;\n}\n\nexport function setBodyIdCounter(value: number): void {\n    nextBodyId = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody(type: BodyType, shape: Shape, x: number, y: number, z: number, label?: string): RigidBody {\n    const mass = type === BodyType.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType.Dynamic ? FP_ONE : 0;\n\n    // Simplified inertia calculation\n    let inertia = 0;\n    if (type === BodyType.Dynamic) {\n        if (shape.type === ShapeType.Box) {\n            // I = (1/12) * m * (h\u00B2 + d\u00B2) for each axis - use average\n            const h = shape.halfExtents;\n            inertia = fpMul(mass, fpMul(toFixed(1 / 6),\n                fpMul(h.x, h.x) + fpMul(h.y, h.y) + fpMul(h.z, h.z)));\n        } else {\n            // I = (2/5) * m * r\u00B2 for solid sphere\n            const r = (shape as SphereShape).radius;\n            inertia = fpMul(mass, fpMul(toFixed(0.4), fpMul(r, r)));\n        }\n    }\n\n    const bodyLabel = label || 'body_' + nextBodyId;\n    const bodyId = nextBodyId++;\n\n    return {\n        id: bodyId,\n        label: bodyLabel,\n        type,\n        shape,\n        position: vec3FromFloats(x, y, z),\n        rotation: quatIdentity(),\n        linearVelocity: vec3Zero(),\n        angularVelocity: vec3Zero(),\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotationX: false,\n        lockRotationY: false,\n        lockRotationZ: false,\n        isTrigger: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBodyMass(body: RigidBody, mass: number): void {\n    if (body.type !== BodyType.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBodyVelocity(body: RigidBody, vx: number, vy: number, vz: number): void {\n    body.linearVelocity = vec3FromFloats(vx, vy, vz);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse(body: RigidBody, impulse: Vec3, point?: Vec3): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(impulse, body.invMass));\n\n    if (point) {\n        const r = vec3Sub(point, body.position);\n        const torque = vec3Cross(r, impulse);\n        body.angularVelocity = vec3Add(body.angularVelocity, vec3Scale(torque, body.invInertia));\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce(body: RigidBody, force: Vec3, dt: Fixed): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n    const impulse = vec3Scale(force, dt);\n    applyImpulse(body, impulse);\n}\n", "/**\n * Collision Detection and Response\n *\n * Handles narrow-phase collision detection between shapes and\n * impulse-based collision response.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpMin, fpSqrt, fpClamp } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Sub, vec3Add, vec3Scale, vec3Neg, vec3Dot, vec3Cross, vec3LengthSq, vec3Normalize } from '../../math/vec';\nimport { quatRotateVec3, quatConjugate } from '../../math/quat';\nimport { ShapeType, SphereShape, BoxShape, AABB } from './shapes';\nimport { RigidBody, BodyType, applyImpulse } from './rigid-body';\n\n// ============================================\n// Constants\n// ============================================\n\nconst POSITION_CORRECTION = toFixed(0.6);  // Slightly less aggressive correction\nconst SLOP = toFixed(0.05);                 // Penetration allowance to reduce jitter\nconst WAKE_VELOCITY_THRESHOLD = toFixed(1.5);  // Threshold for waking sleeping bodies\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB(body: RigidBody): AABB {\n    const pos = body.position;\n    const shape = body.shape;\n\n    if (shape.type === ShapeType.Sphere) {\n        const r = shape.radius;\n        return {\n            min: { x: pos.x - r, y: pos.y - r, z: pos.z - r },\n            max: { x: pos.x + r, y: pos.y + r, z: pos.z + r }\n        };\n    } else {\n        // For rotated boxes, compute world-space AABB by projecting onto each world axis\n        const h = shape.halfExtents;\n\n        // Get the box axes in world space\n        const axisX = quatRotateVec3(body.rotation, vec3(FP_ONE, 0, 0));\n        const axisY = quatRotateVec3(body.rotation, vec3(0, FP_ONE, 0));\n        const axisZ = quatRotateVec3(body.rotation, vec3(0, 0, FP_ONE));\n\n        // Compute the extent along each world axis\n        const extentX = fpAbs(fpMul(axisX.x, h.x)) + fpAbs(fpMul(axisY.x, h.y)) + fpAbs(fpMul(axisZ.x, h.z));\n        const extentY = fpAbs(fpMul(axisX.y, h.x)) + fpAbs(fpMul(axisY.y, h.y)) + fpAbs(fpMul(axisZ.y, h.z));\n        const extentZ = fpAbs(fpMul(axisX.z, h.x)) + fpAbs(fpMul(axisY.z, h.y)) + fpAbs(fpMul(axisZ.z, h.z));\n\n        return {\n            min: { x: pos.x - extentX, y: pos.y - extentY, z: pos.z - extentZ },\n            max: { x: pos.x + extentX, y: pos.y + extentY, z: pos.z + extentZ }\n        };\n    }\n}\n\n// ============================================\n// Contact Types\n// ============================================\n\nexport interface ContactPoint {\n    point: Vec3;\n    penetration: Fixed;\n}\n\nexport interface Contact {\n    bodyA: RigidBody;\n    bodyB: RigidBody;\n    normal: Vec3;          // Points from B toward A (standard convention)\n    points: ContactPoint[]; // Multiple contact points (contact manifold)\n}\n\n// ============================================\n// Collision Detection Functions\n// ============================================\n\nfunction sphereSphereCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as SphereShape;\n    const shapeB = b.shape as SphereShape;\n\n    const diff = vec3Sub(a.position, b.position);  // Points from B to A\n    const distSq = vec3LengthSq(diff);\n    const minDist = shapeA.radius + shapeB.radius;\n    const minDistSq = fpMul(minDist, minDist);\n\n    if (distSq >= minDistSq) return null;\n\n    const dist = fpSqrt(distSq);\n    const normal = dist > 0 ? vec3Scale(diff, fpDiv(FP_ONE, dist)) : vec3(FP_ONE, 0, 0);\n    const penetration = minDist - dist;\n    const point = vec3Sub(a.position, vec3Scale(normal, shapeA.radius));\n\n    return { bodyA: a, bodyB: b, normal, points: [{ point, penetration }] };\n}\n\nfunction sphereBoxCollision(sphere: RigidBody, box: RigidBody): Contact | null {\n    const sphereShape = sphere.shape as SphereShape;\n    const boxShape = box.shape as BoxShape;\n\n    // Transform sphere center into box's local space (accounting for rotation)\n    const worldDiff = vec3Sub(sphere.position, box.position);\n    const invRotation = quatConjugate(box.rotation);\n    const localSphere = quatRotateVec3(invRotation, worldDiff);\n    const h = boxShape.halfExtents;\n\n    // Find closest point on box to sphere center (in local space)\n    const closestLocal: Vec3 = {\n        x: fpClamp(localSphere.x, -h.x, h.x),\n        y: fpClamp(localSphere.y, -h.y, h.y),\n        z: fpClamp(localSphere.z, -h.z, h.z)\n    };\n\n    const diffLocal = vec3Sub(localSphere, closestLocal);\n    const distSq = vec3LengthSq(diffLocal);\n    const radiusSq = fpMul(sphereShape.radius, sphereShape.radius);\n\n    if (distSq >= radiusSq) return null;\n\n    const dist = fpSqrt(distSq);\n\n    let normalLocal: Vec3;\n    let penetration: Fixed;\n\n    if (dist > 0) {\n        normalLocal = vec3Scale(diffLocal, fpDiv(FP_ONE, dist));\n        penetration = sphereShape.radius - dist;\n    } else {\n        // Sphere center inside box - find shortest axis to push out\n        const dx = h.x - fpAbs(localSphere.x);\n        const dy = h.y - fpAbs(localSphere.y);\n        const dz = h.z - fpAbs(localSphere.z);\n\n        if (dx <= dy && dx <= dz) {\n            normalLocal = localSphere.x >= 0 ? vec3(FP_ONE, 0, 0) : vec3(-FP_ONE, 0, 0);\n            penetration = dx + sphereShape.radius;\n        } else if (dy <= dz) {\n            normalLocal = localSphere.y >= 0 ? vec3(0, FP_ONE, 0) : vec3(0, -FP_ONE, 0);\n            penetration = dy + sphereShape.radius;\n        } else {\n            normalLocal = localSphere.z >= 0 ? vec3(0, 0, FP_ONE) : vec3(0, 0, -FP_ONE);\n            penetration = dz + sphereShape.radius;\n        }\n    }\n\n    // Transform contact point and normal back to world space\n    const worldClosest = vec3Add(box.position, quatRotateVec3(box.rotation, closestLocal));\n    const worldNormal = quatRotateVec3(box.rotation, normalLocal);\n\n    return { bodyA: sphere, bodyB: box, normal: worldNormal, points: [{ point: worldClosest, penetration }] };\n}\n\nfunction boxBoxCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as BoxShape;\n    const shapeB = b.shape as BoxShape;\n    const hA = shapeA.halfExtents;\n    const hB = shapeB.halfExtents;\n\n    // Get rotated axes for both boxes\n    const axesA = [\n        quatRotateVec3(a.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(a.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(a.rotation, vec3(0, 0, FP_ONE))\n    ];\n    const axesB = [\n        quatRotateVec3(b.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(b.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(b.rotation, vec3(0, 0, FP_ONE))\n    ];\n\n    const extentsA = [hA.x, hA.y, hA.z];\n    const extentsB = [hB.x, hB.y, hB.z];\n    const d = vec3Sub(b.position, a.position);\n\n    let minPen = 0x7FFFFFFF as Fixed;\n    let bestNormal = vec3(0, FP_ONE, 0);\n\n    // Project extent onto axis\n    function project(axes: Vec3[], extents: Fixed[], axis: Vec3): Fixed {\n        return fpAbs(fpMul(vec3Dot(axes[0], axis), extents[0])) +\n               fpAbs(fpMul(vec3Dot(axes[1], axis), extents[1])) +\n               fpAbs(fpMul(vec3Dot(axes[2], axis), extents[2]));\n    }\n\n    // Test separation on axis, returns false if separated\n    function testAxis(axis: Vec3): boolean {\n        const lenSq = vec3LengthSq(axis);\n        if (lenSq < toFixed(0.0001)) return true; // Skip degenerate\n\n        const len = fpSqrt(lenSq);\n        const n = vec3Scale(axis, fpDiv(FP_ONE, len));\n\n        const pA = project(axesA, extentsA, n);\n        const pB = project(axesB, extentsB, n);\n        const dist = fpAbs(vec3Dot(d, n));\n        const pen = (pA + pB) - dist;\n\n        if (pen <= 0) return false;\n        if (pen < minPen) {\n            minPen = pen;\n            bestNormal = vec3Dot(d, n) < 0 ? n : vec3Neg(n);\n        }\n        return true;\n    }\n\n    // Test 15 SAT axes\n    for (let i = 0; i < 3; i++) {\n        if (!testAxis(axesA[i])) return null;\n        if (!testAxis(axesB[i])) return null;\n    }\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (!testAxis(vec3Cross(axesA[i], axesB[j]))) return null;\n        }\n    }\n\n    // Generate proper contact manifold based on the type of contact\n    const contactPoints: ContactPoint[] = [];\n\n    // Determine which body's face is the reference (the one whose normal we're using)\n    const volumeA = fpMul(fpMul(hA.x, hA.y), hA.z);\n    const volumeB = fpMul(fpMul(hB.x, hB.y), hB.z);\n\n    // Find all vertices of the incident body (smaller one) that are below the reference face\n    const incidentBody = volumeB <= volumeA ? b : a;\n    const incidentHalf = volumeB <= volumeA ? hB : hA;\n    const referenceBody = volumeB <= volumeA ? a : b;\n\n    // For each vertex of the incident body, project onto reference face and check penetration\n    const signs: [number, number, number][] = [\n        [-1, -1, -1], [-1, -1, 1], [-1, 1, -1], [-1, 1, 1],\n        [1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]\n    ];\n\n    // Calculate reference face plane normal\n    const refFaceNormal = volumeB <= volumeA ? bestNormal : vec3Neg(bestNormal);\n\n    interface VertexContact {\n        point: Vec3;\n        depth: Fixed;\n    }\n    const vertexContacts: VertexContact[] = [];\n\n    const refAxes = volumeB <= volumeA ? axesA : axesB;\n    const refHalf = volumeB <= volumeA ? hA : hB;\n\n    for (const [sx, sy, sz] of signs) {\n        const localV = vec3(\n            fpMul(incidentHalf.x, toFixed(sx)),\n            fpMul(incidentHalf.y, toFixed(sy)),\n            fpMul(incidentHalf.z, toFixed(sz))\n        );\n        const worldV = vec3Add(incidentBody.position, quatRotateVec3(incidentBody.rotation, localV));\n\n        // Calculate how deep this vertex is along the collision normal direction\n        const toVertex = vec3Sub(worldV, referenceBody.position);\n        const normalDist = vec3Dot(toVertex, refFaceNormal);\n\n        // Get the reference body's extent along the normal\n        const refExtent = fpMul(fpAbs(vec3Dot(refAxes[0], refFaceNormal)), refHalf.x) +\n                          fpMul(fpAbs(vec3Dot(refAxes[1], refFaceNormal)), refHalf.y) +\n                          fpMul(fpAbs(vec3Dot(refAxes[2], refFaceNormal)), refHalf.z);\n\n        const depth = normalDist + refExtent;\n\n        if (depth > 0) {\n            vertexContacts.push({ point: worldV, depth });\n        }\n    }\n\n    // Sort by depth and take the deepest vertices (up to 4 for face contact)\n    // Use position as tiebreaker for deterministic stable sort\n    vertexContacts.sort((a, b) => {\n        const depthDiff = b.depth - a.depth;\n        if (depthDiff !== 0) return depthDiff;\n        // Tiebreaker using point position for determinism\n        return (a.point.x - b.point.x) || (a.point.y - b.point.y) || (a.point.z - b.point.z);\n    });\n\n    // Use vertices with similar depth (within threshold of deepest)\n    const DEPTH_THRESHOLD = toFixed(0.05);\n    const maxDepth = vertexContacts.length > 0 ? vertexContacts[0].depth : 0 as Fixed;\n\n    for (const vc of vertexContacts) {\n        if (vc.depth > maxDepth - DEPTH_THRESHOLD) {\n            contactPoints.push({ point: vc.point, penetration: vc.depth });\n        }\n        if (contactPoints.length >= 4) break; // Max 4 contact points\n    }\n\n    // Fallback: use the SAT penetration point\n    if (contactPoints.length === 0) {\n        const midPoint = vec3Scale(vec3Add(a.position, b.position), FP_HALF);\n        contactPoints.push({ point: midPoint, penetration: minPen });\n    }\n\n    return { bodyA: a, bodyB: b, normal: bestNormal, points: contactPoints };\n}\n\nexport function detectCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const typeA = a.shape.type;\n    const typeB = b.shape.type;\n\n    if (typeA === ShapeType.Sphere && typeB === ShapeType.Sphere) {\n        return sphereSphereCollision(a, b);\n    } else if (typeA === ShapeType.Sphere && typeB === ShapeType.Box) {\n        return sphereBoxCollision(a, b);\n    } else if (typeA === ShapeType.Box && typeB === ShapeType.Sphere) {\n        const contact = sphereBoxCollision(b, a);\n        if (contact) {\n            // Swap bodies and flip normal\n            return {\n                bodyA: a,\n                bodyB: b,\n                normal: vec3Neg(contact.normal),\n                points: contact.points\n            };\n        }\n        return null;\n    } else {\n        return boxBoxCollision(a, b);\n    }\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\nexport function resolveCollision(contact: Contact): void {\n    const { bodyA, bodyB, normal, points } = contact;\n\n    // Skip if both are static/kinematic or no contact points\n    if (bodyA.invMass === 0 && bodyB.invMass === 0) return;\n    if (points.length === 0) return;\n\n    // Calculate relative velocity along collision normal to determine wake conditions\n    const relVelForWake = vec3Sub(bodyA.linearVelocity, bodyB.linearVelocity);\n    const impactVelocity = fpAbs(vec3Dot(relVelForWake, normal));\n\n    // Check if this is a resting contact (bodies gently settling, not impacting)\n    const isRestingContact = impactVelocity < WAKE_VELOCITY_THRESHOLD;\n\n    // If one body is sleeping and this is a resting contact, keep it sleeping\n    // Apply position correction only without waking\n    if (isRestingContact && (bodyA.isSleeping || bodyB.isSleeping)) {\n        for (const cp of points) {\n            const penetration = cp.penetration;\n            if (penetration > SLOP) {\n                const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n                if (pureInvMassSum > 0) {\n                    const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n                    const correctionVec = vec3Scale(normal, correction);\n\n                    // Only move non-sleeping bodies\n                    if (bodyA.invMass > 0 && !bodyA.isSleeping) {\n                        bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n                    }\n                    if (bodyB.invMass > 0 && !bodyB.isSleeping) {\n                        bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    const numContacts = points.length;\n    const invNumContacts = fpDiv(FP_ONE, toFixed(numContacts));\n\n    // Restitution (use minimum)\n    const e = fpMin(bodyA.restitution, bodyB.restitution);\n    const frictionCoeff = fpDiv(bodyA.friction + bodyB.friction, toFixed(2));\n\n    // Process each contact point\n    for (const cp of points) {\n        const point = cp.point;\n        const penetration = cp.penetration;\n\n        // Calculate radius vectors from center of mass to contact point\n        const rA = vec3Sub(point, bodyA.position);\n        const rB = vec3Sub(point, bodyB.position);\n\n        // Calculate velocity at contact point (including rotation)\n        const velA = vec3Add(bodyA.linearVelocity, vec3Cross(bodyA.angularVelocity, rA));\n        const velB = vec3Add(bodyB.linearVelocity, vec3Cross(bodyB.angularVelocity, rB));\n        const relVel = vec3Sub(velA, velB);\n\n        const velAlongNormal = vec3Dot(relVel, normal);\n\n        // Only resolve if approaching\n        if (velAlongNormal < 0) {\n            // Calculate impulse magnitude\n            const rACrossN = vec3Cross(rA, normal);\n            const rBCrossN = vec3Cross(rB, normal);\n\n            const angularInertiaA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rACrossN, rACrossN), bodyA.invInertia);\n            const angularInertiaB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rBCrossN, rBCrossN), bodyB.invInertia);\n\n            const invMassSum = bodyA.invMass + bodyB.invMass + angularInertiaA + angularInertiaB;\n            let j = fpMul(-(FP_ONE + e), velAlongNormal);\n            j = fpDiv(j, invMassSum);\n            j = fpMul(j, invNumContacts);  // Distribute across contacts\n\n            const impulse = vec3Scale(normal, j);\n\n            if (bodyA.invMass > 0) {\n                applyImpulse(bodyA, impulse, point);\n            }\n            if (bodyB.invMass > 0) {\n                applyImpulse(bodyB, vec3Neg(impulse), point);\n            }\n\n            // Friction\n            const tangent = vec3Sub(relVel, vec3Scale(normal, velAlongNormal));\n            const tangentLenSq = vec3LengthSq(tangent);\n\n            if (tangentLenSq > toFixed(0.0001)) {\n                const tangentNorm = vec3Normalize(tangent);\n                const rACrossT = vec3Cross(rA, tangentNorm);\n                const rBCrossT = vec3Cross(rB, tangentNorm);\n\n                const angularInertiaTA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rACrossT, rACrossT), bodyA.invInertia);\n                const angularInertiaTB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rBCrossT, rBCrossT), bodyB.invInertia);\n\n                const invMassSumT = bodyA.invMass + bodyB.invMass + angularInertiaTA + angularInertiaTB;\n                const tangentSpeed = fpSqrt(tangentLenSq);\n                let jt = fpDiv(tangentSpeed, invMassSumT);\n                jt = fpMul(jt, invNumContacts);  // Distribute\n\n                const maxFriction = fpMul(fpAbs(j), frictionCoeff);\n                if (jt > maxFriction) jt = maxFriction;\n\n                const frictionImpulse = vec3Scale(tangentNorm, -jt);\n\n                if (bodyA.invMass > 0) {\n                    applyImpulse(bodyA, frictionImpulse, point);\n                }\n                if (bodyB.invMass > 0) {\n                    applyImpulse(bodyB, vec3Neg(frictionImpulse), point);\n                }\n            }\n        }\n\n        // Position correction for this contact\n        if (penetration > SLOP) {\n            const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n            const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n            const scaledCorrection = fpMul(correction, invNumContacts);  // Distribute\n            const correctionVec = vec3Scale(normal, scaledCorrection);\n\n            if (bodyA.invMass > 0) {\n                bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n            }\n            if (bodyB.invMass > 0) {\n                bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n            }\n        }\n    }\n}\n", "/**\n * Physics World\n *\n * Manages the physics simulation including gravity, collision detection,\n * and integration of velocities and positions.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Clone, vec3Add, vec3Scale, vec3LengthSq } from '../../math/vec';\nimport { quatFromAxisAngle, quatMul, quatNormalize } from '../../math/quat';\nimport { aabbOverlap } from './shapes';\nimport { RigidBody, BodyType } from './rigid-body';\nimport { Contact, computeAABB, detectCollision, resolveCollision } from './collision';\nimport { shouldCollide } from './layers';\nimport { TriggerState, TriggerEvent } from './trigger';\n\n// ============================================\n// Constants\n// ============================================\n\nconst GRAVITY: Vec3 = { x: 0, y: toFixed(-30), z: 0 };  // -30 units/s\u00B2\nconst LINEAR_DAMPING = toFixed(0.1);      // 10% velocity loss per frame\nconst ANGULAR_DAMPING = toFixed(0.1);     // 10% angular velocity loss per frame\nconst SLEEP_THRESHOLD = toFixed(0.12);    // Sleep when nearly stopped\nconst SLEEP_FRAMES_REQUIRED = 20;         // ~0.33 seconds at 60fps before sleeping\nconst CONTACT_SLEEP_BONUS = 10;           // Extra sleep frames when in stable contact\nconst COLLISION_ITERATIONS = 8;           // Multiple iterations for stability\n\n// ============================================\n// World Interface\n// ============================================\n\nexport interface World {\n    bodies: RigidBody[];\n    gravity: Vec3;\n    dt: Fixed;  // Fixed timestep\n    triggers: TriggerState;  // Trigger/sensor event tracking\n    /** Step the physics simulation */\n    step(): Contact[];\n}\n\nexport function createWorld(dt: number = 1 / 60): World {\n    const world: World = {\n        bodies: [],\n        gravity: vec3Clone(GRAVITY),\n        dt: toFixed(dt),\n        triggers: new TriggerState(),\n        step() {\n            return stepWorld(world);\n        }\n    };\n    return world;\n}\n\nexport function addBody(world: World, body: RigidBody): void {\n    world.bodies.push(body);\n}\n\nexport function removeBody(world: World, body: RigidBody): void {\n    const index = world.bodies.indexOf(body);\n    if (index >= 0) {\n        world.bodies.splice(index, 1);\n        // Clean up trigger overlaps involving this body\n        world.triggers.removeBody(body);\n    }\n}\n\n// ============================================\n// Ground Check\n// ============================================\n\n/**\n * Check if a body is grounded (has a surface below it within threshold)\n * @param world The physics world\n * @param body The body to check\n * @param threshold Distance below to check (default 0.15)\n * @returns true if grounded\n */\nexport function isGrounded(world: World, body: RigidBody, threshold: number = 0.15): boolean {\n    const thresholdFP = toFixed(threshold);\n\n    for (const other of world.bodies) {\n        if (other === body) continue;\n\n        // Check if there's collision contact with normal pointing up\n        const contact = detectCollision(body, other);\n        if (contact && contact.normal.y > FP_HALF) {\n            // Normal pointing up means surface is below\n            return true;\n        }\n\n        // Also check slightly below current position\n        const savedY = body.position.y;\n        body.position.y = body.position.y - thresholdFP;\n        const contactBelow = detectCollision(body, other);\n        body.position.y = savedY;\n\n        if (contactBelow && contactBelow.normal.y > FP_HALF) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// ============================================\n// World Step\n// ============================================\n\nexport function stepWorld(world: World): Contact[] {\n    const { gravity, dt, triggers } = world;\n    const contacts: Contact[] = [];\n    const triggerOverlaps: TriggerEvent[] = [];\n\n    // CRITICAL: Sort bodies by label for deterministic collision processing order\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\n\n    // Track which bodies are in stable resting contact (for island sleeping)\n    const restingContactBodies = new Set<RigidBody>();\n    const sleepingContactBodies = new Set<RigidBody>();\n\n    // First pass: identify resting contacts and sleeping contact pairs\n    for (let i = 0; i < bodies.length; i++) {\n        for (let j = i + 1; j < bodies.length; j++) {\n            const a = bodies[i];\n            const b = bodies[j];\n\n            if (a.invMass === 0 && b.invMass === 0) continue;\n            if (!shouldCollide(a.filter, b.filter)) continue;\n\n            const aabbA = computeAABB(a);\n            const aabbB = computeAABB(b);\n            if (!aabbOverlap(aabbA, aabbB)) continue;\n\n            const contact = detectCollision(a, b);\n            if (contact) {\n                if (fpAbs(contact.normal.y) > FP_HALF) {\n                    restingContactBodies.add(a);\n                    restingContactBodies.add(b);\n\n                    if (a.isSleeping && b.type === BodyType.Dynamic) {\n                        const bSpeedSq = vec3LengthSq(b.linearVelocity) + vec3LengthSq(b.angularVelocity);\n                        if (bSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(b);\n                        }\n                    }\n                    if (b.isSleeping && a.type === BodyType.Dynamic) {\n                        const aSpeedSq = vec3LengthSq(a.linearVelocity) + vec3LengthSq(a.angularVelocity);\n                        if (aSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Integrate velocities (apply gravity)\n    for (const body of bodies) {\n        if (body.type !== BodyType.Dynamic) continue;\n        if (body.isSleeping) continue;\n\n        body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(gravity, dt));\n\n        let linearDamp = FP_ONE - LINEAR_DAMPING;\n        let angularDamp = FP_ONE - ANGULAR_DAMPING;\n\n        if (restingContactBodies.has(body)) {\n            linearDamp = fpMul(linearDamp, toFixed(0.95));\n            angularDamp = fpMul(angularDamp, toFixed(0.9));\n        }\n\n        body.linearVelocity = vec3Scale(body.linearVelocity, linearDamp);\n        body.angularVelocity = vec3Scale(body.angularVelocity, angularDamp);\n    }\n\n    // Multiple collision iterations for stability\n    for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {\n        for (let i = 0; i < bodies.length; i++) {\n            for (let j = i + 1; j < bodies.length; j++) {\n                const a = bodies[i];\n                const b = bodies[j];\n\n                if (a.invMass === 0 && b.invMass === 0) continue;\n                if (!shouldCollide(a.filter, b.filter)) continue;\n\n                const aabbA = computeAABB(a);\n                const aabbB = computeAABB(b);\n                if (!aabbOverlap(aabbA, aabbB)) continue;\n\n                const contact = detectCollision(a, b);\n                if (contact) {\n                    // Check if either body is a trigger\n                    const isTriggerCollision = a.isTrigger || b.isTrigger;\n\n                    if (isTriggerCollision) {\n                        // Record trigger overlap (only on first iteration)\n                        if (iter === 0) {\n                            // Determine which is the trigger\n                            if (a.isTrigger) {\n                                triggerOverlaps.push({ trigger: a, other: b });\n                            }\n                            if (b.isTrigger) {\n                                triggerOverlaps.push({ trigger: b, other: a });\n                            }\n                        }\n                        // Skip physics response for triggers\n                    } else {\n                        // Normal collision - apply physics response\n                        if (iter === 0) contacts.push(contact);\n                        resolveCollision(contact);\n                    }\n                }\n            }\n        }\n    }\n\n    // Process trigger events after collision detection\n    triggers.processOverlaps(triggerOverlaps);\n\n    // Integrate positions\n    for (const body of bodies) {\n        if (body.type === BodyType.Static) continue;\n        if (body.isSleeping) continue;\n\n        // Clamp tiny linear velocities to zero\n        const linearClampThreshold = toFixed(0.05);\n        if (fpAbs(body.linearVelocity.x) < linearClampThreshold) body.linearVelocity.x = 0;\n        if (fpAbs(body.linearVelocity.y) < linearClampThreshold) body.linearVelocity.y = 0;\n        if (fpAbs(body.linearVelocity.z) < linearClampThreshold) body.linearVelocity.z = 0;\n\n        body.position = vec3Add(body.position, vec3Scale(body.linearVelocity, dt));\n\n        // Skip rotation integration if all rotations are locked\n        if (body.lockRotationX && body.lockRotationY && body.lockRotationZ) {\n            continue;\n        }\n\n        // Apply rotation locks\n        let angVelX = body.lockRotationX ? 0 : body.angularVelocity.x;\n        let angVelY = body.lockRotationY ? 0 : body.angularVelocity.y;\n        let angVelZ = body.lockRotationZ ? 0 : body.angularVelocity.z;\n\n        // Clamp tiny angular velocities to zero\n        const angularClampThreshold = toFixed(0.01);\n        if (fpAbs(angVelX) < angularClampThreshold) angVelX = 0;\n        if (fpAbs(angVelY) < angularClampThreshold) angVelY = 0;\n        if (fpAbs(angVelZ) < angularClampThreshold) angVelZ = 0;\n\n        body.angularVelocity.x = angVelX;\n        body.angularVelocity.y = angVelY;\n        body.angularVelocity.z = angVelZ;\n\n        const angVelLengthSq = fpMul(angVelX, angVelX) + fpMul(angVelY, angVelY) + fpMul(angVelZ, angVelZ);\n\n        if (angVelLengthSq > 0) {\n            const angSpeed = fpSqrt(angVelLengthSq);\n            const angle = fpMul(angSpeed, dt);\n            const invSpeed = fpDiv(FP_ONE, angSpeed);\n            const axis = {\n                x: fpMul(angVelX, invSpeed),\n                y: fpMul(angVelY, invSpeed),\n                z: fpMul(angVelZ, invSpeed)\n            };\n            const rotDelta = quatFromAxisAngle(axis, angle);\n            body.rotation = quatNormalize(quatMul(rotDelta, body.rotation));\n        }\n\n        // Sleep detection\n        const speedSq = vec3LengthSq(body.linearVelocity);\n        const angSpeedSq = vec3LengthSq(body.angularVelocity);\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\n\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\n            const sleepIncrement = sleepingContactBodies.has(body) ? (1 + CONTACT_SLEEP_BONUS) : 1;\n            body.sleepFrames += sleepIncrement;\n\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\n                body.isSleeping = true;\n                body.linearVelocity = vec3Zero();\n                body.angularVelocity = vec3Zero();\n            }\n        } else {\n            body.sleepFrames = 0;\n            body.isSleeping = false;\n        }\n    }\n\n    return contacts;\n}\n"],
  "mappings": "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AA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA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",
  "names": ["buffer", "input", "def", "input", "game", "input", "syncFieldsSet", "renderer", "game", "canvas", "game", "canvas", "input", "game", "vec2Zero", "vec2", "vec2Add", "vec2Scale", "vec2LengthSq", "vec2", "vec2Zero", "vec2Add", "vec2Scale", "vec2LengthSq", "vec2Zero", "game", "Layers", "DEFAULT_FILTER", "RESTITUTION_DEFAULT", "FRICTION_DEFAULT", "LINEAR_DAMPING", "ANGULAR_DAMPING", "SLEEP_THRESHOLD"]
}
